<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>数据库Database课程笔记-BUAA | fysszlr's blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/yomiya.png"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=2.0.7"><!-- inject head--><link rel="canonical" href="http://example.com/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><!-- aplayer--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css"><!-- katex--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="数据库Database课程笔记-BUAA 第一章 概述 数据库技术，是一种数据管理技术 数据库技术的软件实现就是DBMS（数据库管理系统） 数据库系统是在数据库管理系统基础上建立的具有数据处理功能的系统 12345678910111213graph RLA[数据库系统]B[数据库]"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="fysszlr's blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/yomiya.png"><link rel="apple-touch-icon" href="/img/pwa/yomiya.png" sizes="180x180"><script>console.log(' %c Solitude %c ' + '2.0.7' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: '2023-09-17 23:50:00',
    lazyload: {
        enable: true,
        error: '/img/error_load.avif'
    },
    copyright: {"limit":5,"author":"作者: fysszlr","link":"链接: ","source":"来源: fysszlr's blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"},"barrage":{"title":"热评"}},
    aside: {
        sayhello: {
            morning: "✨ 才...才不是想提醒你吃早饭呢",
            noon: "太阳甩在身后~ ☀️",
            afternoon: "下午的学习跟奶茶更配哦 🧋",
            night: "真的...现在就睡嘛（歪头",
            goodnight: "这是属于我们的🌙彻夜之歌",
        },
        sayhello2: ["坚持下去！","相信自己，你很棒！","每一步都是进步！","勇往直前，你可以的！","成功在望，继续努力！","从失败走向失败之路~"],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: true
    },
    comment: {"avatar":"https://gravatar.com/avatar","commentBarrage":true},
    lightbox: 'fancybox',
    post_ai: false,
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","music":{"start":"播放音乐","stop":"暂停音乐"},"barrage":{"open":"显示热评","close":"关闭热评"},"translate":{"translateDelay":0,"defaultEncoding":2}},
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: true,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- background img--><!-- loading--><div id="loading-box" onclick="preloader.endLoading();" style="zoom:1"><div class="loading-bg"><img class="loading-img nolazyload" src="/img/pwa/yomiya.png" alt="loading image"></div></div><script>const preloader = {
    isLoaded: false,
    endLoading: () => {
        if (!preloader.isLoaded) {
            document.getElementById('loading-box').classList.add('loaded');
            preloader.isLoaded = true;
        }
    },
    initLoading: () => {
        document.getElementById('loading-box').classList.remove('loaded');
        preloader.isLoaded = false;
    },
    removePaceDone: () => {
        document.getElementById('body').classList = 'pace-done';
    }
}

window.addEventListener('load', () => {
    preloader.endLoading();
});

window.addEventListener('pjax:send', () => {
    preloader.initLoading();
});

document.addEventListener('pjax:complete', () => {
    preloader.endLoading();
});

setTimeout(() => {
    preloader.endLoading();
}, 5000);</script><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude fa-solid fa-xmark"></i></div><div class="console-card-group"><div class="console-card-group-right"><div class="console-card tags" onclick="sco.hideConsole()"><div class="card-content"><div class="author-content-item-tips">标签</div><div class="author-content-item-title">寻找感兴趣的领域</div></div><div class="card-tag-cloud"><a href="/tags/CO/">CO<sup>6</sup></a><a href="/tags/%E5%8D%8E%E4%B8%BA/">华为<sup>2</sup></a><a href="/tags/c-c/">c++&amp;c#<sup>2</sup></a><a href="/tags/OOpre/">OOpre<sup>5</sup></a><a href="/tags/hexo/">hexo<sup>1</sup></a><a href="/tags/LLM/">LLM<sup>1</sup></a><a href="/tags/fysszlr/">fysszlr<sup>1</sup></a><a href="/tags/%E9%9F%B3%E4%B9%90/">音乐<sup>1</sup></a><a href="/tags/%E8%AE%B0%E5%BD%95/">记录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库<sup>1</sup></a></div></div><div class="console-card history" onclick="sco.hideConsole()"><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">2025/01</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">2024/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">2024/08</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">2024/07</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">2023/12</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">2023/11</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">2023/10</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span class="card-archive-list-count-unit">篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">2023/09</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span class="card-archive-list-count-unit">篇</span></div></a></li></ul></div></div></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude fa-solid fa-circle-half-stroke"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude fa-solid fa-mattress-pillow"></i></span></div><div class="console-btn-item" id="consoleMusic" onclick="sco.musicToggle()"><span class="music-switch" title="音乐开关"><i class="solitude fa-solid fa-compact-disc"></i></span></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="sco.switchCommentBarrage()"><span class="commentBarrage"><i class="solitude fa-solid fa-comment"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Article</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Friends</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>Links</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="solitude  fas fa-gift"></i><span>Treasure</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Myself</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay/"><i class="solitude  fas fa-wifi"></i><span>Says</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  fas fa-music"></i><span>Music</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/CO/">CO<sup>6</sup></a><a href="/tags/%E5%8D%8E%E4%B8%BA/">华为<sup>2</sup></a><a href="/tags/c-c/">c++&amp;c#<sup>2</sup></a><a href="/tags/OOpre/">OOpre<sup>5</sup></a><a href="/tags/hexo/">hexo<sup>1</sup></a><a href="/tags/LLM/">LLM<sup>1</sup></a><a href="/tags/fysszlr/">fysszlr<sup>1</sup></a><a href="/tags/%E9%9F%B3%E4%B9%90/">音乐<sup>1</sup></a><a href="/tags/%E8%AE%B0%E5%BD%95/">记录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">算法设计与分析<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">fysszlr</span><i class="solitude fa-solid fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">数据库Database课程笔记-BUAA</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>Home</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Article</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  fas fa-folder-closed"></i><span>Archives</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  fas fa-clone"></i><span>Categories</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  fas fa-tags"></i><span>Tags</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Friends</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/links/"><i class="solitude  fas fa-user-group"></i><span>Links</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="solitude  fas fa-gift"></i><span>Treasure</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>Myself</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/essay/"><i class="solitude  fas fa-wifi"></i><span>Says</span></a></li><li><a class="site-page child" href="/music/"><i class="solitude  fas fa-music"></i><span>Music</span></a></li></ul></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html" title=""><i class="solitude fas fa-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude fa-solid fa-dice-d6"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude fa-solid fa-magnifying-glass"></i></a></div><div class="nav-button" id="nav-console"><a class="console_switchbutton" onclick="sco.showConsole()" title="中控台" href="javascript:void(0);"><label><i class="left"></i><i class="center"></i><i class="right"></i></label></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude fa-solid fa-arrow-up"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fa-solid fa-bars"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="https://images.pexels.com/photos/1148820/pexels-photo-1148820.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800" alt="数据库Database课程笔记-BUAA"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tags-name tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>数据库</span></a></div></div></div></div><h1 class="post-title">数据库Database课程笔记-BUAA</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2025-01-10 14:28:00"><i class="post-meta-icon solitude fa-solid fa-calendar-days"></i><time datetime="2025-01-10T06:28:00.000Z">2025-01-10T06:28:00.000Z</time></span><span class="post-meta-date" title="最后更新于 2025-01-10 14:29:49"><i class="post-meta-icon solitude fa-solid fa-arrow-rotate-right"></i><time datetime="2025-01-10T06:29:49.522Z">2025-01-10T06:29:49.522Z</time></span><span class="post-meta-wordcount"><i class="post-meta-icon solitude fa-solid fa-file-word" title="文章字数"></i><span class="word-count">18.4k</span><span class="post-meta-separator"></span><i class="post-meta-icon solitude fa-solid fa-clock" title="阅读耗时"></i><span>66 min</span></span><a class="post-meta-pv" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="文章热度"><i class="post-meta-icon solitude fa-solid fa-fire-flame-curved"></i><span id="twikoo_visitors"><i class="solitude fa-solid fa-spinner"></i></span></a></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>数据库Database课程笔记-BUAA</h1>
<h2 id="第一章-概述">第一章 概述</h2>
<blockquote>
<ul>
<li>
<p>数据库技术，是一种数据管理技术</p>
</li>
<li>
<p>数据库技术的软件实现就是DBMS（数据库管理系统）</p>
</li>
<li>
<p>数据库系统是在数据库管理系统基础上建立的具有数据处理功能的系统</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A[数据库系统]</span><br><span class="line">B[数据库]</span><br><span class="line">C[数据库管理系统（DBMS）]</span><br><span class="line">D[数据库技术]</span><br><span class="line">E[应用程序]</span><br><span class="line">F[数据管理技术]</span><br><span class="line">C&lt;-.数据处理.-&gt;B</span><br><span class="line">C--数据管理--&gt;A</span><br><span class="line">B--&gt;A</span><br><span class="line">E--&gt;A</span><br><span class="line">D--软件实现--&gt;C</span><br><span class="line">D--属于--&gt;F</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="数据管理技术的发展">数据管理技术的发展</h3>
<blockquote>
<p>数据库与其它数据管理技术相比有什么特点？</p>
<p>数据库技术要解决的基本问题是什么？</p>
</blockquote>
<h4 id="数据库技术产生与发展背景">数据库技术产生与发展背景</h4>
<ul>
<li>1960s 操作系统、算法与数据结构、软件工程日趋成熟，出现数据库技术（业务数据处理）（科学计算）</li>
<li>层次、网状、关系三类数据库经过发展，关系数据库最终成为主流</li>
<li>今天 出现NewSQL、NoSQL（延申到智能化数据处理领域）</li>
</ul>
<h4 id="数据管理技术的发展过程">数据管理技术的发展过程</h4>
<ul>
<li>
<p>人工管理阶段</p>
<ul>
<li>
<p>时间：&lt;1950s</p>
<ul>
<li>
<p>背景：只有磁带、卡片等；没有操作系统；主要用于科学计算</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>数据不在计算机上存储</p>
</li>
<li>
<p>程序规定数据的逻辑结构与物理结构，数据与程序不具有独立性（由程序员设计）</p>
</li>
<li>
<p>应用程序与数据组一一对应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[应用程序1]-.-D[文件1]</span><br><span class="line">B[应用程序2]-.-E[文件2]</span><br><span class="line">C[应用程序3]-.-F[文件3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统阶段</p>
<ul>
<li>
<p>时间：1950s-1960s</p>
<ul>
<li>
<p>背景：出现磁盘、磁鼓；出现文件系统；计算机不但用于科学计算，还用于管理</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>数据以文件形式保留在外存上</p>
</li>
<li>
<p>数据存取以记录为单位</p>
</li>
<li>
<p>程序与数据有一定独立性</p>
</li>
<li>
<p>文件与程序基本上是一一对应关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">G[存取系统]</span><br><span class="line">A[应用程序1]-.-G-.-D[文件1]</span><br><span class="line">B[应用程序2]-.-G-.-E[文件2]</span><br><span class="line">C[应用程序3]-.-G-.-F[文件3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​</p>
<pre><code>* 问题：数据冗余度大、存储空间浪费、易造成数据的不一致性、维护难度大
</code></pre>
<ul>
<li>数据库系统阶段</li>
</ul>
<h4 id="数据库系统基本问题与关键技术">数据库系统基本问题与关键技术</h4>
<ul>
<li>需求：
<ul>
<li>集成：将特定应用环境中的所有相关的数据，进行统一地、集中地按照一定数据结构进行存储</li>
<li>共享：数据可为多个不同的用户所共享</li>
</ul>
</li>
<li>核心技术：
<ul>
<li>数据模型</li>
<li>数据独立性</li>
</ul>
</li>
<li>核心软件：数据库管理系统DBMS（Database Manage System）
<ul>
<li>最早的DBMS——IMS，IDS</li>
<li>查尔斯·巴赫曼 数据库技术之父：在《IDS与DBTG报告》中提出“<strong>三级模式、两级映像</strong>”</li>
</ul>
</li>
</ul>
<h4 id="数据库系统数据管理特点">数据库系统数据管理特点</h4>
<ul>
<li>
<p>面向全组织的复杂的数据结构</p>
<ul>
<li>
<p>在描述数据时，不仅描述数据本身，还要描述数据之间的联系，使整个组织的<strong>数据结构化</strong></p>
</li>
<li>
<p>数据库与文件系统的根本区别</p>
</li>
</ul>
</li>
<li>
<p>数据冗余度小，易扩充</p>
<ul>
<li>
<p>数据库可以随时选择子集，灵活度高</p>
</li>
<li>
<p>具有较高的数据和程序的独立性</p>
<ul>
<li>
<p>三级模式、两级映像</p>
</li>
<li>
<pre><code class="language-mermaid">graph BT
a[应用1]
b[应用2]
c[应用3]
d[应用4]
e[局部逻辑结构（外模式1）]
f[局部逻辑结构（外模式2）]
g[全局逻辑结构（模式）]
h[物理结构（内模式）]
i[数据库]
e--&gt;a
e--&gt;b
f--&gt;c
f--&gt;d
g--外模式/模式映像1--&gt;e
g--外模式/模式映像2--&gt;f
h&lt;--模式/内模式映像--&gt;g
i&lt;--&gt;h
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* 统一的数据控制功能</span><br><span class="line"></span><br><span class="line">  * 数据的安全性控制（保护非法操作）</span><br><span class="line"></span><br><span class="line">  * 数据的完整性控制（数据的正确性）</span><br><span class="line"></span><br><span class="line">  * 并发控制</span><br><span class="line"></span><br><span class="line">  * 数据库恢复</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 数据的最小存取单位是数据项</span><br><span class="line">  * 既可以存取一个或一组记录，也可以存取数据中某个或一组数据项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 数据模型</span><br><span class="line"></span><br><span class="line">&gt; 数据库技术要解决的基本问题是什么？数据的集成问题</span><br><span class="line"></span><br><span class="line">#### 数据模型定义</span><br><span class="line"></span><br><span class="line">* 数据模型用来抽像和表示现实世界中的数据和信息</span><br><span class="line"></span><br><span class="line">* 目标：现实世界数据和机器世界数据的转换</span><br><span class="line"></span><br><span class="line">#### 数据模型的层次</span><br><span class="line"></span><br><span class="line">* 将现实世界业务的数据进行认识、抽象，转化为信息世界中的**概念模型**（也称信息模型）</span><br><span class="line">* 将概念模型转化为机器世界数据中的**数据模型**（如层次、网状、关系）</span><br><span class="line"></span><br><span class="line">#### 概念模型</span><br><span class="line"></span><br><span class="line">* 基于信息世界的概念，表达各种信息</span><br><span class="line">* 有较强的语义表达能力，简单、清晰、便于理解</span><br><span class="line">* 常用E-R法进行表示</span><br><span class="line"></span><br><span class="line">#### E-R法（Entity-Relation Approach）</span><br><span class="line"></span><br><span class="line">* 目标：描述显示世界，并转换成相应的数据模型</span><br><span class="line"></span><br><span class="line">* 基本概念</span><br><span class="line"></span><br><span class="line">  * **实体**（Entity）：客观存在并可相互区分的事物 **长方体**</span><br><span class="line"></span><br><span class="line">  * **属性**（Attribute）：实体所具有的某一特性 **椭圆形**</span><br><span class="line"></span><br><span class="line">  * **码/键**（Key）：唯一标识实体的属性集</span><br><span class="line"></span><br><span class="line">  * **域**（Domain）：某个属性的取值范围</span><br><span class="line"></span><br><span class="line">  * **实体型**（Entity Type）：表示一类实体，用实体名及其属性名集合来抽象、刻画</span><br><span class="line"></span><br><span class="line">  * **联系**（Relation）：实体型之间的联系，是实体之间的相互关联 **菱形**</span><br><span class="line">    * 名称</span><br><span class="line">    * 类型：一对一、一对多、多对多</span><br><span class="line">    * 可以具有属性</span><br><span class="line"></span><br><span class="line">* 联系的语义扩充</span><br><span class="line"></span><br><span class="line">  &gt; 我从没在这章以外的题目中碰到这几个</span><br><span class="line"></span><br><span class="line">  * 存在依赖</span><br><span class="line">    某实体存在依赖于另一实体的存在，称该实体为弱实体，该实体**存在依赖**另一实体</span><br><span class="line">  * 标识依赖</span><br><span class="line">    如果实体不能由它自己的属性来唯一标识，而必须通过与它相联系的另一实体一起来标识 ，那么称该实体**标识依赖**于另一个实体</span><br><span class="line">  * 实体的子类</span><br><span class="line">    子类可以继承父类属性，并定义自己的属性；子类间交集不一定为空</span><br><span class="line"></span><br><span class="line">* 注意：</span><br><span class="line"></span><br><span class="line">  * 同一个实体机内部各实体之间也可以存在不同类型的联系</span><br><span class="line">  * 三个或多个实体型间可能具有联系（按语义确定类型）</span><br><span class="line">  * 两个实体型之间可具有多种联系</span><br><span class="line"></span><br><span class="line">#### 数据模型</span><br><span class="line"></span><br><span class="line">* 定义：数据模型是概念的集合，精确描述数据库系统的**静态特性、动态特性和完整性约束**</span><br><span class="line">* 三要素：数据结构、数据操作、完整性约束</span><br><span class="line">* 数据结构（怎么存）</span><br><span class="line">  * 由描述数据对象以及对象之间联系的一组概念组成</span><br><span class="line">  * 描述对象的类型、内容、性质的概念，如关系模型中的域、属性等；描述对象之间联系的概念，如关系模型中的关系</span><br><span class="line">  * 是数据**静态特性**的描述</span><br><span class="line">  * 是刻画数据模型**最重要**的方法，通常按照数据结构的类型来命名数据模型</span><br><span class="line">* 数据操作（怎么改）</span><br><span class="line">  * 是对数据库中各种数据对象（型）的实例（值）允许执行的操作集合，包括操作及操作规则</span><br><span class="line">  * 定义操作的确切含义、操作符号、操作规则及操作语言</span><br><span class="line">  * 是数据**动态特性**的描述</span><br><span class="line">  * 数据库主要有**检索和更新**（插、删、改）两大类操作</span><br><span class="line">* 完整性约束</span><br><span class="line">  * 是**完整性规则**的集合</span><br><span class="line">  * 完整性规则是给定的数据模型中数据及其联系所有的制约和依存规则，用以保证数据的正确、相容；</span><br><span class="line">  * 完整约束条件包括：</span><br><span class="line">    * 符合这种数据模型所必须遵守的基本的通用的完整性约束条件</span><br><span class="line">    * 针对具体数据的特定语义约束条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据模型的分类</span><br><span class="line"></span><br><span class="line">* 层次模型</span><br><span class="line">  * ”树结构“表示联系</span><br><span class="line">* 网状模型</span><br><span class="line">  * ”图结构“表示联系</span><br><span class="line">* 关系模型</span><br><span class="line">  * ”二维表“表示联系</span><br><span class="line">  * 关系中的每个分量是不可分的数据项</span><br><span class="line"></span><br><span class="line">### 数据库系统结构</span><br><span class="line"></span><br><span class="line">&gt; 有效解决这些问题的技术是什么？</span><br><span class="line"></span><br><span class="line">#### 逻辑结构 vs. 物理结构</span><br><span class="line"></span><br><span class="line">* 逻辑结构：数据在程序中定义的结构</span><br><span class="line">* 物理结构：文件在存储介质上的结构</span><br><span class="line"></span><br><span class="line">#### 数据独立性</span><br><span class="line"></span><br><span class="line">&gt; 解决数据库的共享问题</span><br><span class="line"></span><br><span class="line">* 数据独立性由数据和程序共同决定</span><br><span class="line">* 如果数据**物理结构**改变，不需要修改程序，则有**物理独立性**（通过文件系统解决）</span><br><span class="line">* 如果数据**逻辑结构**改变，不需要修改程序，则有**逻辑独立性**（通过SQL解决）</span><br><span class="line">* 如果修改数据，则必须修改程序，则无数据独立性（如果不具有物理独立性或逻辑独立性，则无数据独立性）</span><br><span class="line"></span><br><span class="line">#### 三级模式、两级映像</span><br><span class="line"></span><br><span class="line">* 用于实现物理独立性及逻辑独立性</span><br><span class="line"></span><br><span class="line">* 数据库结构多层次抽象，层次之间建立映射/对应关系</span><br><span class="line"></span><br><span class="line">* ```mermaid</span><br><span class="line">  graph BT</span><br><span class="line">  a[应用1]</span><br><span class="line">  b[应用2]</span><br><span class="line">  c[应用3]</span><br><span class="line">  d[应用4]</span><br><span class="line">  e[局部逻辑结构（外模式1）]</span><br><span class="line">  f[局部逻辑结构（外模式2）]</span><br><span class="line">  g[全局逻辑结构（模式）]</span><br><span class="line">  h[物理结构（内模式）]</span><br><span class="line">  i[数据库]</span><br><span class="line">  e--&gt;a</span><br><span class="line">  e--&gt;b</span><br><span class="line">  f--&gt;c</span><br><span class="line">  f--&gt;d</span><br><span class="line">  g--外模式/模式映像1--&gt;e</span><br><span class="line">  g--外模式/模式映像2--&gt;f</span><br><span class="line">  h&lt;--模式/内模式映像--&gt;g</span><br><span class="line">  i&lt;--&gt;h</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库由OS管理，其它部分由DBMS管理；OS和DBMS统一由DBA管理</p>
</li>
<li>
<p><strong>模式</strong></p>
<ul>
<li>是数据库中全体数据的<strong>逻辑结构和特性</strong>的描述</li>
<li>是所有用户的公共数据视图</li>
<li>也称为逻辑模式、概念模式</li>
<li>用DDL（Data Description Language）进行定义</li>
<li>三级模式的<strong>核心</strong></li>
</ul>
</li>
<li>
<p><strong>外模式</strong></p>
<ul>
<li>与某一特定应用有关的数据的逻辑表示</li>
<li>是个别用户的数据视图</li>
<li>也称为子模式、用户模式</li>
<li>通常是<strong>模式的子集</strong></li>
</ul>
</li>
<li>
<p><strong>内模式</strong></p>
<ul>
<li>对数据的<strong>物理结构和存储方式</strong>的描述</li>
<li>通常用内模式DDL定义</li>
<li>我们程序员不用管🐶</li>
</ul>
</li>
<li>
<p>外模式/模式映像</p>
<ul>
<li>解决数据的逻辑独立性</li>
</ul>
</li>
<li>
<p>模式/内模式映像</p>
<ul>
<li>解决数据的物理独立性</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>保证数据的独立性</li>
<li>简化用户接口，方便用户使用</li>
<li>有利于数据共享</li>
<li>有利于数据的安全保密</li>
</ul>
</li>
</ul>
<h4 id="DBMS主要功能">DBMS主要功能</h4>
<blockquote>
<p>DBMS是数据库系统的核心软件，在操作系统的支持下工作</p>
</blockquote>
<ul>
<li>数据库定义功能
<ul>
<li>提供DDL语言描述外模式、模式、内模式</li>
<li><strong>模式翻译程序</strong>将源模式翻译成目标模式</li>
</ul>
</li>
<li>数据存取功能
<ul>
<li>提供DML语言（Data manipulation language）对数据库进行检索、插入、修改、删除</li>
</ul>
</li>
<li>数据库运行管理
<ul>
<li>并发控制、存取控制、完整性约束条件检查和执行，日志组织和管理，事务管理和自动恢复</li>
</ul>
</li>
<li>数据组织、存储和管理</li>
<li>数据库的建立和维护功能</li>
</ul>
<h2 id="第二章-关系数据库">第二章 关系数据库</h2>
<blockquote>
<p>E.F.Codd于70年代初提出关系数据模型与关系数据理论，因此获得1981年的ACM图灵奖</p>
<p>~~没想到四十多年后的今天我还在学这个（吐槽）~~🥹</p>
</blockquote>
<h3 id="引言">引言</h3>
<p>关系理论建立在集合代数理论基础上，有着坚实的数学基础</p>
<p>早期系统</p>
<ul>
<li>System R：IBM</li>
<li>INGRES：Berkeley</li>
</ul>
<p>目前主流系统</p>
<ul>
<li>Oracle、MySQL、PostgreSQL、DB2，SQL-Server等</li>
<li>国内：武汉达梦、人大金仓、华为OpenGauss</li>
</ul>
<p>GaussDB vs. OpenGauss</p>
<p>GaussDB：华为云数据库统称，包括多个版本，如 GaussDB(for MySQL)、GaussDB(for PostgreSQL) 等</p>
<p>OpenGauss：基于 PostgreSQL 的扩展和优化的开源数据库系统</p>
<hr>
<blockquote>
<p>关系数据模型是如何定义的？</p>
<p>关系模型的优点和缺点是什么？</p>
</blockquote>
<h3 id="关系模型的基本概念">关系模型的基本概念</h3>
<h4 id="关系的数学定义">关系的数学定义</h4>
<ul>
<li>
<p><strong>域（Domain）</strong><br>
一组具有相同数据类型值的集合</p>
</li>
<li>
<p><strong>元组</strong>和<strong>分量</strong><br>
给定一组域$D1,D2…$，$D1\times D2…$得到的笛卡尔积的每个元素$(d_1,d_2,…)$称为n元组（n-tuple），或简称<strong>元组</strong>，元组的每一个值$d_k$叫做<strong>分量</strong>，分量不可分</p>
</li>
<li>
<p>笛卡尔积可以表示为二维表<br>
关系也被称为二维表</p>
<table>
<thead>
<tr>
<th>$D_1$</th>
<th>$D2$</th>
<th>…</th>
<th>$D_n$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$d_1$</td>
<td>$d_2$</td>
<td>…</td>
<td>$d_n$</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>关系</strong><br>
笛卡尔积叫做在域$D_1, D_2…D_n$上的<strong>关系</strong>，用$R(D_1,D_2,…D_n)$表示<br>
n=1，单元关系<br>
n=2，二元关系<br>
二维表的每列称为<strong>属性(Attribute)</strong></p>
</li>
</ul>
<h4 id="关系的性质">关系的性质</h4>
<ul>
<li>列是同质的（Homogenenux），即每一列中的分量来自同一域</li>
<li>不同列可以出自同一域，每列必须有不同的属性名</li>
<li>行、列次序可以互换</li>
<li>任意两个元组不能完全相同</li>
<li>每一分量必须是不可再分的数据，满足这一条件的关系称为满足**第一范式（1NF）**的<br>
eg. 若某分量为二元组（a1, a2），则不满足第一范式</li>
</ul>
<h4 id="关系模型的数据结构">关系模型的数据结构</h4>
<blockquote>
<p>关系模型的数据结构就是“关系”</p>
</blockquote>
<ul>
<li>
<p>关系</p>
<ul>
<li>实体及实体之间的联系均用单一的数据结构——关系来约束</li>
</ul>
</li>
<li>
<p>基本概念</p>
<ul>
<li>
<p>关系、域、n目关系、元组、属性</p>
</li>
<li>
<p><strong>码（Key，键）</strong></p>
<ul>
<li><strong>候选码（Candidate key）</strong>：关系中的某一<strong>属性组</strong>，若它的值唯一地标识了一个元组，并具有<strong>最小性</strong>，则为<strong>候选码</strong></li>
<li><strong>主码（Primary key，首码，码）</strong>：若一个关系有多个候选码，则选择其中一个为<strong>主码</strong></li>
<li><strong>最小性</strong>：在保持唯一性的前提下，候选码不包含任何冗余属性。也就是说，如果从候选码中去掉任何一个属性，剩下的属性集将无法继续唯一标识数据记录。</li>
</ul>
</li>
<li>
<p><strong>主属性和非主属性</strong></p>
<ul>
<li>候选码中的属性称为<strong>主属性</strong>，否则为<strong>非主属性</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>关系模式</p>
<ul>
<li>作用：描述数据库的逻辑结构</li>
<li>形式化表示：$R(U, D, dom, F)$<br>
$R$：表示关系的名称，通常代表一个数据库表的名字<br>
$U$（Universe of attributes）：表示属性集合，包含该关系中的所有属性，每个属性对应数据库表中的一列<br>
$D$（Domains of attributes）：表示每个属性的定义域（Domain），即每个属性可以取的合法值的类型集合，更精简<br>
$dom$（Domain function）：表示一个映射函数，用于将每个属性映射到其对应的定义域，更精细<br>
$F$（Functional dependencies）：表示在该关系模式上定义的<strong>函数依赖集</strong>。函数依赖用于表示一个属性集如何函数性地决定另一个属性集</li>
<li>简记：$R(A_1,A_2…)$</li>
<li>关系是关系模式在某一时刻的状态或内容<br>
<strong>关系模式是静态的，关系是动态的</strong></li>
<li><strong>型</strong>：关系模式的集合构成关系数据库模式—关系数据库的型</li>
<li><strong>值</strong>：关系的集合则构成具体的关系数据库—关系数据库的值。</li>
</ul>
</li>
</ul>
<h4 id="关系模型的数据操作">关系模型的数据操作</h4>
<ul>
<li>
<p>特点：集合操作</p>
<ul>
<li>操作的对象和结果都是集合</li>
</ul>
</li>
<li>
<p>基础：关系运算</p>
<ul>
<li>
<p>关系运算分为代数方式和逻辑方式</p>
</li>
<li>
<pre><code class="language-mermaid">graph RL
A[关系代数（代数方式）]
B[关系演算（逻辑方式）]
C[元组关系演算]
D[域关系演算]
E[关系运算]
A---&gt;E
B---&gt;E
C---&gt;B
D---&gt;B
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  * 关系代数</span><br><span class="line"></span><br><span class="line">    * 常规集合运算：并、差、交、广义笛卡儿积（乘）</span><br><span class="line">    * 特有的关系运算：选择、投影、连接、自然连接、 求商</span><br><span class="line"></span><br><span class="line">  * 关系演算</span><br><span class="line"></span><br><span class="line">    * 元组演算：$\&#123;t\mid\Phi(t)\&#125;$</span><br><span class="line">    * 域关系演算：$\&#123;(x_1,x_2...\mid\Phi(x_1,x_2...)\&#125;$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 关系模型的语义约束（完整性约束）</span><br><span class="line"></span><br><span class="line">&gt; 关系模型必须支持实体完整性和参照完整性，可以支持用户定义完整性</span><br><span class="line"></span><br><span class="line">* 实体完整性（Entity Integrity）</span><br><span class="line">  * 主码不可为空或部分为空</span><br><span class="line">  * 空值：不知道或不存在的值</span><br><span class="line">* 参照完整性（Referential integrity）</span><br><span class="line">  * 若关系R的某个或某组关系F和关系S的主码相对应，则称F为关系R的**外部码（Foreign Key）**，并称R为**参照关系（Referencing Relation）**，S为被**参照关系（Referenced Relation）**或**目标关系（Target Relation）**；R和S不一定是不同的关系</span><br><span class="line">  * 相对应的含义：R的外码和S的主码定义在一个域上</span><br><span class="line">  * 参照完整性：若R的外码F和S的主码P相对应，则R中每一个元组的F值或者等于S中某元组的P值，或者为空值</span><br><span class="line"></span><br><span class="line">* 用户定义完整性</span><br><span class="line">  * 用户针对具体的应用环境定义的完整性约束</span><br><span class="line"></span><br><span class="line">### 关系代数</span><br><span class="line"></span><br><span class="line">&gt; 从数学角度，基本关系代数运算有：并、差、乘、选择、投影</span><br><span class="line">&gt;</span><br><span class="line">&gt; 从数据库角度，核心的关系代数运算为：选择、投影、连接（或自然连接）</span><br><span class="line"></span><br><span class="line">#### 传统集合运算</span><br><span class="line"></span><br><span class="line">* 并（Union）</span><br><span class="line">* 差（Defference）</span><br><span class="line">* 交（Intersection）</span><br><span class="line">* 广义笛卡儿积（Extended cartesian product）</span><br><span class="line">  * $R\times S = \&#123;t\mid t=&lt;r,s&gt;\and\ r\in R \and s\in S\&#125;$</span><br><span class="line"></span><br><span class="line">#### 专门的关系运算</span><br><span class="line"></span><br><span class="line">* 选取或限制（Selection or Restriction）</span><br><span class="line">  * $\sigma_F(R)=\&#123;t\mid t\in R,F(t)=\text&#123;True&#125;\&#125;$</span><br><span class="line">  * e.g. $\sigma_&#123;age=12&#125;(S)$</span><br><span class="line">* 投影（Projection)</span><br><span class="line">  * $\Pi_A(R)=\&#123;t[A]\mid t\in R, A\in U\&#125;$</span><br><span class="line">  * e.g. $\Pi_&#123;Name,Age&#125;(S)$</span><br><span class="line">  * 需要删去重复行</span><br><span class="line">* 连接（Join）</span><br><span class="line">  * $\underset&#123;X\theta Y&#125;&#123;R\bowtie S&#125; =\&#123;t\mid t=&lt;r,s&gt;\and r\in R \and s\in S \and r[X] \ \theta \ s[Y]\&#125;$</span><br><span class="line">* 自然连接（Natural Join）</span><br><span class="line">  * $R\bowtie S=\&#123;(Z,X,W)\mid (Z,X)\in R \and (X,W)\in S \and r[X] = s[X]\&#125;$</span><br><span class="line">  * 需要删去重复行</span><br><span class="line">  * 连接与自然连接</span><br><span class="line">    * 自然连接的结果要在上述R与S的等值连接结果基础上再进行投影运算，去掉重复的属性列</span><br><span class="line">* 除法（Divide）</span><br><span class="line">  * $R\div S = (t\mid t \in \Pi_x(R)\and s \in S\and &lt;t,s&gt; \in R)$</span><br><span class="line">  * 翻译：R中所有与S做笛卡尔积得到的关系包含在R中的关系</span><br><span class="line">  * ~~除法需要用乘法来定义，真是讽刺~~</span><br><span class="line"></span><br><span class="line">#### 优先级</span><br><span class="line"></span><br><span class="line">* 单目运算优先级最高，投影&gt;选取</span><br><span class="line">* 专门关系运算中的多目运算和笛卡尔积优先级其次</span><br><span class="line">* 传统集合运算中的多目运算除笛卡尔积外优先级最低</span><br><span class="line"></span><br><span class="line">### 元组关系演算与域关系演算</span><br><span class="line"></span><br><span class="line">&gt; 把谓词演算应用到关系运算中就是关系演算</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 以元组为变量，简称元组演算</span><br><span class="line">&gt; * 以域为变量，简称域演算</span><br><span class="line"></span><br><span class="line">#### 元组关系演算</span><br><span class="line"></span><br><span class="line">* 基本结构：元组演算表达式</span><br><span class="line">* 形式定义：$\&#123;t\mid\Phi(t)\&#125;$</span><br><span class="line">* 递归定义</span><br><span class="line">  1. 原子命题函数是公式，称为原子公式，原子公式有三类</span><br><span class="line">     * $R(t)$</span><br><span class="line">     * $t[i]\ \theta\  u[j]$</span><br><span class="line">     * $t[i]\ \theta\ c或c\ \theta\ t[i]$</span><br><span class="line">  2. 如果$\Phi_1$，$\Phi_2$是公式，则$\Phi_1\and\Phi_2,\Phi_1\or\Phi_2,\neg\Phi$也是公式</span><br><span class="line">  3. 如果$\Phi$是公式，则$\exist t(\Phi), \forall t(\Phi)$也是公式</span><br><span class="line"></span><br><span class="line">* 在元组演算公式中，各种运算符的优先次序为：</span><br><span class="line">  * 算术比较运算符最高</span><br><span class="line">  * 量词次之，且$\exist$的优先级高于$\forall$</span><br><span class="line">  * 逻辑运算符最低，且$\neg$优先级高于$\and$，$\and$高于$\or$</span><br><span class="line">  * 如果有括号，则括号中的运算优先级最高</span><br><span class="line"></span><br><span class="line">#### 域关系演算</span><br><span class="line"></span><br><span class="line">&gt; 其实就是不用数组的元组关系演算🤣</span><br><span class="line"></span><br><span class="line">* 形式定义：$\&#123;(x_1,x_2...\mid\Phi(x_1,x_2...)\&#125;$</span><br><span class="line">* 与元组关系演算有相同的运算符、相同的公式递归定义</span><br><span class="line"></span><br><span class="line">### 三类关系运算的安全约束及等价性</span><br><span class="line"></span><br><span class="line">#### 关系运算的安全约束</span><br><span class="line"></span><br><span class="line">* **安全运算**：关系运算中不产生无限关系和无穷验证的运算</span><br><span class="line">* **安全表达式**：**安全运算**的运算表达式</span><br><span class="line">* **安全约束**：对**安全运算**采取的限制</span><br><span class="line">* 关系代数是安全运算，关系演算则不一定是，所以对关系演算要进行安全约束</span><br><span class="line">  * 对$\Phi$定义一个优先的符号集$DOM(\Phi)$，使对$\Phi$的运算结果及中间结果所产生的关系及其 元组的各个分量都必须属于$DOM(\Phi)$</span><br><span class="line"></span><br><span class="line">#### 三类关系运算的等价性</span><br><span class="line"></span><br><span class="line">* 经过安全约束后的三类关系运算的表达能力是等价的，可以相互转换</span><br><span class="line"></span><br><span class="line">* ```mermaid</span><br><span class="line">  graph LR</span><br><span class="line">  A[关系代数表达式]&lt;--&gt;B[安全元组演算表达式]&lt;--&gt;C[安全域演算表达式]&lt;--&gt;A</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="关系数据语言概述">关系数据语言概述</h3>
<h4 id="数据库数据语言">数据库数据语言</h4>
<ul>
<li><strong>数据定义（描述）语言（Data definition or description language，DDL）</strong>
<ul>
<li>包括模式DDL，外模式DDL，内模式DDL</li>
</ul>
</li>
<li><strong>数据操纵语言（Data Manipulation Language，DML）</strong>
<ul>
<li>四种基本操作：检索、插入、修改、删除</li>
<li>DML有联机交互方式和宿主语言方式
<ul>
<li>联机交互方式：自含式语言，可独立使用，适用于终端直接查询</li>
<li>宿主语言方式：嵌入式语言，依附于宿主语言，嵌入高级语言的程序中，实现数据库操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据控制语言（Data Control Language，DCL）</strong>
<ul>
<li>完成数据库的安全性控制、完整性控制、并发控制</li>
</ul>
</li>
</ul>
<h4 id="关系数据语言特点及优点">关系数据语言特点及优点</h4>
<ul>
<li>特点
<ul>
<li>一体化
<ul>
<li>将数据的定义、查询、更新、控制等合为一体，只提供一种称之为“查询语言”的语言，便于用户学习使用</li>
</ul>
</li>
<li>非过程化
<ul>
<li>用户只需要决定“干什么”，具体“怎么干”由DBMS决定，使得语言操作简单、易学、易用</li>
</ul>
</li>
<li>面向集合的存取方式
<ul>
<li>操作的对象和结果都是关系</li>
</ul>
</li>
<li>既可独立使用又可与主语言嵌套使用</li>
</ul>
</li>
<li>优越性
<ul>
<li>关系模型采用了最简单的数据结构，使得DML大大简化</li>
<li>关系数据语言建立在关系运算的数学基础上，可以实现关系的垂直方向和水平方向的任意分割和组装操作，可构造出多样的新关系</li>
</ul>
</li>
</ul>
<h4 id="关系数据语言分类">关系数据语言分类</h4>
<blockquote>
<p>关系数据语言的核心是查询，所以又称为查询语言</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[关系代数]</span><br><span class="line">B[关系演算]</span><br><span class="line">C[元组关系演算]</span><br><span class="line">D[域关系演算]</span><br><span class="line">E[ISBL]</span><br><span class="line">F[ALPHA；QUEL]</span><br><span class="line">G[QBE]</span><br><span class="line">H[SQL]</span><br><span class="line">I[关系运算]</span><br><span class="line">I--&gt;A</span><br><span class="line">I--&gt;B</span><br><span class="line">A----&gt;E</span><br><span class="line">E---&gt;H</span><br><span class="line">F---&gt;H</span><br><span class="line">B--&gt;C---&gt;F</span><br><span class="line">B--&gt;D---&gt;G</span><br></pre></td></tr></table></figure>
<h3 id="关系模型的优点与缺点">关系模型的优点与缺点</h3>
<ul>
<li>
<p>优点</p>
<ul>
<li>建立在严格数学概念基础上，有严格的设计理论</li>
<li>概念单一，实体和联系都用关系描述，查询操作结果也是一个关系，保证了数据操作语言的一致性</li>
<li>数据结构简单直观、易理解、语言表达简洁</li>
<li>存取路径对用户透明，数据独立性更高，安全保密性更好,，简化了程序员和数据库开发建立的工作</li>
</ul>
</li>
<li>
<p>缺点</p>
<blockquote>
<p>随着各种查询优化的开发，劣势已经基本解决</p>
</blockquote>
<ul>
<li>由于存取路径对用户透明，查询效率不如层次、网状数据模型</li>
<li>为了提高性能，需要查询优化，增加数据库管理系统的开发难度</li>
</ul>
</li>
</ul>
<h2 id="第三章-关系数据库标准语言SQL">第三章 关系数据库标准语言SQL</h2>
<blockquote>
<ul>
<li>1974，由Chamberlin和Boyee提出，称为SEQUEL（Structured English Query Language），Chamberlin被称为SQL之父</li>
<li>1975-1979，在IBM的System R上实现</li>
<li>1981，IBM在推出SQL/DS关系数据库时，将其命名为SQL（Structured Query Language）</li>
<li>目前，ANSI和ISO先后制定了SQL-86、SQL-89……SQL-2011等多个SQL标准</li>
<li>2024，fysszlr被称为“SQL之耻”🏳️</li>
</ul>
</blockquote>
<h3 id="概述">概述</h3>
<blockquote>
<p>关系数据库中，可以通过SQL操作的数据对象有哪些？</p>
</blockquote>
<h4 id="SQL特点">SQL特点</h4>
<ul>
<li>综合统一</li>
<li>非过程化</li>
<li>面向集合</li>
<li>提供两种使用方式（交互式、嵌入式）</li>
<li>语言简洁、易学易用</li>
</ul>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>
<p>基本表与导出表</p>
<ul>
<li>
<p><strong>基本表</strong>：是实际存在的，在存储中可用一个存储文件来表示</p>
</li>
<li>
<p><strong>导出表</strong>：是从基本表导出的表，由<strong>视图（View）<strong>和</strong>快照（Snapshot）</strong></p>
<ul>
<li>
<p>相对于快照视图更常用一些</p>
</li>
<li>
<p>视图是一个<strong>虚表</strong>，即在实际数据库中不单独存储视图的数据，只在数据库的数据字典中存储视图的定义</p>
</li>
<li>
<p>视图一经定义就可以和基本表一样进行查询等操作，也可以用来定义新的视图</p>
</li>
<li>
<p>视图定义示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CS_STudent</span><br><span class="line"><span class="keyword">As</span></span><br><span class="line">	<span class="keyword">SELECT</span> S#,SN,SA <span class="keyword">FROM</span> S</span><br><span class="line">	<span class="keyword">WHERE</span> SD <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>快照是某一个时间点，数据库内信息的静态副本；视图可更新，快照不可更新</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关系数据库的三级模式结构</p>
<ul>
<li>用户——SQL，外模式——View，模式——Base table，内模式——Stored file</li>
<li>用户可以操作外模式，也可以直接操作模式</li>
<li>外模式可以对应到一个模式，也可以对应到多个模式</li>
<li>一个模式对应一个内模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[SQL]</span><br><span class="line">B[View V1]</span><br><span class="line">C[View V2]</span><br><span class="line">D[Base table B1]</span><br><span class="line">E[Base table B2]</span><br><span class="line">F[Base table B3]</span><br><span class="line">G[Base table B4]</span><br><span class="line">H[Stored file S1]</span><br><span class="line">I[Stored file S2]</span><br><span class="line">J[Stored file S3]</span><br><span class="line">K[Stored file S4]</span><br><span class="line">A&lt;---&gt;D&lt;--&gt;H</span><br><span class="line">A&lt;--&gt;B--&gt;E&lt;--&gt;I</span><br><span class="line">A&lt;--&gt;C--&gt;F&lt;--&gt;J</span><br><span class="line">C--&gt;G&lt;--&gt;K</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SQL语法">SQL语法</h3>
<blockquote>
<p>SQL如何实现数据定义、查询、更新、控制操作？</p>
</blockquote>
<h4 id="SQL数据查询功能">SQL数据查询功能</h4>
<blockquote>
<p>这一部分内容其实不多，理解例子并灵活运用最重要</p>
<p>下文例子默认：</p>
<ul>
<li>S(S#, SN, SA, SD);</li>
<li>C(C#, CN, PC#);</li>
<li>SC(S#, C#, G);</li>
</ul>
</blockquote>
<ul>
<li>
<p>基本结构：SELECT-FROM-WHERE组成的查询块</p>
</li>
<li>
<pre><code class="language-sql">SELECT 目标列
FROM 基本表（或视图）
WHERE 检索条件;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 查询块的结构仍然是一个表，查询块可以进行关系代数中投影、选取、连接等操作的组合</span><br><span class="line"></span><br><span class="line">* SELECT对垂直方向进行操作，WHERE对水平方向进行操作</span><br><span class="line"></span><br><span class="line">* 技巧</span><br><span class="line"></span><br><span class="line">  * **投影操作**：如果没有WHERE，即为单纯的投影操作</span><br><span class="line"></span><br><span class="line">    * 采用**DISTINCT**可以消去SELECT结果中的重复行</span><br><span class="line"></span><br><span class="line">      ```sql</span><br><span class="line">      # 检索全体学生选的课号</span><br><span class="line">      SELECT DISTINCT C#</span><br><span class="line">      FROM SC;</span><br></pre></td></tr></table></figure>

* **选取检索**：WHERE可以包含多种符号

  * 比较运算符：=、&lt; &gt;(!=)、&gt;、&gt;=、&lt;、&lt;=

  * 布尔运算符：AND、OR、NOT 

  * ( )

  * 使用**BETWEEN AND**可以区间查询

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> G <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">85</span>;</span><br></pre></td></tr></table></figure>

* **排序检索**：使用**ORDER BY**进行排序检索

  * 格式：ORDER BY 列名 ASC（或DESC）

  * ASC：升序，DESC：降序；默认升序

  * 支持多列排序

  * ```sql
    # 检索全体学生信息，并按系号升序，同一个系按年龄降序排
    SELECT *
    FROM S
    ORDER BY SD, SA DESC;
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **连表检索**：将多个相互关联的表按照一定条件连接起来，可以实现连表检索</span><br><span class="line"></span><br><span class="line">  * 此时WHERE需要包含连接条件和选取条件</span><br><span class="line"></span><br><span class="line">    ```sql</span><br><span class="line">    # 检索学生张华所学课程的成绩</span><br><span class="line">    SELECT SN, C#, G</span><br><span class="line">    FROM S, SC</span><br><span class="line">    WHERE S.S#=SC.S# AND SN=&#x27;张华&#x27;;</span><br></pre></td></tr></table></figure>

  * 可以定义**别名**实现表自身的连接

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索所有比李勇年龄大的学生姓名、年龄</span><br><span class="line"><span class="keyword">SELECT</span> X.SN, X.SA</span><br><span class="line"><span class="keyword">FROM</span> S X, S Y</span><br><span class="line"><span class="keyword">WHERE</span> X.SA<span class="operator">&gt;</span>Y.SA <span class="keyword">AND</span> Y.SN<span class="operator">=</span><span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure>

  * **外连接**
    在连接谓词某一边加\+或\*，则逻辑上为*所在边的表增加了一个空行；它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索所有学生的全部信息。</span><br><span class="line"><span class="keyword">SELECT</span> S.S#, SN,SA,SD, C#, G</span><br><span class="line"><span class="keyword">FROM</span> S, SC</span><br><span class="line"><span class="keyword">WHERE</span> S.S#<span class="operator">=</span>SC.S#(<span class="operator">*</span>);</span><br></pre></td></tr></table></figure>

* **嵌套检索**：WHERE的子句中可以包含另一个查询块，称为**子查询**或**嵌套查询**，包含子查询的语句称为**外部查询**

  * 普通子查询：与外部查询无关，可单独执行获得一组值

  * 相关子查询：把外查询的列值作为检索条件的条件值

  * 如果子查询返回单值，可以直接用比较运算符 =,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=等连接子查询

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 检索与李勇同岁的学生姓名</span><br><span class="line"><span class="keyword">SELECT</span> SN</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> S.SA<span class="operator">=</span></span><br><span class="line">	(<span class="keyword">SELECT</span> SA <span class="keyword">FROM</span> S</span><br><span class="line">	<span class="keyword">WHERE</span> SN<span class="operator">=</span><span class="string">&#x27;李勇&#x27;</span>);</span><br></pre></td></tr></table></figure>

  * 如果子查询返回一组值，则必须在比较运算符和子查询之间插入**ANY**、**ALL**、**IN**（在集合中）、**NOT IN** （不在集合中等）、**EXIST**（子查询不为空）、**NOT EXIST**（子查询不为空）等操作符啦

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 检索选修C2课程的成绩最高的学生学号</span><br><span class="line"><span class="keyword">SELECT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> C#<span class="operator">=</span>‘C2’ <span class="keyword">AND</span></span><br><span class="line">	G<span class="operator">&gt;=</span><span class="keyword">ALL</span></span><br><span class="line">	(<span class="keyword">SELECT</span> G <span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">WHERE</span> C#<span class="operator">=</span>‘C2’);</span><br></pre></td></tr></table></figure>

    特别的，可以用两个NOT EXIST表示任意或蕴含

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 检索至少选修了学生S2选修的全部课程的学生学号</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC SCY</span><br><span class="line">    <span class="keyword">WHERE</span> SCY.S# <span class="operator">=</span> <span class="string">&#x27;S2&#x27;</span> <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">        <span class="keyword">WHERE</span> S# <span class="operator">=</span> SCX.S# <span class="keyword">AND</span> C# <span class="operator">=</span> SCY.C#));</span><br></pre></td></tr></table></figure>

* **并、差、交检索**：**UNION**（并）、**MINUS**（差）、**INTERSECT**（交）

  * 并、差、交检索的操作对象必须是相容的，是同类关系，即必须有相同数量的属性列，且相应属性列的域也必须相同

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检索无人选修的课程号和名称</span><br><span class="line"><span class="keyword">SELECT</span> C#，CN <span class="keyword">FROM</span> C <span class="keyword">WHERE</span> C# <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> C# <span class="keyword">FROM</span> C</span><br><span class="line">    MINUS</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> C# <span class="keyword">FROM</span> SC); # 我觉得这里的<span class="keyword">DISTINCT</span>不必要</span><br></pre></td></tr></table></figure>

* **库函数检索**：库函数只能在SELECT和HAVING子句中出现

  | 库（集）函数 | 作用             |
  | ------------ | ---------------- |
  | COUNT()      | 按列值计个数     |
  | COUNT(\*)    | 对行记数         |
  | SUM()        | 对数值列求总和   |
  | AVG()        | 求数值列的平均值 |
  | MAX()        | 在列中找出最大值 |
  | MIN()        | 在列中找出最小值 |

* **分组检索**：按属性列（列组）将关系的元组分组，每组在这些分组属性列（列组）上具有相同值，对每一组执行SELECT操作

  * **HAVING**子句针对“分组”进行，必须和**GROUP BY** 连用，用于去掉不符合条件的若干分组

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名</span><br><span class="line">[<span class="keyword">HAVING</span> 条件表达式]</span><br></pre></td></tr></table></figure>

  * 出现的顺序：WHERE — GROUP BY — HAVING

    <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 求选修四门以上课程的学生学号和总成绩（不统计不及格的课程）。最后按降序列出总成绩排序名单。</span><br><span class="line"><span class="keyword">SELECT</span> S#, SUM（G）</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> G<span class="operator">&gt;=</span><span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S#</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(G) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

* **算术表达式检索**：SELECT子句中，可包括由属性列、常数、库函数、算 术运算符+-*/ 等组成的算术表达式；检索结果数据项名可用表达式表示或用“别名”来表示

  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 有职工表EMP( EMP#，EMPN，JOB，SALARY，BONUS，DEPT )，要求检索所有PROGRAMMER的奖金大于工资<span class="number">25</span><span class="operator">%</span>的职工姓名和一年的总收入，并按奖金与工资之比的降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> EMPN,BONUS<span class="operator">/</span>SALARY BS, <span class="number">12</span><span class="operator">*</span>(SALARY<span class="operator">+</span>BONUS) TOTAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> JOB<span class="operator">=</span><span class="string">&#x27;PROGRAMMER&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> BONUS<span class="operator">&gt;</span><span class="number">0.25</span><span class="operator">*</span>SALARY</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> BONUS<span class="operator">/</span>SALARY <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

* **部分匹配查询**：&lt;列名&gt; **LIKE**/**NOT LIKE** &lt;字符串常量&gt;

  * %：代表任意序列的0个或多个字符
  * _：代表任意单个字符

  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索所有姓刘的学生的学号、姓名</span><br><span class="line"><span class="keyword">SELECT</span> S#, SN</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> SN <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br></pre></td></tr></table></figure>

* **派生表查询**：当子查询出现在FROM子句中，则子查询生成的表称为临时派生表，该表也可作为主查询的操作对象

  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 检索每个学生超出自己平均成绩的课程号。</span><br><span class="line"><span class="keyword">SELECT</span> S#, C#</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> S#, <span class="built_in">AVG</span>(G)</span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> S# ) <span class="keyword">AS</span> AVG_SC(AVG_S#,AVG_G)</span><br><span class="line"><span class="keyword">WHERE</span> SC.S# <span class="operator">=</span> AVG_SC.AVG_S# <span class="keyword">AND</span> SC.G <span class="operator">&gt;=</span> AVG_SC.AVG_G)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h4 id="SQL数据定义功能">SQL数据定义功能</h4>
<ul>
<li>
<p>定义、删除、修改基本表</p>
</li>
<li>
<p>定义、删除视图</p>
</li>
<li>
<p>定义、删除索引</p>
</li>
<li>
<table>
<thead>
<tr>
<th>操作对象</th>
<th>创建</th>
<th>删除</th>
<th>修改</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本表</td>
<td>Create Table</td>
<td>Drop Table</td>
<td>Alter Table</td>
</tr>
<tr>
<td>视图</td>
<td>Create View</td>
<td>Drop View</td>
<td>\</td>
</tr>
<tr>
<td>索引</td>
<td>Create Index</td>
<td>Drop Index</td>
<td>\</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="SQL视图操作">SQL视图操作</h4>
<ul>
<li>
<p>定义视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br><span class="line">[(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] …)]</span><br><span class="line"><span class="keyword">As</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">With</span> <span class="keyword">Check</span> Option]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除视图</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Drop</span> <span class="keyword">View</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>视图消解</strong>（View Resolution）</p>
<ul>
<li>DBMS执行视图查询操作时，将对视图的操作转化为对原始数据字典的查询，这一过程叫做视图消解</li>
</ul>
</li>
<li>
<p>视图优点</p>
<ul>
<li>能够简化用户操作</li>
<li>使用户能够以多种角度看待同一数据</li>
<li>提供了一定程度的逻辑独立性</li>
<li>能够对数据提供安全保护</li>
</ul>
</li>
</ul>
<h4 id="SQL数据更新">SQL数据更新</h4>
<ul>
<li>插入数据——Insert语句</li>
<li>修改数据——Update语句</li>
<li>删除数据——Delete语句</li>
</ul>
<h4 id="SQL数据控制">SQL数据控制</h4>
<ul>
<li>定义完整性约束条件</li>
<li>支持事务操作</li>
<li>提供安全控制功能
<ul>
<li>授权</li>
<li>收回权限</li>
</ul>
</li>
</ul>
<h4 id="空值处理">空值处理</h4>
<ul>
<li>
<p><strong>空值</strong>：“不知道”、”不存在“、”无意义“的值，统一用NULL表示</p>
</li>
<li>
<p>属性定义中使用NOT NULL和UNIQUE约束的域以及主属性都不可以取空值</p>
</li>
<li>
<p>空值算数运算结果为NULL，布尔运算结果为UNKNOWN</p>
</li>
<li>
<p>空值判断：使用<strong>IS NULL</strong>或<strong>IS NOT NULL</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> SD <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在WHERE和HAVING子句中，只有使结果为TRUE的元组才会输出</p>
</li>
</ul>
<h3 id="嵌入式SQL">嵌入式SQL</h3>
<blockquote>
<p>SQL有哪些使用方式？</p>
</blockquote>
<ul>
<li>嵌入式SQL的意义
<ul>
<li>把SQL语句嵌入到高级语言中</li>
<li>把SQL的最佳特性与程序设计语言中的最佳特性（如过程处理能力）结合起来，使SQL功能更强，灵活性更强</li>
</ul>
</li>
<li>嵌入式SQL与高级语言区别
<ul>
<li>在SQL语句前加前缀（如EXEC SQL），区分SQL语句与主语言语句</li>
<li>需要通过游标遍历SQL产生的集合，对齐颗粒度</li>
<li>通过主变量（主语言程序变量） 交换数据</li>
</ul>
</li>
<li>嵌入式SQL的处理
<ul>
<li>对嵌入式SQL，DBMS需要进行预编译进行处理
<ul>
<li>DBMS需要将SQL语句翻译成高级语言源码，然后按主语言的通常方式进行编译、连接</li>
<li>优点：执行效率高</li>
<li>缺点：可移植性差
<ul>
<li>ODBC（Open Database Connectivity）<br>
由微软设计，便于数据库实现共同API，便于移植</li>
<li>JDBC（Java Database Connectivity）<br>
由Oracle设计，是Java的数据库访问标准</li>
</ul>
</li>
</ul>
</li>
<li>动态SQL允许程序在运行过程中“临时”组装SQL语句</li>
</ul>
</li>
</ul>
<h2 id="第四章-数据库保护">第四章 数据库保护</h2>
<blockquote>
<ul>
<li>数据完整性控制是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出</li>
<li>数据安全性控制是保护数据库防止恶意的破坏和非法存取</li>
<li>安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据</li>
</ul>
</blockquote>
<h3 id="数据库安全性控制">数据库安全性控制</h3>
<blockquote>
<p>数据库中的数据会有哪些安全威胁，如何进行安全保护？</p>
</blockquote>
<h4 id="数据库安全性控制含义">数据库安全性控制含义</h4>
<ul>
<li>
<p><strong>数据库的安全性</strong>：保护数据库以防止不合法的使用所造成的<strong>数据泄漏、更改和破坏</strong></p>
<ul>
<li>向授权用户提供可靠的信息服务</li>
<li>拒绝对数据的非授权存取访问请求，保证数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>保护数据库防止恶意的破坏和非法存取</li>
</ul>
</li>
<li>
<p>计算机系统安全模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[用户/应用程序]---B[DBMS]---C[OS&amp;Network]---D[DB]</span><br></pre></td></tr></table></figure>
<ul>
<li>用户/应用程序：用户标识和认证</li>
<li>DBMS：存取控制、审计</li>
<li>OS&amp;Network：操作系统与网络安全</li>
<li>DB：数据加密</li>
</ul>
</li>
</ul>
<h4 id="数据库安全性控制方法">数据库安全性控制方法</h4>
<ul>
<li>
<p>用户标识与认证</p>
<ul>
<li>数据库提供的<strong>最外层</strong>安全保护方法</li>
<li><strong>标识</strong>是指系统采用一定的方式标识其用户或应用程序的名字或身份</li>
<li><strong>认证</strong>是指系统在用户或应用程序登录时判断其是否为合法的授权用户</li>
<li>常用实现方式：用户名和口令</li>
</ul>
</li>
<li>
<p>存取控制</p>
<ul>
<li>
<p>确保合法用户按照指定权限使用DBMS和访问数据</p>
</li>
<li>
<p>包含<strong>用户权限定义</strong>和<strong>合法权限检查</strong>两部分，这两部分组成DBMS的安全子系统</p>
</li>
<li>
<p>自主存取控制（discretionary access control，DAC)</p>
<ul>
<li>
<p>根据预先定义的用户权限进行存取控制，用户权限是指用户对数据对象允许执行的操作类型，由数据对象和操作类型两个要素组成；用户间可以授予权限</p>
</li>
<li>
<p>示例</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>数据对象</th>
<th>操作类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td>模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">模式</td>
<td>内模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">模式</td>
<td>外模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">数据</td>
<td>表</td>
<td>检索、插入、删除、修改</td>
</tr>
<tr>
<td style="text-align:left">数据</td>
<td>属性列</td>
<td>检索、插入、删除、修改</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>一般使用基于角色的存取控制（RBAC）</p>
<ul>
<li>用户级权限，用户对整个数据库权限的限定，与数据库中具体关系无关</li>
<li>关系级权限，用户使用关系和视图权限的限定</li>
<li>授予权限：Grant</li>
<li>取消权限：Revoke</li>
</ul>
</li>
</ul>
</li>
<li>
<p>强制存取方法（mandatory access control， MAC)</p>
<ul>
<li>MAC机制对比主体和客体的Label，最终确定主体是否能够存取客体
<ul>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li>
<li>仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其它方法</p>
<ul>
<li>视图<br>
为不同用户定义不同视图，将用户访问限制在一定范围内</li>
<li>审计<br>
将用户对数据库的所有操作自动记录下来放入审计日志中</li>
<li>数据加密<br>
防止数据库中数据在存储和传输中失密</li>
</ul>
</li>
</ul>
<h4 id="可信计算机系统评测标准">可信计算机系统评测标准</h4>
<blockquote>
<p>目前大部分数据库系统处于C等级防护</p>
</blockquote>
<ul>
<li>标准
<ul>
<li>TCSEC（Trusted Computer System Evaluation Criteria)，1985，美国国防部制定，可信计算机标准</li>
<li>TDI（Trusted Database Interpretation），1991，美国国家计算机安全中心制定，数据库标准</li>
</ul>
</li>
</ul>
<h3 id="数据库完整性控制">数据库完整性控制</h3>
<blockquote>
<p>如何保证数据库中数据的正确、有效和一致性？</p>
</blockquote>
<h4 id="数据完整性含义">数据完整性含义</h4>
<ul>
<li><strong>数据完整性</strong>：指数据的正确性和相容性
<ul>
<li>正确性：数据应具有合法的类型，并在有效 的取值范围之内</li>
<li>相容性：指同一对象在不同关系中的数据是符合逻辑的</li>
</ul>
</li>
<li>作用
<ul>
<li>防止数据库中存在 不符合语义的数据，防止错误信息的输入和输出</li>
</ul>
</li>
</ul>
<h4 id="完整性约束条件">完整性约束条件</h4>
<ul>
<li>
<p>定义：施加在数据库数据之上的语义约束条件</p>
</li>
<li>
<p>作用对象可以是列、元组、关系</p>
</li>
<li>
<p>包含实体完整性、参照完整性、用户自定义完整性</p>
</li>
<li>
<p>静态约束</p>
<ul>
<li>数据库在每一确定状态必须满足的约束，是反映<strong>数据库状态合理性</strong>的约束</li>
<li>包含静态列级约束、静态元组约束、静态关系约束</li>
</ul>
</li>
<li>
<p>动态约束</p>
<ul>
<li>数据库在数据转变时必须满足的约束，是反映<strong>数据库状态变迁</strong>的约束</li>
<li>包含动态列级约束、动态元组约束、动态关系约束</li>
</ul>
</li>
</ul>
<h4 id="完整性控制">完整性控制</h4>
<ul>
<li>功能
<ul>
<li>定义功能<br>
提供定义完整性约束条件的机制</li>
<li>检查功能<br>
检查用户发出的操作请求是否违背了完整性约束条件</li>
<li>违约响应<br>
若违背了完整性约束条件，则采取一定措施来保证数据的完整性</li>
</ul>
</li>
<li>完整性检查时机
<ul>
<li><strong>立即执行约束</strong>：在一条语句执行完后立即进行完整性约束的检查</li>
<li><strong>延迟执行约束</strong>：在整个用户事务执行完毕后，再进行完整性约束的检查</li>
</ul>
</li>
<li>完整性规则形式定义：(D, O, A, C, P)
<ul>
<li>D ( Data ) 约束所作用的数据对象</li>
<li>O ( Operation ) 触发完整性检查的数据库操作</li>
<li>A ( Assertion ) 数据对象必须满足的断言或语义约束</li>
<li>C ( Condition ) 选择A作用的数据对象值的谓词</li>
<li>P ( Procedure ) 违反完整性规则时触发的过程</li>
</ul>
</li>
</ul>
<h2 id="第五章-关系数据理论">第五章 关系数据理论</h2>
<blockquote>
<p>什么样的关系是好关系？没有<strong>插入异常</strong>、<strong>删除异常</strong>、<strong>数据冗余</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A[关系的规范化]</span><br><span class="line">B[关系数据理论]</span><br><span class="line">C[规范化方法：模式分解]</span><br><span class="line">D[关系模式规范标准：范式]</span><br><span class="line">E[数据依赖：函数依赖/多值依赖]</span><br><span class="line">E--&gt;D--&gt;C</span><br><span class="line">E-.-&gt;B</span><br><span class="line">D-.-&gt;B</span><br><span class="line">C-.-&gt;B</span><br><span class="line">B--指导--&gt;A</span><br></pre></td></tr></table></figure>
<p>todo：</p>
<ul>
<li>多值依赖和4NF部分有未完成事宜</li>
<li>无损分解判定算法有未完成事宜</li>
<li>候选码求解算法有未完成事宜</li>
</ul>
</blockquote>
<h3 id="函数依赖">函数依赖</h3>
<h4 id="定义">定义</h4>
<ul>
<li><strong>X–&gt;Y</strong>：有属性X和Y，若对于X的每个具体值，Y有唯一的值与之对应，则称“X函数确定Y”或“Y函数依赖于X”</li>
<li><strong>平凡的函数依赖</strong>：X–&gt;Y，且$Y\subseteq X$</li>
<li><strong>非平凡的函数依赖</strong>：X–&gt;Y，且$Y\nsubseteq X$</li>
<li><strong>决定因素</strong>：X–&gt;Y，则X为决定因素</li>
<li>类型：1:1、1:m、n:m</li>
</ul>
<h4 id="三种函数依赖">三种函数依赖</h4>
<ul>
<li><strong>完全函数依赖</strong>：若X–&gt;Y，且X的任意真子集都无法确定Y，则Y对X完全函数依赖，记作$X\overset{f}\rightarrow Y$</li>
<li><strong>部分函数依赖</strong>：若X–&gt;Y，且存在X真子集确定Y，则Y对X部分函数依赖，记作$X\overset{p}\rightarrow Y$</li>
<li><strong>传递函数依赖</strong>：若X–&gt;Y，Y–&gt;Z，且Y无法确定X，则Z对X传递函数依赖，记作$X\overset{t}\rightarrow Z$</li>
</ul>
<h4 id="函数依赖公理系统">函数依赖公理系统</h4>
<ul>
<li>有属性集合X和Y，若从F的函数依赖能推出$X\rightarrow Y$，则称F逻辑蕴含$X\rightarrow Y$</li>
<li>$F$的闭包记作$F^+$</li>
<li><strong>Armstrong公理系统</strong>
<ul>
<li>自反律：若$Y\subseteq X$，则$X\rightarrow Y$</li>
<li>增广率：若$X\rightarrow Y$，则$XZ\rightarrow YZ$</li>
<li>传递率：若$X\rightarrow Y,\ Y\rightarrow Z$，则$X\rightarrow Z$</li>
</ul>
</li>
<li><strong>Armstrong公理推论</strong>
<ul>
<li>合并规则：若$X\rightarrow Y,\ X\rightarrow Z$，则$X\rightarrow YZ$</li>
<li>伪传递规则：若$X\rightarrow Y,\ WY\rightarrow Z$，则$WX\rightarrow YZ$</li>
<li>分解规则：若$X\rightarrow Y,\ Z\subseteq Y$，则$X\rightarrow Z$</li>
<li>由合并规则和分解规则可推出如下定理
<ul>
<li>$X\rightarrow A_1, A_2…A_k$成立，与$X\rightarrow A_i(i=1,2,…,k)$等价，X能推出A的任意子集</li>
</ul>
</li>
</ul>
</li>
<li>属性集的闭包
<ul>
<li>定义：属性集X关于函数依赖集F的闭包</li>
<li>定理：若$X\rightarrow Y$能从Armstrong公理系统推出，则$Y\subseteq X_F^+$</li>
</ul>
</li>
<li>Armstrong公理系统的有效性与完备性
<ul>
<li>有效性
<ul>
<li>指由F出发根据Armstrong公理推导出来的每个函数依赖一 定在F所蕴含的函数依赖的全体之中</li>
<li>有效性由Armstrong公理系统的正确性证明</li>
</ul>
</li>
<li>完备性
<ul>
<li>F所蕴含的函数依赖的全体中的每一个函数依赖，必定可以由F根据Armstrong公理导出</li>
<li>证明：使用两个特殊元组t，s辅助证明</li>
</ul>
</li>
</ul>
</li>
<li>函数依赖集等价与覆盖
<ul>
<li>若$F^+=G^+$，则称F+与G+等价</li>
<li>若$F^+=G^+$，则$F\subseteq G^+$、$G\subseteq F^+$，称F覆盖G，同时G覆盖F</li>
</ul>
</li>
<li>函数依赖集的最小依赖集
<ul>
<li>要求
<ul>
<li>右部为单属性</li>
<li>没有多余的函数依赖（Functional Dependency，FD）</li>
<li>每个FD左部没有多余属性</li>
</ul>
</li>
<li>极小化方法
<ol>
<li>用右部单属性推导式替代右部集合推导式</li>
<li>检查所有FD，删去所有多余项</li>
<li>检查所有FD，删去所有多余左部属性</li>
<li>重复以上步骤若干次</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="规范化">规范化</h3>
<blockquote>
<p>发展过程：</p>
<ul>
<li>1971-1972：CODD系统提出1NF，2NF，3NF的概念</li>
<li>1974：CODD 和BOYCE提出BCNF</li>
<li>1976：FAGIN 提出4NF，后来又提出了“投影-连接范式” PJNF，也称 5NF</li>
</ul>
<p>范式间关系：<br>
$1NF\subset2NF\subset3NF\subset BCNF\subset4NF\subset5NF$</p>
</blockquote>
<h4 id="范式概念（1NF）">范式概念（1NF）</h4>
<ul>
<li>如果某个关系满足某个指定的约束集，则称它属于某种<strong>范式</strong>（Normal Form）</li>
<li><strong>1NF</strong>
<ul>
<li>最低要求</li>
<li>定义：一个关系只包含<strong>原子值</strong></li>
<li>满足1NF的称为<strong>规范化关系</strong>，简称范式</li>
</ul>
</li>
<li><strong>规范化</strong>：一个低一级范式的关系模式，通过模式分解转换为若干个高级范式的关系模式的集合的过程</li>
</ul>
<h4 id="与函数依赖相关的范式（2NF-3NF-BCNF）">与函数依赖相关的范式（2NF, 3NF, BCNF）</h4>
<ul>
<li>
<p><strong>2NF</strong></p>
<ul>
<li>定义：$R\in 1NF$，且每个非主属性完全依赖于码（主属性可以部分依赖于码）</li>
<li>既要依赖于主键，又不能仅仅依赖码的一部分</li>
<li>规范化：用画图法从1NF中消除非主属性对码的部分函数依赖</li>
<li>插入异常依然存在；删除异常会导致连锁信息被删除；数据冗余得到一定改善</li>
</ul>
</li>
<li>
<p><strong>3NF</strong></p>
<ul>
<li>定义：$R\in2NF$，且每个非主属性不传递依赖于R的任何码</li>
<li>所有的异常都消失了（表面上）</li>
</ul>
</li>
<li>
<p><strong>BCNF</strong></p>
<ul>
<li>当某些特定情况发生时，3NF可能依然存在各种异常</li>
<li>定义
<ul>
<li>$R\in 1NF$，对所有X–&gt;Y，且$Y\nsubseteq X$时，都有X含有码</li>
</ul>
</li>
<li>性质
<ul>
<li>所有属性都完全函数依赖于（不包含该属性的）候选码</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多值依赖与第四范式">多值依赖与第四范式</h3>
<blockquote>
<p>函数依赖反应了现实世界实体间的相互约束</p>
<p>现实世界实体间还有其它约束：</p>
<ul>
<li>多值依赖</li>
<li>连接依赖</li>
<li>分层依赖</li>
<li>相互依赖</li>
</ul>
</blockquote>
<h4 id="多值依赖">多值依赖</h4>
<ul>
<li>定义
<ul>
<li>若对于X，Y，Z（其中Z=U-X-Y），Y的值决定于X的值，且与Z值无关，则称多值依赖X–&gt;–&gt;Y成立</li>
<li>也即：当X确定了，Y和Z都可以有被X决定的多个值，但它们之间是相互独立的</li>
</ul>
</li>
</ul>
<h4 id="4NF">4NF</h4>
<h3 id="模式分解的理论">模式分解的理论</h3>
<h4 id="模式分解的定义">模式分解的定义</h4>
<ul>
<li>若$F_i={X\rightarrow Y\mid X\rightarrow Y\in F^+\ \and\ XY\subseteq U_i}$，则称Fi为F在Ui上的投影</li>
<li>关系模式R&lt;U, F&gt;的一个分解${R_1&lt;U_1,F_1&gt;,R_2&lt;U_2, F_2&gt;,…,R_n&lt;U_n,F_n&gt;}$，其中$U=\Sigma U_i$</li>
</ul>
<h4 id="分解的无损连接性">分解的无损连接性</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>对于关系模式R&lt;U, F&gt;的分解，r为R中任何一个关系，若将分解中所有属于r的部分连接，仍能得到r，则称该分解为<strong>无损分解</strong>，具有<strong>无损连接性</strong></li>
</ul>
</li>
<li>
<p>判定算法</p>
<ul>
<li>仅分解为两部分时的判断算法：R1， R2的共同属性至少构成 R1、R2 二者之一的侯选码，则为无损连接</li>
</ul>
</li>
</ul>
<h4 id="分解的保持函数依赖性">分解的保持函数依赖性</h4>
<ul>
<li>定义
<ul>
<li>若$F+=(\Sigma F_i)+$，则称分解保持函数依赖</li>
</ul>
</li>
<li>判定算法
<ul>
<li>计算$(\Sigma F_i)+$，验证F的每一条依赖是否在$(\Sigma F_i)+$中</li>
</ul>
</li>
</ul>
<h4 id="模式分解的原则">模式分解的原则</h4>
<ul>
<li>具有无损连接性</li>
<li>保持函数依赖</li>
</ul>
<h4 id="模式分解的算法">模式分解的算法</h4>
<ul>
<li>达到3NF且保持函数依赖的分解算法</li>
<li>达到3NF且同时保持无损连接与函数依赖的分解算法</li>
<li>达到BCNF无损连接分解算法</li>
</ul>
<h3 id="候选码的求解和算法">候选码的求解和算法</h3>
<h4 id="快速求解候选码的充分条件">快速求解候选码的充分条件</h4>
<h4 id="左边为单属性的函数依赖集候选码成员的图论判定方法">左边为单属性的函数依赖集候选码成员的图论判定方法</h4>
<h4 id="多属性依赖集候选码求解法">多属性依赖集候选码求解法</h4>
<h2 id="第六章-数据库设计">第六章 数据库设计</h2>
<h3 id="数据库设计方法概述">数据库设计方法概述</h3>
<blockquote>
<p>数据库设计的任务是什么？</p>
<p>数据库设计中的难点是什么，采用怎样的设计方法解决？</p>
</blockquote>
<h4 id="数据库设计">数据库设计</h4>
<ul>
<li>定义
<ul>
<li>对于一个给定的应用环境，<strong>设计优化的数据库逻辑结构和物理结构</strong>，建立数据库，使之能够有效地存储数据，为开发满足用户需求的应用系统奠定基础</li>
</ul>
</li>
<li>特点
<ul>
<li>要把<strong>数据设计</strong>和<strong>处理设计</strong>密切结合起来</li>
<li>与硬件、软件和管理紧密相关</li>
</ul>
</li>
</ul>
<h4 id="手工试凑法">手工试凑法</h4>
<ul>
<li>
<p>根据应用的数据要求与处理要求，直接设计数据库的结构</p>
</li>
<li>
<p>缺点</p>
<ul>
<li>数据间关系复杂，使用要求各式各样，很难仅凭经验进行设计</li>
<li>用户需求一旦改变，难以改变数据结构设计</li>
<li>数据库设计和DBMS绑定，难以移植</li>
<li>难以多人合作；难以交流分享设计</li>
</ul>
</li>
</ul>
<h4 id="规范设计法">规范设计法</h4>
<ul>
<li>运用软件工程的思想和方法，把整个设计过程划分为若干阶段，把复杂的大问题分为若干相对简单的小问题，每个阶段只解决整个设计中的部分问题</li>
<li>迭代和逐步求精的过程</li>
<li>步骤
<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ul>
</li>
</ul>
<h3 id="数据库设计的需求分析">数据库设计的需求分析</h3>
<blockquote>
<p>怎样进行数据库设计的需求分析？</p>
</blockquote>
<h4 id="需求分析的目标">需求分析的目标</h4>
<ul>
<li>处理要求：指用户要完成什么处理功能，对处理的响应时间和处理方式的要求</li>
<li>信息要求：指系统中所涉及的数据及数据之间的联系，具体收集数据的名称、类型、长度等，确定数据之间联系的类型</li>
<li>安全性和完整性的要求</li>
</ul>
<h4 id="需求分析的方法">需求分析的方法</h4>
<ol>
<li>调查用户实际要求，与用户达成共识</li>
<li>分析、表达用户的需求
<ul>
<li>用<strong>数据流图</strong>表达数据和处理之间的关系</li>
<li>用<strong>数据字典</strong>描述系统中各类数据</li>
</ul>
</li>
</ol>
<h3 id="数据库概念结构设计">数据库概念结构设计</h3>
<blockquote>
<p>如何利用E-R法进行应用系统的概念模型设计？</p>
</blockquote>
<ol>
<li>局部E-R图设计</li>
<li>综合分E-R图形成总E-R图
<ul>
<li>解决冲突，将各分E-R图合并起来生成<strong>初步E-R图</strong>
<ul>
<li>冲突主要包括属性冲突、命名冲突、结构冲突</li>
<li><strong>属性冲突</strong>：属性的类型、取值范围或取值集合不同，或属性取值单位冲突——讨论协商解决</li>
<li><strong>命名冲突</strong>：包括属性名、实体名、联系名之间的同名异义，异名同义——建立命名表，统一命名</li>
<li><strong>结构冲突</strong>：
<ul>
<li>同一对象在不同应用中有不同抽象；如在一应用中为实体，在另一应用中为属性——把属性变为实体或实体变为属性</li>
<li>同一实体在不同分E-R图中属性个数、次序不同——属性求并，再适当调整次序</li>
<li>实体之间的联系在不同分E-R图中呈现不同类型———根据语义加以综合或调整</li>
</ul>
</li>
</ul>
</li>
<li>消除不必要的冗余，生成<strong>基本E-R图</strong>
<ul>
<li>初步E-R图可能存在冗余的联系和冗余的关系</li>
<li>分析法</li>
<li>规范化方法
<ol>
<li>将各种关系依赖转化为码之间的函数依赖</li>
<li>进行极小化处理</li>
<li>考察每一个在极小集中消失的函数依赖，确定是否为冗余</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据库逻辑结构设计">数据库逻辑结构设计</h3>
<blockquote>
<p>数据库的逻辑结构设计的主要内容是什么？</p>
</blockquote>
<ul>
<li>E-R图向关系模型的转换
<ul>
<li>将实体型、联系和多元联系，每个转换为一个关系模式</li>
<li>具有相同码的关系可以合并</li>
<li>对于实体型：实体的属性就是关系的属性，实体的码就是关系的码</li>
<li>对于联系：联系相连的属性的码以及联系的属性为关系的属性，候选码根据各实体的码组合决定</li>
<li>对于弱实体类型：创建一个新的关系，新关系主码为被依赖关系的主码和弱实体类型的码，属性为弱实体类型所有的属性</li>
<li>对于超类/子类联系：为超类和子类分别创建关系，超类关系包含所有子类均有的属性，以及一个子类判定码；子类关系包含超类的码和子类的属性</li>
</ul>
</li>
<li>关系模型的规范化和优化
<ul>
<li>规范化
<ul>
<li>按照数据依赖的理论，确定关系模型的范式等级</li>
</ul>
</li>
<li>优化
<ul>
<li>按系统的处理要求，确定是否进行模式合并或分解</li>
<li>可以对关系模式进行必要的分解
<ul>
<li><strong>水平分解</strong>：将关系的元组分为若干子集合，每个集合为一个子关系，以提高系统效率
<ul>
<li>二八原则：将经常使用的数据分解出来作为一个关系，其它数据作为另一个关系</li>
</ul>
</li>
<li><strong>垂直分解</strong>：将关系模式的属性分解为若干子集合，形成若干子关系模式
<ul>
<li>原则：经常在一起使用的属性从R中分解出来的形成一子关系模式</li>
<li>垂直分解必须保证无损连接性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设计用户子模式
<ul>
<li>根据局部应用的需求，结合具体DBMS的特点，设计用户外模式
<ul>
<li>列更符合用户习惯</li>
<li>对不同级别的用户定义不用的视图，保证系统的安全性</li>
<li>降低复杂查询的难度，简化使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库物理结构设计">数据库物理结构设计</h3>
<blockquote>
<p>数据库的物理结构设计的主要内容是什么？</p>
</blockquote>
<ul>
<li>物理结构包括数据在物理设备上的存储结构与存取方法</li>
<li>存储结构
<ul>
<li>存放位置
<ul>
<li>经常存取部分和存取频率较低部分分开存放</li>
<li>数据和日志备份放于不同的磁盘上</li>
</ul>
</li>
<li>系统配置
<ul>
<li>配置变量、存储分配参数、进行物理优化</li>
</ul>
</li>
</ul>
</li>
<li>存取方法
<ul>
<li>索引
<ul>
<li>包含索引记录/索引项</li>
<li>索引记录必须有序</li>
<li>索引并非越多越好</li>
</ul>
</li>
<li>聚集
<ul>
<li>将关系中某个属性（组）相同的记录存放在连续的物理块中，提高该属性的查询速度</li>
<li>一个关系只能参加一个聚集</li>
<li>经常进行连接操作的关系可以建立聚集</li>
<li>建立和维护聚集系统开销很大，对于更新操作多于连接操作的关系不应该使用聚集</li>
</ul>
</li>
<li>hash
<ul>
<li>通过hash将关键字转化为地址</li>
<li>使用hash无法加速区间查询方法</li>
<li>一般要求关系的大小可与之，而且不变</li>
<li>如果关系大小动态改变，则需要dbms提供动态hash存取方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-存储管理和索引">第七章 存储管理和索引</h2>
<blockquote>
<p>总的来说，这章内容在CO和OS讲过一遍了（大概</p>
</blockquote>
<h3 id="物理存储系统">物理存储系统</h3>
<blockquote>
<p>DBMS如何在磁盘上以文件形式存储数据？</p>
</blockquote>
<h4 id="存储分级">存储分级</h4>
<ul>
<li>内存：cpu，内存DRAM</li>
<li>外存：固态硬盘SSD，机械硬盘HDD，网盘Network Storage</li>
<li>数据只有放入内存才能被处理</li>
<li>DBMS设定数据库的基本存储在磁盘上，DBMS管理内存和外存的数据交换</li>
<li>DBMS目标：最小化磁盘的主存键传输存储块的数量，即最小化磁盘存取次数</li>
</ul>
<h4 id="磁盘">磁盘</h4>
<ul>
<li>架构：盘片-磁道-扇区</li>
<li>时间：寻道时间+旋转时间+传输时间</li>
</ul>
<h3 id="数据存储结构">数据存储结构</h3>
<blockquote>
<p>DBMS如何在磁盘上以文件形式存储数据？</p>
</blockquote>
<h4 id="概述-2">概述</h4>
<ul>
<li>数据库的表映射到文件</li>
<li>文件被组织为记录的序列，记录被映射到磁盘块上</li>
<li>文件由若干磁盘块构成，块是存储分配和数据传输的单位</li>
<li>一个块可以包含几个记录，每条记录被完全包含在单个块中</li>
</ul>
<h4 id="文件的磁盘块分配">文件的磁盘块分配</h4>
<ul>
<li>连续分配：文件在块中连续存放</li>
<li>连接分配：数据块中包含下个数据块的指针</li>
<li>按簇分配：簇是连续的几个磁盘块，簇之间指针连接</li>
<li>索引分配：索引块中存放指向数据块的指针</li>
</ul>
<h4 id="数据库块-页">数据库块/页</h4>
<ul>
<li>
<p>每个页由头部header和数据构成</p>
</li>
<li>
<p>header包含了页中数据的元数据，例如：</p>
<ul>
<li>页大小</li>
<li>checksum</li>
<li>dbms版本</li>
</ul>
</li>
<li>
<p>分槽（slot）页结构</p>
<ul>
<li>Header中记录了已经使用的槽数，以及最后一个被用槽的偏移量，以及一个槽数组</li>
<li>槽数据记录的每个元组的偏移量</li>
<li>槽数组从开始向尾部增长，记录元组从尾部向开始增长，二者相遇被认为页满</li>
<li>便于存储变长记录</li>
</ul>
</li>
<li>
<p>记录（tuple）结构</p>
<ul>
<li>记录是字节序列，DBMS负责将其解释为属性类型和值
<ul>
<li>记录头部：元组的元数据，例如加锁信息</li>
<li>记录数据：属性的实际数据，不能超过一个页</li>
<li>唯一标识符ID</li>
</ul>
</li>
</ul>
</li>
<li>
<pre><code class="language-mermaid">graph LR
A[文件]
B[页]
C[Header]
D[Slot]
E[Tuple]
A--&gt;B--&gt;C
B--&gt;D--&gt;E
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 缓冲区管理	</span><br><span class="line"></span><br><span class="line">&gt; DBMS如何管理内存，以及从磁盘读写文件？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这里的缓冲区，真的不是缓存吗？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 脑袋好痒，感觉又听了一遍计组</span><br><span class="line"></span><br><span class="line">* 缓冲区：主存中可以存储磁盘块副本的区域</span><br><span class="line">* 缓冲区管理区：缓存空间分配，内外存交换</span><br><span class="line">* 交换单位：块/页</span><br><span class="line">* 目标：最小化交换的块/页数</span><br><span class="line">* 页表、策略......</span><br><span class="line"></span><br><span class="line">### 索引</span><br><span class="line"></span><br><span class="line">&gt; DBMS如何提高数据访问效率？有哪些类型的索引，它们是如何构造的？</span><br><span class="line"></span><br><span class="line">#### 基本概念</span><br><span class="line"></span><br><span class="line">* 构成</span><br><span class="line"></span><br><span class="line">  * **索引域（搜索码）**：存储数据文件的属性组</span><br><span class="line">  * **指引**：指向记录在磁盘块的位置</span><br><span class="line"></span><br><span class="line">* 索引对部分属性进行了组织或排序，且大小比原记录小得多，利用DBMS快速有效访问</span><br><span class="line"></span><br><span class="line">* DBMS负责在执行查询时使用最恰当的索引</span><br><span class="line"></span><br><span class="line">* 分类</span><br><span class="line"></span><br><span class="line">  * 排序索引 vs. 哈希索引</span><br><span class="line">    * 字如其名~</span><br><span class="line">  * 聚集索引 vs. 非聚集索引</span><br><span class="line">    * 聚集索引：索引排列顺序和记录一致，又被称为**主索引**（Primary Index）</span><br><span class="line">    * 非聚集索引：索引顺序和记录不一致，又被称为**辅助索引**（Secondary Index）</span><br><span class="line">  * 稠密索引 vs. 稀疏索引</span><br><span class="line">    * 稠密索引：对于文件中每个搜索码都有索引项与其对应</span><br><span class="line">    * 稀疏索引：只有部分索引域有索引项，索引大小小，但查询慢；非聚集索引都是稀疏索引</span><br><span class="line"></span><br><span class="line">* 多级索引</span><br><span class="line"></span><br><span class="line">  &gt; 索引文件可能过大，所以需要多级索引以减小空间大小</span><br><span class="line"></span><br><span class="line">  * 二叉树索引：排列方式和二叉堆相同</span><br><span class="line">  * 多枝树索引：同一节点有多个关键字值的情况时使用</span><br><span class="line">  * B树</span><br><span class="line">  * B+树</span><br><span class="line">  * 哈希索引</span><br><span class="line"></span><br><span class="line">## 第八章 查询处理与查询优化</span><br><span class="line"></span><br><span class="line">&gt; 关系查询处理的四个阶段：</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 查询分析</span><br><span class="line">&gt; * 查询检查</span><br><span class="line">&gt; * 查询优化</span><br><span class="line">&gt; * 查询执行</span><br><span class="line">&gt;</span><br><span class="line">&gt; 查询时间的主要影响因素：IO次数</span><br><span class="line"></span><br><span class="line">### 查询处理过程</span><br><span class="line"></span><br><span class="line">&gt; 从接收到SQL查询语句到语句执行，需要做哪些处理？</span><br><span class="line"></span><br><span class="line">#### 关系查询处理步骤</span><br><span class="line"></span><br><span class="line">1. 查询分析</span><br><span class="line">2. 查询检查</span><br><span class="line">3. 查询优化</span><br><span class="line">4. 查询执行</span><br><span class="line"></span><br><span class="line">#### 查询代价的度量</span><br><span class="line"></span><br><span class="line">* 影响因素：磁盘访问，CPU, 网络通信等</span><br><span class="line">* 从磁盘访问数据的**I/O代价**通常是最重要的代价</span><br><span class="line">* 使用访问磁盘的块数作为估计代价的因素</span><br><span class="line"></span><br><span class="line">### 查询操作的实现</span><br><span class="line"></span><br><span class="line">&gt; 选取、连接等操作是如何实现的？</span><br><span class="line"></span><br><span class="line">#### 选择运算实现算法</span><br><span class="line"></span><br><span class="line">* 全表扫描法</span><br><span class="line">  * 按照物理顺序读表的块到内存，检查每个元组，直到所有块都接受检查</span><br><span class="line">* 索引扫描法</span><br><span class="line">  * 先通过索引项找到目标索引项，再通过索引项找到元组</span><br><span class="line"></span><br><span class="line">#### 连接运算实现算法</span><br><span class="line"></span><br><span class="line">* 嵌套—循环法</span><br><span class="line">  * 两个表，一个为外循环，一个为内循环</span><br><span class="line">  * 需要检查每一种元组组合，代价高</span><br><span class="line">  * 元组较多的为外层关系</span><br><span class="line">* 索引嵌套—循环法</span><br><span class="line">  * 如果内层关系有索引，则可以用其索引加速连接查询过程</span><br><span class="line">  * 如果内外都有索引，则用元组较少的关系作为外层关系</span><br><span class="line">* 排序—合并法</span><br><span class="line">  * 将两个关系在连接属性上排序</span><br><span class="line">  * 用类似two pointers的方法遍历两个关系一遍</span><br><span class="line">  * 只能用于等值连接或自然连接</span><br><span class="line">* 哈希连接法</span><br><span class="line">  * 将两表的连接属性映射到一个集合上，只在集合的同一个元组中遍历查找连接项</span><br><span class="line">  * 只能用于等值连接或自然连接</span><br><span class="line"></span><br><span class="line">#### 排序算法</span><br><span class="line"></span><br><span class="line">* 快速排序：内存中可以完全容纳关系时使用</span><br><span class="line">* 外排序-归并</span><br><span class="line">  1. 简历多个排好序的归并段（run），仅包含关系的部分记录</span><br><span class="line">  2. 对归并段进行排序</span><br><span class="line"></span><br><span class="line">#### 其它算法</span><br><span class="line"></span><br><span class="line">* 去重：使重复数据相邻，再删除</span><br><span class="line">  * 排序</span><br><span class="line">  * 哈希</span><br><span class="line">* 投影：在每个元组上投影，再去重</span><br><span class="line">* 并差交</span><br><span class="line">  * 类似排序-合并法</span><br><span class="line">  * 或类似hash法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表达式的执行</span><br><span class="line"></span><br><span class="line">* 物化（Materialized）</span><br><span class="line">  * 按次序每次执行一个运算，并将结果保存为一个临时关系，写入磁盘</span><br><span class="line">  * 适用性广泛，但临时表的写和读代价大</span><br><span class="line">* 流水线（Pipeline）</span><br><span class="line">  * 将运算过程整理为一个运算树</span><br><span class="line">  * 同时执行多个运算，将结果传递给下一个运算</span><br><span class="line">  * 不需要在磁盘存储临时关系</span><br><span class="line">  * 对于一些操作不适用，比如排序</span><br><span class="line"></span><br><span class="line">### 查询优化</span><br><span class="line"></span><br><span class="line">&gt; 查询优化的目标是什么？如何进行优化？</span><br><span class="line"></span><br><span class="line">#### 查询优化的必要性</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">SELECT SN</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S# = SC.S# AND C#=’02’;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>该sql在好的查询语句和坏的查询语句下表现可能相差10^4倍！！！</p>
<h4 id="查询优化的目标">查询优化的目标</h4>
<p>选择一个高效执行的查询处理策略，使得查询代价 最小，即访问磁盘的块数最少</p>
<h4 id="查询优化方法">查询优化方法</h4>
<blockquote>
<p>查询计划：定义了每个操作的算法以及这些操作执行的顺序</p>
</blockquote>
<ul>
<li>查询的代数优化
<ul>
<li>关系代数表达式的优化，即按照一定的规则，<strong>改变代数表达式中操作的次序和组合</strong></li>
<li>启发式优化规则
<ul>
<li>选择运算尽早执行（减小中间关系——减少元组数据）</li>
<li>投影运算尽早执行（减小中间关系——减少属性数目）</li>
<li>把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来（减少扫描关系的次数）</li>
<li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算（把笛卡尔积与选择转换为连接）</li>
<li>找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用（中间结果复用）</li>
</ul>
</li>
<li>关系代数表达式等价变换规则
<ul>
<li>共十一条<br>
<s>因为打赌不会考这个所以没有记录（理直气壮）</s></li>
</ul>
</li>
</ul>
</li>
<li>查询的物理优化
<ul>
<li><strong>存取路径和底层操作算法的选择</strong>，包括基于规则或基于代价等</li>
<li>常用方法
<ul>
<li>基于规则的启发式优化方法</li>
<li>基于代价估算的优化方法</li>
<li>两者结合的优化方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询优化的一般步骤">查询优化的一般步骤</h4>
<ol>
<li>把查询转换成语法树，如关系代数语法树（查询树）</li>
<li>把查询树利用代数优化转换成优化后的标准形式</li>
<li>利用基于启发式规则的物理优化，选择底层的操作算法与存取路径，生成查询计划；利用基于代价的物理优化，选择代价最小的</li>
</ol>
<h2 id="第九章-事务处理技术">第九章 事务处理技术</h2>
<blockquote>
<p>事务是数据库恢复和并发控制的基本单位</p>
</blockquote>
<h3 id="事务的概念">事务的概念</h3>
<blockquote>
<p>在数据库系统运行过程中，有哪些情况可能造成数据丢失、错误或不一致？</p>
<p>什么是事务？事务有哪些特性？事务的实现机制有哪些？</p>
</blockquote>
<h4 id="事务的特性">事务的特性</h4>
<blockquote>
<p>ACID</p>
</blockquote>
<ul>
<li>原子性（Atomicity）：由恢复技术实现</li>
<li>一致性（Consistency）：由原子性保证</li>
<li>隔离性（Isolation）：由并发控制实现</li>
<li>持久性（Durability）：由恢复技术实现</li>
</ul>
<h4 id="事务的特性遭破坏的情况">事务的特性遭破坏的情况</h4>
<ul>
<li>多个事务并发运行时，不同事务的操作交叉进行</li>
<li>事务在运行过程中被强行停止</li>
</ul>
<h3 id="数据库恢复技术">数据库恢复技术</h3>
<blockquote>
<p>如何将数据库从各种故障中恢复？</p>
</blockquote>
<h4 id="概述-3">概述</h4>
<ul>
<li>将数据库从错误状态回复到已知正确状态</li>
<li>通过数据库管理系统的恢复子系统完成</li>
</ul>
<h4 id="故障的种类">故障的种类</h4>
<ul>
<li>事务内部的故障
<ul>
<li>人工对数据库进行回滚</li>
<li>死锁、运算溢出等</li>
</ul>
</li>
<li>系统故障
<ul>
<li>硬件错误、操作系统故障、掉电等</li>
<li>会使事务异常终止，不会破坏数据</li>
</ul>
</li>
<li>介质故障
<ul>
<li>硬盘损坏</li>
<li>破坏数据库，影响相关事务</li>
</ul>
</li>
<li>计算机病毒
<ul>
<li>对数据进行非法修改</li>
<li>基本不在考虑范围内</li>
</ul>
</li>
</ul>
<h4 id="恢复的实现技术">恢复的实现技术</h4>
<blockquote>
<p>核心思想：UNDO未完成的事务，REDO已完成的事务</p>
</blockquote>
<ul>
<li>故障对数据库系统的影响
<ol>
<li>数据本身被破坏</li>
<li>数据本身没有问题</li>
</ol>
</li>
<li>恢复原理：冗余</li>
<li>关键问题
<ul>
<li>如何建立冗余</li>
<li>如何通过冗余实施数据库恢复</li>
</ul>
</li>
<li>数据转储的两种状态
<ul>
<li>静态转储
<ul>
<li>系统中无事务运行时进行的转储操作，并且转储 过程中，不允许对数据库进行任何存取、修改</li>
<li>优点：保证副本的数据一致性</li>
<li>缺点：由于转储必须等待正在运行的事务结束才能开始，而新的事务必须等待转储结束才能执行，降低了数据库的可用性</li>
</ul>
</li>
<li>动态转储
<ul>
<li>转储期间允许对数据库进行存取或修改</li>
<li>优点：不影响数据库的可用性</li>
<li>缺点：不能保证副本上的数据正确、有效，还必须把转储期间各事务对数据库的修改记录下来，建立日志文件</li>
</ul>
</li>
</ul>
</li>
<li>数据转储的两种方式
<ul>
<li>海量转储
<ul>
<li>每次存储全部数据库</li>
</ul>
</li>
<li>增量转储
<ul>
<li>只存储上次更新的内容</li>
</ul>
</li>
</ul>
</li>
<li>日志文件的建立和使用
<ul>
<li>记录事务对数据库的操作</li>
<li>分为以记录为单位和以数据块为单位</li>
<li>必须先写日志文件，后写数据库</li>
<li>遇到事务故障和系统故障时，撤销事务，根据转储类型恢复数据</li>
</ul>
</li>
<li>UNDO
<ul>
<li>反向扫描日志文件，查找事务的更新操作</li>
<li>对更新操作执行逆操作，直到遇到该事务的开始标志为止</li>
</ul>
</li>
<li>检查点
<ul>
<li>纯日志恢复技术的缺点
<ul>
<li>搜索耗费时间多</li>
<li>不必要重做某些事务</li>
</ul>
</li>
<li>检查点技术可以改善效率，使得检查点前的事务不必重做</li>
<li>新增重新开始文件，动态维护检查点</li>
<li>恢复步骤
<ul>
<li>将检查点时的事务放入UNDO列表</li>
<li>从检查点开始正向扫描日志，将开始的事务放入UNDO，结束的事务放入REDO</li>
<li>UNDOUNDO的，REDOREDO的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并发控制技术">并发控制技术</h3>
<blockquote>
<p>并发控制的基本思想与主要方法是什么？如何保证并发事务调度的正确性？</p>
</blockquote>
<h4 id="概述-4">概述</h4>
<ul>
<li>并发控制优点
<ul>
<li>提高系统吞吐量</li>
<li>减少平均相应时间</li>
</ul>
</li>
<li>问题
<ul>
<li>如果控制不当，会对数据一致性带来问题</li>
</ul>
</li>
<li>具体问题种类
<ul>
<li>丢失更新（Lost Update）</li>
<li>“脏”数据的读出（Dirty Read）</li>
<li>不可重复读（Non-Repeatable Read）</li>
</ul>
</li>
</ul>
<h4 id="并发控制主要方法">并发控制主要方法</h4>
<ul>
<li>
<p>采用封锁机制，合理调度并发事务，避免并发事务间的互相干扰造成数据的不一致</p>
</li>
<li>
<p>封锁的类型</p>
<ul>
<li>
<p>排它锁（X锁）：不可读不可写</p>
</li>
<li>
<p>共享锁（S锁）：可读不可写</p>
</li>
<li>
<table>
<thead>
<tr>
<th>t1\t2</th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>S</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>一级封锁协议——防止丢失更新</p>
<ul>
<li>事务在修改数据前必须对其加X锁，直到事务结束</li>
<li>防止丢失修改，不能保证可重复读和不读“脏”数据</li>
</ul>
</li>
<li>
<p>二级封锁协议——防止读脏数据</p>
<ul>
<li>一级封锁协议+事务在读取数据前必须加S锁，直到读取结束</li>
<li>防止读“脏”数据，不能保证重复读</li>
</ul>
</li>
<li>
<p>三级封锁协议——防止不可重复度</p>
<ul>
<li>一级封锁协议+事务在读取数据前必须加S锁，直到事务结束</li>
<li>防止重复读</li>
</ul>
</li>
<li>
<p>封锁粒度：封锁对象的大小</p>
<ul>
<li>粒度大，并发性低，封锁机构简单，开销小</li>
<li>粒度小，并发性高，封锁机构复杂，开销大</li>
</ul>
</li>
<li>
<p>多粒度封锁协议</p>
<ul>
<li>
<p>多粒度树中每个结点可以被独立地加锁，覆盖所有子节点</p>
</li>
<li>
<p>显式封锁是当前结点被直接加锁</p>
</li>
<li>
<p>隐式封锁是当前节点的先祖被加锁导致当前结点加锁</p>
</li>
<li>
<p><strong>意向锁</strong></p>
<ul>
<li>
<p>对任意节点加锁时，必须先对其上级节点加意向锁</p>
</li>
<li>
<p>在后续加锁时，不需要额外检查下级节点的封锁，只需检查对象和它的上级结点</p>
</li>
<li>
<p>三种意向锁</p>
<ul>
<li>意向共享锁 IS</li>
<li>意向排它锁 IX</li>
<li>意向共享排它锁 SIX （<strong>先加S，再加IX</strong>）</li>
</ul>
</li>
<li>
<table>
<thead>
<tr>
<th>t1\t2</th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>X</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>IS</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>IX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>SIX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="活锁和死锁">活锁和死锁</h4>
<blockquote>
<p>CO还在追我</p>
</blockquote>
<ul>
<li>解决死锁的办法
<ul>
<li>预防死锁</li>
<li>死锁检测和解除</li>
</ul>
</li>
<li>预防死锁
<ul>
<li>一次封锁法</li>
<li>顺序封锁法</li>
</ul>
</li>
<li>死锁检测
<ul>
<li>超时法</li>
<li>等待图法</li>
</ul>
</li>
<li>死锁恢复
<ul>
<li>选择一个处理死锁代价最小的事务，将其撤销</li>
</ul>
</li>
</ul>
<h4 id="事务可串行化调度">事务可串行化调度</h4>
<ul>
<li>定义
<ul>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行它们时的结果相同，我们称这种调度策略为可串行化调度</li>
<li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li>
</ul>
</li>
<li><strong>两段锁协议</strong>（Two-phase Locking）
<ul>
<li>事务分为两个阶段，第一个阶段是获得封锁，也称为扩展阶段；第二个阶段是释放封锁，也称为收缩阶段</li>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再获得任何其它封锁</li>
</ul>
</li>
<li>执行两段锁协议的事务一定是可串行化调度的，但仍可能发生死锁</li>
</ul>
<h4 id="其它并发控制方法">其它并发控制方法</h4>
<ul>
<li>事务隔离级别</li>
<li>悲观与乐观并发控制技术</li>
<li>多版本并发控制技术</li>
</ul>
<h2 id="第十章-数据库技术新发展">第十章 数据库技术新发展</h2>
<blockquote>
<p>终于结束啦~~让我们来听听数据库的“新”技术</p>
</blockquote>
<h3 id="概述-5">概述</h3>
<blockquote>
<p>数据库技术有哪些新的发展方向？</p>
</blockquote>
<h4 id="SQL">SQL</h4>
<ul>
<li>传统关系型数据库，支持SQL操作、事务ACID特性</li>
<li>几千用户，TB级数据</li>
</ul>
<h4 id="NoSQL">NoSQL</h4>
<ul>
<li>Not only SQL，非关系型的数据库，水平可扩展、分布式</li>
<li>不使用SQL，不支持事务的ACID操作</li>
<li>HBase、MongoDB等</li>
</ul>
<h4 id="NewSQL">NewSQL</h4>
<ul>
<li>新的可扩展/高性能数据库</li>
<li>不仅具有NoSQL的海量数据存储管理能力，还保持了传统数据库支持ACID和SQL等特性</li>
<li>华为云数据库GaussDB，VoltDB，OceanBase等</li>
</ul>
<h3 id="分布式数据库概念与技术">分布式数据库概念与技术</h3>
<blockquote>
<p>什么是分布式数据库系统，分布式数据库的体系结构以及实现技术是怎样的？</p>
</blockquote>
<h4 id="分布式数据库系统基本概念">分布式数据库系统基本概念</h4>
<ul>
<li>分布式数据库系统定义
<ul>
<li>分布式数据库是由一组分布在计算机网络的不同结点上的数据组成，每个结点具有独立处理的能力（称为场地自治），可以执行局部应用，同时每个结点也能通过网络通信支持全局应用
<ul>
<li>局部应用：只操作一个结点上 数据库的应用</li>
<li>全局应用：操作两个或两个以上节点上数据库的应用</li>
</ul>
</li>
<li>分布性— 数据分布存储在网络的各个节点上</li>
<li>逻辑上的整体性—数据被一种机制联系在一起，构成一个有机整体</li>
<li>分布式数据库以“数据分布”为前提，强调场地自治性（局部应用）以及自治场地之间的协作性（全局应用），两者缺一不可
<ul>
<li>场地自治性：每个场地有自己的数据库、一组终端、运行局部DBMS，是独立的DBS，具有高度自治性</li>
<li>自治场地之间的协作性：各结点组成整体，从用户角度看，分布式数据库系统逻辑上如同一个集中式数据库一样，用户可以在任何场地执行全局应用</li>
</ul>
</li>
</ul>
</li>
<li>分布式数据库系统的特点
<ul>
<li>数据独立性
<ul>
<li>数据的逻辑独立性和物理独立性</li>
<li>数据的分布独立性
<ul>
<li>数据的逻辑分片、数据物理位置分布的细节、重复副本（冗余数据）一致性问题、局部结点上的数据模型等与用户程序无关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>集中与自治相结合的控制结构</li>
<li>适当增加数据冗余
<ul>
<li>提高系统的可靠性、可用性</li>
<li>提高系统性能</li>
<li>不利于更新，增加了系统维护代价</li>
<li>全局的一致性、可串行性和可恢复性</li>
</ul>
</li>
</ul>
<h4 id="分布式数据库系统体系结构">分布式数据库系统体系结构</h4>
<ul>
<li>整体结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[全局外模式1]</span><br><span class="line">B[全局外模式2]</span><br><span class="line">C[全局概念模式]</span><br><span class="line">D[分片模式]</span><br><span class="line">E[分布模式]</span><br><span class="line">F[局部概念模式1]</span><br><span class="line">G[局部内模式1]</span><br><span class="line">H[局部DB1]</span><br><span class="line">I[局部概念模式2]</span><br><span class="line">J[局部内模式2]</span><br><span class="line">K[局部DB2]</span><br><span class="line">A---C</span><br><span class="line">B---C</span><br><span class="line">C---D---E</span><br><span class="line">E---F</span><br><span class="line">E---I</span><br><span class="line">F---G---H</span><br><span class="line">I---J---K</span><br></pre></td></tr></table></figure>
<ul>
<li>分布透明性
<ul>
<li>分片透明性</li>
<li>位置透明性</li>
<li>局部数据模型透明性</li>
</ul>
</li>
</ul>
<h4 id="分布式数据库系统主要技术">分布式数据库系统主要技术</h4>
<ul>
<li>分布式查询处理和优化</li>
<li>分布事务管理</li>
</ul>
<h3 id="云数据库">云数据库</h3>
<blockquote>
<p>什么是云数据库，其架构是怎样的？</p>
</blockquote>
<ul>
<li>云数据库
<ul>
<li>概述
<ul>
<li>云服务提供商建立计算、存储与网络资源池，基于这些资源池提供基础设施、平台和软件服务</li>
<li>用户可按需按量购买和使用云服务提供的各种服务</li>
</ul>
</li>
<li>挑战和机遇
<ul>
<li>如何更好的将云的底层资源池化、资源解耦优势发挥出来，支撑用户建立高可用、可拓展性、弹性的数据库系统</li>
</ul>
</li>
<li>数据库服务DataBase-as-a-Service，DBaaS
<ul>
<li>云数据库服务
<ul>
<li>一主多从</li>
</ul>
</li>
<li>云原生数据库技术
<ul>
<li>计算存储分离</li>
<li>计算节点无状态</li>
<li>存储集群灵巧化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>原生分布式数据库
<ul>
<li>由多个同构型的数据库节点组成</li>
<li>每个节点都具备分布式处理的能力</li>
<li>相互连接组合形成面向用户的单个数据库</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="/img/pwa/yomiya.png"></a><div class="post-copyright__author_name">fysszlr's blog</div><div class="post-copyright__author_desc">※嘀嘟嘟嘀嘟~※</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">fysszlr's blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tags-punctuation"><i class="solitude fa-solid fa-hashtag"></i>数据库<span class="tagsPageCount">1</span></span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/23/%E4%BB%8E%E6%97%B6%E5%BA%8F%E5%88%B0%E6%97%B6%E7%A9%BA%E5%86%8D%E5%88%B0%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">论文笔记：从时序到时空再到城市大模型的演进</div></div></a></div></nav><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude fa-solid fa-comment"></i><span> 评论</span><span class="count"> (<span class="twikoo-count"><i class="solitude fa-solid fa-spinner"></i></span>)</span></div></div><div class="comment-wrap"><div id="twikoo-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/pwa/head.jpg"></div><div class="author-info__description_group"><div class="author-info__description">站长正在熬夜学习<b>编译原理</b>，blog有空就更新www</div><div class="author-info__description2">希望你可以在这里找到对你有用的知识和教程喵~</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">fysszlr</div><div class="author-info__desc">※嘀嘟嘟嘀嘟~※</div></a><div class="card-info-social-icons is-center"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fa-solid fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">数据库Database课程笔记-BUAA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%BF%B0"><span class="toc-text">第一章 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-text">数据管理技术的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%BA%A7%E7%94%9F%E4%B8%8E%E5%8F%91%E5%B1%95%E8%83%8C%E6%99%AF"><span class="toc-text">数据库技术产生与发展背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-text">数据管理技术的发展过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98%E4%B8%8E%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-text">数据库系统基本问题与关键技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%89%B9%E7%82%B9"><span class="toc-text">数据库系统数据管理特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DBMS%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-text">DBMS主要功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">第二章 关系数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">关系模型的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="toc-text">关系的数学定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">关系的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">关系模型的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">关系模型的数据操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-text">关系数据语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80"><span class="toc-text">数据库数据语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BC%98%E7%82%B9"><span class="toc-text">关系数据语言特点及优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB"><span class="toc-text">关系数据语言分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">关系模型的优点与缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%87%E5%87%86%E8%AF%AD%E8%A8%80SQL"><span class="toc-text">第三章 关系数据库标准语言SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E7%89%B9%E7%82%B9"><span class="toc-text">SQL特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E6%B3%95"><span class="toc-text">SQL语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD"><span class="toc-text">SQL数据查询功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD"><span class="toc-text">SQL数据定义功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C"><span class="toc-text">SQL视图操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0"><span class="toc-text">SQL数据更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">SQL数据控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">空值处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FSQL"><span class="toc-text">嵌入式SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BF%9D%E6%8A%A4"><span class="toc-text">第四章 数据库保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-text">数据库安全性控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6%E5%90%AB%E4%B9%89"><span class="toc-text">数据库安全性控制含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-text">数据库安全性控制方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AF%84%E6%B5%8B%E6%A0%87%E5%87%86"><span class="toc-text">可信计算机系统评测标准</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-text">数据库完整性控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E5%90%AB%E4%B9%89"><span class="toc-text">数据完整性含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-text">完整性约束条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="toc-text">完整性控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA"><span class="toc-text">第五章 关系数据理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-text">函数依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-text">三种函数依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%85%AC%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">函数依赖公理系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-text">规范化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E6%A6%82%E5%BF%B5%EF%BC%881NF%EF%BC%89"><span class="toc-text">范式概念（1NF）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9B%B8%E5%85%B3%E7%9A%84%E8%8C%83%E5%BC%8F%EF%BC%882NF-3NF-BCNF%EF%BC%89"><span class="toc-text">与函数依赖相关的范式（2NF, 3NF, BCNF）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F"><span class="toc-text">多值依赖与第四范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-text">多值依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4NF"><span class="toc-text">4NF</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E7%9A%84%E7%90%86%E8%AE%BA"><span class="toc-text">模式分解的理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">模式分解的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E7%9A%84%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E6%80%A7"><span class="toc-text">分解的无损连接性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E7%9A%84%E4%BF%9D%E6%8C%81%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-text">分解的保持函数依赖性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-text">模式分解的原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">模式分解的算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E6%B1%82%E8%A7%A3%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-text">候选码的求解和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%B1%82%E8%A7%A3%E5%80%99%E9%80%89%E7%A0%81%E7%9A%84%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="toc-text">快速求解候选码的充分条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E8%BE%B9%E4%B8%BA%E5%8D%95%E5%B1%9E%E6%80%A7%E7%9A%84%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E5%80%99%E9%80%89%E7%A0%81%E6%88%90%E5%91%98%E7%9A%84%E5%9B%BE%E8%AE%BA%E5%88%A4%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-text">左边为单属性的函数依赖集候选码成员的图论判定方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%B1%9E%E6%80%A7%E4%BE%9D%E8%B5%96%E9%9B%86%E5%80%99%E9%80%89%E7%A0%81%E6%B1%82%E8%A7%A3%E6%B3%95"><span class="toc-text">多属性依赖集候选码求解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">第六章 数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-text">数据库设计方法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-text">数据库设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E8%AF%95%E5%87%91%E6%B3%95"><span class="toc-text">手工试凑法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E8%AE%BE%E8%AE%A1%E6%B3%95"><span class="toc-text">规范设计法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">数据库设计的需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">需求分析的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">需求分析的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">数据库概念结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">数据库逻辑结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">数据库物理结构设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-text">第七章 存储管理和索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">物理存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E7%BA%A7"><span class="toc-text">存储分级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E7%9B%98"><span class="toc-text">磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">数据存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E7%A3%81%E7%9B%98%E5%9D%97%E5%88%86%E9%85%8D"><span class="toc-text">文件的磁盘块分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9D%97-%E9%A1%B5"><span class="toc-text">数据库块&#x2F;页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">查询优化的目标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">查询优化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">查询优化的一般步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF"><span class="toc-text">第九章 事务处理技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">事务的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">事务的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E9%81%AD%E7%A0%B4%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">事务的特性遭破坏的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF"><span class="toc-text">数据库恢复技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">故障的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-text">恢复的实现技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF"><span class="toc-text">并发控制技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">并发控制主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81"><span class="toc-text">活锁和死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96%E8%B0%83%E5%BA%A6"><span class="toc-text">事务可串行化调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-text">其它并发控制方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E6%96%B0%E5%8F%91%E5%B1%95"><span class="toc-text">第十章 数据库技术新发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL"><span class="toc-text">SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoSQL"><span class="toc-text">NoSQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NewSQL"><span class="toc-text">NewSQL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%8A%80%E6%9C%AF"><span class="toc-text">分布式数据库概念与技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">分布式数据库系统基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">分布式数据库系统体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF"><span class="toc-text">分布式数据库系统主要技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%91%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">云数据库</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fa-solid fa-map"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="数据库Database课程笔记-BUAA"><img alt="数据库Database课程笔记-BUAA" src="https://images.pexels.com/photos/1148820/pexels-photo-1148820.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=800"></a><div class="content"><span class="title" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="数据库Database课程笔记-BUAA">数据库Database课程笔记-BUAA</span><span class="article-recent_post_categories" href="/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/">笔记</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/23/%E4%BB%8E%E6%97%B6%E5%BA%8F%E5%88%B0%E6%97%B6%E7%A9%BA%E5%86%8D%E5%88%B0%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/" title="论文笔记：从时序到时空再到城市大模型的演进"><img alt="论文笔记：从时序到时空再到城市大模型的演进" src="https://images.pexels.com/photos/169677/pexels-photo-169677.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=2"></a><div class="content"><span class="title" href="/2024/09/23/%E4%BB%8E%E6%97%B6%E5%BA%8F%E5%88%B0%E6%97%B6%E7%A9%BA%E5%86%8D%E5%88%B0%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/" title="论文笔记：从时序到时空再到城市大模型的演进">论文笔记：从时序到时空再到城市大模型的演进</span><span class="article-recent_post_categories" href="/2024/09/23/%E4%BB%8E%E6%97%B6%E5%BA%8F%E5%88%B0%E6%97%B6%E7%A9%BA%E5%86%8D%E5%88%B0%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/">笔记</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/03/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B/" title="C语言系统级编程"><img alt="C语言系统级编程" src="https://images.pexels.com/photos/1181332/pexels-photo-1181332.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=2"></a><div class="content"><span class="title" href="/2024/09/03/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B/" title="C语言系统级编程">C语言系统级编程</span><span class="article-recent_post_categories" href="/2024/09/03/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B/">笔记</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/02/%E8%AE%B8%E5%8F%AF%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" title="许可：关于算法的一些思考"><img alt="许可：关于算法的一些思考" src="https://images.pexels.com/photos/7125583/pexels-photo-7125583.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=2"></a><div class="content"><span class="title" href="/2024/09/02/%E8%AE%B8%E5%8F%AF%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" title="许可：关于算法的一些思考">许可：关于算法的一些思考</span><span class="article-recent_post_categories" href="/2024/09/02/%E8%AE%B8%E5%8F%AF%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">笔记</span></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/Hexo-Solitude(Arclicy)%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="Hexo-Solitude(Acrylic)博客配置教程"><img alt="Hexo-Solitude(Acrylic)博客配置教程" src="https://images.pexels.com/photos/262508/pexels-photo-262508.jpeg?auto=compress&amp;cs=tinysrgb&amp;w=1260&amp;h=750&amp;dpr=2"></a><div class="content"><span class="title" href="/2024/08/15/Hexo-Solitude(Arclicy)%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="Hexo-Solitude(Acrylic)博客配置教程">Hexo-Solitude(Acrylic)博客配置教程</span><span class="article-recent_post_categories" href="/2024/08/15/Hexo-Solitude(Arclicy)%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/">经验</span></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>fysszlr</span></div><div class="footer-bar-description">修之于身，施之于事，见之于言</div></div><div id="footer_deal"><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/fysszlr" title="Github"><i class="solitude  fab fa-github"></i></a><div class="nolazyload footer_mini_logo" id="footer_mini_logo" title="返回顶部" onclick="sco.toTop()"><img src= "/img/loading.avif" data-lazy-src="/img/pwa/yomiya.png" alt="返回顶部"></div><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/274642803" title="Bilibili"><i class="solitude  fab fa-bilibili"></i></a></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2025 By&nbsp;<a class="footer-bar-link" href="/">fysszlr</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="Theme">Theme</a></div></div></div><div class="comment-barrage needEndHide"></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude fa-solid fa-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude fa-solid fa-clone"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude fa-solid fa-clipboard"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude fa-solid fa-comment-medical"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude fa-regular fa-window-maximize"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude fa-solid fa-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude fa-solid fa-clone"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude fa-solid fa-cloud-arrow-down"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude fa-solid fa-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="solitude fa-solid fa-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="solitude fa-solid fa-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="solitude fa-solid fa-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="solitude fa-solid fa-clone"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-randomPost" onclick="toRandomPost()||rm.hideRightMenu()"><i class="solitude fas fa-tower-broadcast"></i><span>Random</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/categories/')||rm.hideRightMenu()"><i class="solitude fas fa-clone"></i><span>Categories</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/tags/')||rm.hideRightMenu()"><i class="solitude fas fa-tags"></i><span>Tags</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude fa-solid fa-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></div><div class="rightMenu-item" id="menu-translate"><i class="solitude fa-solid fa-language"></i><span>轉為繁體</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=2.0.7"></script><script src="/js/main.js?v=2.0.7"></script><script src="/js/third_party/waterfall.min.js?v=2.0.7"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=2.0.7"></script><script>dark()
</script><script src="/js/tw_cn.js?v=2.0.7"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="/js/covercolor/local.js?v=2.0.7"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><script src="/js/right_menu.js?v=2.0.7"></script><div class="js-pjax"><script>(() => {
    const getCount = () => {
        const ele = document.querySelectorAll('.twikoo-count')
        if (!ele) return
        twikoo.getCommentsCount({
            envId: 'cloudbase-baas-0g7bgq0i662ac256',
            region: 'ap-shanghai',
            urls: [window.location.pathname],
            includeReply: false
        }).then(res => {
            ele.forEach(item => item.textContent = res[0].count)
        }).catch(err => {
            console.error(err)
        })
    }
    const init = () => {
        twikoo.init(Object.assign({
            el: '#twikoo-wrap',
            envId: 'cloudbase-baas-0g7bgq0i662ac256',
            region: 'ap-shanghai',
            path: window.location.pathname,
            onCommentLoaded: () => {
                GLOBAL_CONFIG.lightbox && utils.lightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
            }
        }, null))

         && getCount()
        sco.owoBig({
            body: '.OwO-body',
            item: '.OwO-items li'
        })

        true && barrageTwikoo()
    }

    const loadTwikoo = () => {
        if (typeof twikoo === 'object') setTimeout(init,0)
        else utils.getScript('https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.38/twikoo.all.min.js').then(init)
    }

    if ('Twikoo' === 'Twikoo' || true) {
        if (true) utils.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
        else loadTwikoo()
    } else {
        window.loadTwoComment = loadTwikoo
    }
})()
</script><script>async function barrageTwikoo() {
    await fetch("cloudbase-baas-0g7bgq0i662ac256", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            event: "COMMENT_GET",
            accessToken: "mongodb+srv://twikoo:YW5FuYrll85rYuqm@blog-comment.yxti8zc.mongodb.net/?retryWrites=true&w=majority&appName=blog-comment",
            url: window.location.pathname
        })
    }).then(async res => {
        if (!res.ok) throw new Error("HTTP error! status: " + res.status)
        const data = await res.json();
        const init = () => {
            initializeCommentBarrage((data.data).map(item => Object.assign({
                content: item.comment,
                nick: item.nick,
                mailMd5: item.mailMd5,
                id: item.id
            })))
        }
        if (typeof initializeCommentBarrage === "undefined") await utils.getScript('/js/third_party/barrage.min.js?v=2.0.7').then(init)
        else init()
    }).catch(error => console.error("An error occurred while fetching comments: ", error))
}</script><script defer pjax src="https://cdnjs.cloudflare.com/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude fa-solid fa-xmark"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=2.0.7"></script><!-- Tianli-Talk--><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="7732681405" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--efu-main)"></meting-js></div></body></html><script>const posts=["2025/01/10/数据库笔记/","2024/09/23/从时序到时空再到城市大模型的演进/","2024/09/03/C语言系统级编程/","2024/09/02/许可：关于算法的一些思考/","2024/08/15/Hexo-Solitude(Arclicy)博客配置教程/","2024/07/12/Ascand C 学习笔记/","2024/07/10/昇思MindSpore介绍/","2023/12/22/CO-P7设计文档/","2023/11/24/陈震：创业及并购经验分享/","2023/11/04/OOpre-课程总结/","2023/11/04/462OJ-Ver1-0-基于云服务器的CO自动化评测OJ平台/","2023/10/23/CO-P2上机记录/","2023/10/20/OOpre-Lec6-继承与接口的使用/","2023/10/16/CO-P1上机记录/","2023/10/13/OOpre-Lec5-JAVA程序常见错误分析/","2023/10/10/CO-P0上机记录/","2023/10/08/OOpre-Lec4-输入解析的结构性设计/","2023/09/25/CO-pre上机记录/","2023/09/25/西方音乐鉴赏/","2023/09/20/OOpre Lec3-如何管理对象/","2023/09/18/c++&csharp/","2023/09/17/第一次の建站/"];function toRandomPost(){ pjax.loadUrl(GLOBAL_CONFIG.root+posts[Math.floor(Math.random()*posts.length)]); }</script>