<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CO P1上机记录</title>
    <url>/2023/10/16/CO-P1%E4%B8%8A%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>依旧是在遇到了大量突发情况下惊险完成了P1，于是想着将我的想法与遇到的问题写下，期望能够对大家有些许的启发www~</p>
<hr>
<h2 id="T1：P1-L1-dotProduct-2023"><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1144&amp;PieId=1121">T1：P1_L1_dotProduct_2023</a></h2>
<h3 id="题解：">题解：</h3>
<h4 id="法一：暴力大法好">法一：暴力大法好</h4>
<p>应该有不少同学和我一样，考试中不确定for怎么写，直接<code>ctrl+c</code> <code>ctrl+v</code>写了32位的🤪🤪</p>
<p>硬要说有什么优化的话…vector_a和vector_b字数太长了，<s>看着有点烦</s>容易打错字，可以自己定义两个32位wire替代~</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] b;</span><br><span class="line"><span class="keyword">assign</span> a = vector_a;</span><br><span class="line"><span class="keyword">assign</span> b = vector_b;</span><br><span class="line"><span class="keyword">assign</span> result =</span><br><span class="line">    (a[<span class="number">0</span>] &amp; b[<span class="number">0</span>]) +</span><br><span class="line">    (a[<span class="number">1</span>] &amp; b[<span class="number">1</span>]) +</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    (a[<span class="number">31</span>] &amp; b[<span class="number">31</span>]);</span><br></pre></td></tr></table></figure>
<p>当然，你也可以在C或者Python或者JAVA（或者verilog）中打表来减少复制时间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++) </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;(a[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] &amp; b[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]);&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="法二：for循环">法二：for循环</h4>
<p>在Verilog里写for循环优雅地解决问题当然是我们最提倡的方式</p>
<p>一般来说，verilog里的for循环可以这么写</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">always</span> @(*) <span class="keyword">begin</span></span><br><span class="line">    <span class="comment">//preliminary</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; max_i;i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        	<span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>将进行位运算的步骤放进for循环里，很轻松就可以求解问题</p>
<hr>
<h2 id="T2：P1-L4-coloring-2023"><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1171&amp;PieId=1121">T2：P1_L4_coloring_2023</a></h2>
<h3 id="题解：-2">题解：</h3>
<p>本题有两种设计状态的方式：</p>
<ol>
<li>
<p>用一个变量存储当前状态</p>
<table>
<thead>
<tr>
<th>当前序列</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>无颜色</td>
<td>000</td>
</tr>
<tr>
<td>红</td>
<td>001</td>
</tr>
<tr>
<td>红红</td>
<td>010</td>
</tr>
<tr>
<td>绿</td>
<td>011</td>
</tr>
<tr>
<td>绿绿</td>
<td>100</td>
</tr>
<tr>
<td>蓝</td>
<td>101</td>
</tr>
<tr>
<td>蓝蓝</td>
<td>110</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>用两个变量存储当前状态</p>
<table>
<thead>
<tr>
<th>当前颜色</th>
<th>当前数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>无颜色</td>
<td>0</td>
</tr>
<tr>
<td>红</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>2</td>
</tr>
<tr>
<td>绿</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>2</td>
</tr>
<tr>
<td>蓝</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>2</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>从状态数上，两种方法差不多，但在实际编程中，第二种表示方法由于可以用if合并一些情况的处理方式，也许会稍微快一点</p>
<p>下面以方法二模式列出代码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] now; <span class="comment">//当前颜色</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt; <span class="comment">//当前数量</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//preliminary</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (cnt) </span><br><span class="line">            <span class="number">0</span> : <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">1</span> : <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (color == now) <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( (now ^ color) == <span class="number">1</span>) <span class="keyword">begin</span> <span class="comment">//判断是否红绿相接，下同</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2</span> : <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (color == now) <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( (now ^ color) == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    <span class="comment">//do something</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>有以下两点需要注意一下：</p>
<ol>
<li>本题为<strong>异步复位</strong>，且为<strong>低电平有效</strong>，假如实在想不起来<code> negedge</code>，就只能试试用组合逻辑实现清零操作了（据说有佬成功了orz）</li>
<li>在初始化的时候，不建议把颜色清成0，否则当下一个输入1的时候电路就会出错。解决办法为特判一下或者一开始就把颜色清成2，这样就不会和任何输入冲突。（因为这个挂了好几次~😿)</li>
</ol>
<hr>
<h2 id="T3：numberNest">T3：numberNest</h2>
<h3 id="题意：">题意：</h3>
<p>定义两个相同数字之间的部分为“数字匹配”，对于数字匹配，有以下要求：</p>
<ol>
<li>一个数字的匹配中的数字必须比这个数大，如123321是合理的，而121121是不合理的</li>
<li>一个数字匹配的下一个数字只能比这个数字大1，如1234444321是合理的，而1331是不合理的</li>
</ol>
<p>输入：串行输入的数字序列</p>
<p>输出：当前输入的序列是否合理，合理输出0；不合理输出1，并将当前序列清空</p>
<p>（由于记忆问题，题目描述可能有略微区别，还请大家多多谅解www~）</p>
<h3 id="题解：-3">题解：</h3>
<p>本题依旧有两个解法：</p>
<h4 id="法一：状态机大法">法一：状态机大法</h4>
<p>题目对数据限制了最多为5，据此可以列出状态机</p>
<p>相信一定会有别的大佬详细讲解这种方法的，我就不献丑啦🎶~</p>
<h4 id="法二：两个if法">法二：两个if法</h4>
<p>定义一个状态state，为当前正在进行匹配的数字，如123的state为3，122的state为1，空串的state为0</p>
<p>不难发现，在任何情况下，我们的合理输入(用in表示)只有两种：</p>
<ol>
<li>
<p>in = state + 1</p>
<p>序列开始了下一个匹配，需要将state加一</p>
</li>
<li>
<p>in = state</p>
<p>序列结束了当前匹配，需要将state减一</p>
</li>
</ol>
<p>（这么说可能稍微有点抽象，大家可以自己构造几个数据跑一跑）</p>
<p>相反，只要不满足上面的情况，就说明序列不合理</p>
<p>我们可以简单地写出代码</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!rst_n) <span class="keyword">begin</span></span><br><span class="line">        check &lt;= <span class="number">0</span>;</span><br><span class="line">        state &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (in == state + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            check &lt;= <span class="number">0</span>;</span><br><span class="line">            state &lt;= state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in == state) <span class="keyword">begin</span></span><br><span class="line">            check &lt;= <span class="number">0</span>;</span><br><span class="line">            state &lt;= state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">       	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">           	check &lt;= <span class="number">1</span>;</span><br><span class="line">            state &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这种方法的优点在于<s>代码比较短</s>，可拓展性比较好（指对数据范围的依赖小）</p>
<hr>
<h2 id="总结：">总结：</h2>
<p>本次考试的三个题目，并没有简单地考查状态机或组合电路等基本知识，而是要求考生对Verilog编程语言具有较深刻的理解和熟练掌握，才能较为轻松地解决。</p>
<p>同时，本次考试加大了对测试块（TB）编写的要求，对于P4及以后的练习，很可能会出现不编写测试块就无法解决的问题。愿我们都能在此之前武装到牙齿，能够从容面对即将到来的挑战~</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>Ascand C 学习笔记</title>
    <url>/2024/07/12/Ascand%20C%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>fysszlr の Ascand C 学习笔记</h1>
<blockquote>
<p>让我们一起来探索这个充满可能性的领域吧！</p>
</blockquote>
<h2 id="异构计算架构CANN">异构计算架构CANN</h2>
<h3 id="背景">背景</h3>
<p>AI创新正加速发展：从“<strong>预测推断</strong>”到“<strong>内容生成</strong>”，我们正经历一场从感知理解世界到生成创造世界的变革。</p>
<ol>
<li><strong>第一次浪潮</strong>：符号主义+逻辑推理</li>
<li><strong>第二次浪潮</strong>：专家系统+机器学习</li>
<li><strong>第三次浪潮</strong>：深度学习
<ol>
<li><strong>第四次浪潮</strong>：智能内容生成（如ChatGPT）</li>
</ol>
</li>
</ol>
<h3 id="昇腾基础架构介绍（CANN）">昇腾基础架构介绍（CANN）</h3>
<h4 id="1-华为在AI行业的投入与发展">1. 华为在AI行业的投入与发展</h4>
<ul>
<li><strong>2018.10</strong>：华为正式进军AI行业</li>
<li><strong>2022.11</strong>：昇腾基础软硬件全面升级</li>
</ul>
<p>华为致力于打造性能卓越、易于使用的全场景人工智能平台，推动AI行业的全面发展。</p>
<h4 id="2-昇腾AI基础软硬件架构的创新与优势">2. 昇腾AI基础软硬件架构的创新与优势</h4>
<ul>
<li><strong>硬件与计算框架</strong>：昇腾与英伟达对比，支持主流AI框架（如PyTorch、TensorFlow），以及昇思MindSpore，CANN对标英伟达的CUDA。</li>
<li><strong>自研达芬奇架构与高集成SoC设计</strong>：专为AI计算设计，具备最优配比的算力、内存和带宽，匹配AI应用场景，实现极致能效和面效比。</li>
</ul>
<h4 id="3-昇腾AI异构计算架构CANN">3. 昇腾AI异构计算架构CANN</h4>
<ul>
<li><strong>通用计算</strong>：操作系统使能CPU硬件指令抽象编码及执行。</li>
<li><strong>AI计算</strong>：CANN使能CPU与NPU协同编码，充分发挥NPU计算能力，通过CPU分配计算指令，实现NPU并行计算。</li>
</ul>
<h4 id="4-昇腾CANN的功能与特点">4. 昇腾CANN的功能与特点</h4>
<ul>
<li><strong>处理器并行加速</strong>：支持大模型并行计算加速，支持原生开发（Ascend C）和生态迁移（GPU到NPU）。</li>
<li><strong>算子设计与实现能力</strong>：从“追赶”到“自我超越”，持续突破。</li>
<li><strong>高性能基础算子库</strong>：实现网络瞬时加速，开发核心融合算子库，涵盖多种计算需求。</li>
</ul>
<h4 id="5-软硬协同优化">5. 软硬协同优化</h4>
<ul>
<li><strong>二进制算子库</strong>：提升动态shape能力，解决Python运行速度慢的问题，使用最优调度模板自动调用。</li>
</ul>
<h4 id="6-昇腾图优化引擎">6. 昇腾图优化引擎</h4>
<ul>
<li><strong>图优化引擎</strong>：优化串行指令为并行执行，提升计算效率；通过“工序合并”减少计算节点和数据交互，降低内存开销。</li>
<li><strong>计算图执行下沉技术</strong>：将计算任务下放到硬件设备，实现算力均衡和高效调度。</li>
</ul>
<h4 id="7-自动调优引擎AOE">7. 自动调优引擎AOE</h4>
<ul>
<li><strong>持续升级</strong>：优化算子默认优化策略，实现零门槛低成本、零代码模型性能自动优化。</li>
</ul>
<h4 id="8-端到端开发部署">8. 端到端开发部署</h4>
<ul>
<li><strong>快速构建AI应用</strong>：从算子到模型的开发部署，基于昇腾平台。</li>
</ul>
<h4 id="9-Ascend-C算子编程语言">9. Ascend C算子编程语言</h4>
<ul>
<li><strong>使能算子极简开发</strong>：遵循C/C++标准规范，提供自动化流水并行调度、结构化核函数编程、CPU/NPU孪生调试。</li>
</ul>
<h4 id="10-开放的CANN开发体系">10. 开放的CANN开发体系</h4>
<ul>
<li><strong>支持开发者</strong>：开放对接北向生态，提供丰富的融合算子和Runtime库，共同推动大模型创新生态。</li>
</ul>
<h4 id="11-昇腾AI开发者工具">11. 昇腾AI开发者工具</h4>
<ul>
<li><strong>Atlas 200 DK A2开发者套件</strong>：提供开箱即用的开发者套件，支持AI应用创新和高校教学，售价1999元。</li>
<li><strong>Orange Pi AIPro开发板</strong>：昇腾AI与香橙派联合发布，适合开发者使用。</li>
</ul>
<h2 id="Ascend-C算子开发">Ascend C算子开发</h2>
<h3 id="架构说明">架构说明</h3>
<h4 id="AI-Core架构">AI Core架构</h4>
<h5 id="逻辑架构">逻辑架构</h5>
<ul>
<li><strong>计算单元</strong>：包含三种基础计算资源：矩阵计算单元、向量计算单元、标量计算单元。</li>
<li><strong>存储系统</strong>：包括张量缓冲器、统一缓冲区、标量缓冲区、L1缓冲区等。</li>
<li><strong>控制单元</strong>：提供指令控制，相当于AI Core的司令部。</li>
</ul>
<h5 id="并行计算架构抽象">并行计算架构抽象</h5>
<ul>
<li><strong>AI Core</strong>：NPU的内部单元。</li>
<li><strong>Global Memory</strong>：位于NPU内部，AI Core外部。</li>
<li><strong>Local Memory</strong>：位于AI Core内部。</li>
</ul>
<p>计算单元包括三种基础计算资源：</p>
<ol>
<li><strong>Scalar计算单元</strong></li>
<li><strong>Cube计算单元</strong></li>
<li><strong>Vector计算单元</strong></li>
</ol>
<p>此外，还有存储单元和搬运单元：</p>
<ul>
<li><strong>异步指令流</strong>：Scalar计算单元读取指令序列并分发指令。</li>
<li><strong>同步信号流</strong>：管理指令间的依赖关系。</li>
<li><strong>计算数据流</strong>：DMA将数据搬运到Local Memory，完成计算后再次搬出。</li>
</ul>
<h4 id="算子">算子</h4>
<p>算子对应网络中层或节点的计算逻辑，广义地讲，对任何函数进行某一项操作都可以算一个算子。</p>
<h5 id="算子基本概念">算子基本概念</h5>
<ul>
<li><strong>算子名称</strong>（Name）</li>
<li><strong>算子类型</strong>（Type）</li>
<li><strong>数据容器</strong>（Tensor）</li>
</ul>
<h5 id="Tensor">Tensor</h5>
<p>张量是存储算子输入和输出数据的容器，张量描述符（TensorDesc）描述张量的属性，包括名称、形状、数据类型和数据排布格式。在深度学习中，多维度数据通常用多维数据存储。</p>
<h5 id="轴（Axis）">轴（Axis）</h5>
<p>轴代表张量中维度的下标，可以理解为展开n次后的数据。</p>
<h4 id="Ascend-C算子">Ascend C算子</h4>
<p>Ascend C是CANN针对算子开发推出的编程语言。</p>
<h5 id="自定义算子的场景">自定义算子的场景</h5>
<ol>
<li>将第三方框架转化为适配昇腾平台的离线模型时遇到不支持的算子。</li>
<li>在应用中设计某些数学运算，通过自定义算子实现。</li>
<li>迁移第三方框架的网络训练脚本到昇腾平台时遇到未定义行为。</li>
</ol>
<h5 id="Device模块">Device模块</h5>
<p>Device模块负责指定计算运行的设备，包含多个接口用于Device管理。</p>
<ol>
<li>通过<code>aclrtSetDevice</code>接口指定计算使用的设备，分配计算资源。</li>
<li>在分配的Device上进行操作。</li>
<li>通过<code>aclrtResetDevice</code>接口释放设备。</li>
</ol>
<h5 id="核函数">核函数</h5>
<p>核函数是算子设备侧的入口，直接在设备侧执行。指针入参变量统一为<code>__gm__ uint8_t*</code>，指向Global Memory上的内存地址。</p>
<p>核函数调用语句格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;blockDim, l2ctrl, stream&gt;&gt;&gt;(argument list);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>blockDim</strong>：规定核函数在几个核上执行。</li>
<li><strong>l2ctrl</strong>：保留参数，设置为<code>nullptr</code>。</li>
<li><strong>stream</strong>：任务队列，管理任务并行。</li>
</ul>
<h5 id="SPMD模型">SPMD模型</h5>
<p>Ascend C算子编程采用SPMD模型，将数据拆分并分布在多个计算核心上运行。</p>
<h5 id="编程范式">编程范式</h5>
<h6 id="抽象编程模型“TPIPE并行计算”">抽象编程模型“TPIPE并行计算”</h6>
<ul>
<li><strong>流程</strong>：搬入——计算——搬出。</li>
</ul>
<h6 id="流水任务">流水任务</h6>
<p>流水任务是单核处理程序中主程序调度的并行任务。通过流水任务实现数据的并行处理来提升性能。</p>
<h6 id="矢量编程流水线设计">矢量编程流水线设计</h6>
<ul>
<li><strong>逻辑位置</strong>：搬入（VECIN）、搬出（VECOUT）。</li>
<li>每次需要先EnQue，再DeQue。</li>
<li>VECIN和VECOUT采用双缓冲区设计，并行存取。</li>
</ul>
<h5 id="资源管理模块">资源管理模块</h5>
<p>任务间数据传递使用的内存统一由内存管理模块Pipe管理。</p>
<h5 id="临时变量">临时变量</h5>
<p>临时变量通过Pipe管理，使用TBuf数据结构申请空间。</p>
<h2 id="Ascend-C-进阶">Ascend C 进阶</h2>
<h3 id="Host侧开发">Host侧开发</h3>
<ul>
<li><strong>在Host侧定义切分策略</strong></li>
<li><strong>Host侧算子实现</strong>
<ul>
<li><strong>Tiling实现</strong>：计算数据切分过程的参数。</li>
<li><strong>Shape推导</strong>：推理算子的输出张量描述，避免动态内存分配。</li>
<li><strong>算子原型注册</strong>：描述算子的输入、输出及算子在AI处理器上的实现信息。</li>
</ul>
</li>
</ul>
<h3 id="矩阵编程">矩阵编程</h3>
<h4 id="矩阵乘基础">矩阵乘基础</h4>
<ul>
<li><strong>MatMul</strong>：$C = A*B+Bias$</li>
</ul>
<h4 id="基础知识">基础知识</h4>
<ul>
<li><strong>分形格式</strong>：ND、NZ</li>
<li><strong>TPosition</strong></li>
</ul>
<h4 id="Matmul矩阵乘">Matmul矩阵乘</h4>
<ul>
<li><strong>步骤</strong>
<ul>
<li>创建Matmul对象</li>
<li>初始化</li>
<li>设置左矩阵A，右矩阵B，Bias</li>
<li>完成矩阵乘操作</li>
<li>结束矩阵乘操作</li>
</ul>
</li>
</ul>
<h4 id="Matmul-Api算法">Matmul Api算法</h4>
<ul>
<li>尽量不要切k轴，避免多个核之间的数据依赖。</li>
<li>m k n</li>
<li>singleCorem singleCorek singleCore n</li>
<li>depth A1, depth B1——基本块的数量</li>
<li>stepM stepN</li>
</ul>
<h3 id="性能优化">性能优化</h3>
<h4 id="理论性能评估">理论性能评估</h4>
<ul>
<li>达成某个执行单元的bound并不代表算子性能最优。</li>
<li>如果算法没有重复计算过程，并且达到计算单元的bound，则认为算子性能最优。</li>
<li>如果搬运单元达到bound，并且算法达到搬运量最小，则认为算子性能最优。</li>
</ul>
<h4 id="并行切分（Tiling）">并行切分（Tiling）</h4>
<h4 id="0级API">0级API</h4>
<ul>
<li><strong>SIMD</strong>：单指令多数据</li>
<li><strong>Mask</strong>：为1表示参与运算，为0表示不参与运算</li>
</ul>
<h4 id="iCache优化">iCache优化</h4>
<h4 id="Shape对齐亲和计算">Shape对齐亲和计算</h4>
<h4 id="Buffer资源分配">Buffer资源分配</h4>
<h4 id="大型reducesum">大型reducesum</h4>
<ul>
<li>构造辅助矩阵，将Scalar操作变为Cube操作</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>462OJ Ver1.0 - 基于云服务器的CO自动化评测OJ平台</title>
    <url>/2023/11/04/462OJ-Ver1-0-%E5%9F%BA%E4%BA%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84CO%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%84%E6%B5%8BOJ%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h1>462OJ Ver1.0 - 基于云服务器的CO自动化评测OJ平台</h1>
<blockquote>
<p>花米租服务器不易，欢迎大家前来品尝 :)</p>
</blockquote>
<h2 id="简介">简介</h2>
<p>使用c++，python等编程语言综合开发，能将verilog代码提交至远程服务器并自动评测输出结果</p>
<h2 id="特点">特点</h2>
<ul>
<li>
<p>使用学长<code>Toby Shi</code>的魔改Mars对拍验证输出正确性</p>
</li>
<li>
<p>无需在本地配置iverilog，python等环境，主打&quot;<strong>拿来就用</strong>&quot;</p>
<ul>
<li>未来将部署ISE，争取实现行为与课程平台一致</li>
</ul>
</li>
<li>
<p>提供更强的数据点以供评测</p>
<ul>
<li>
<p>保证每个数据点均能被正确执行，在此基础上增强数据强度</p>
</li>
<li>
<p>当前版本由线下准备数据点，未来将把数据点生成任务集成至云服务器</p>
</li>
</ul>
</li>
<li>
<p>结合课程进度推进更新数据点</p>
</li>
<li>
<p>每次测试后均删除上传代码，隐私得到保障</p>
</li>
</ul>
<h2 id="使用指南">使用指南</h2>
<h3 id="准备文件">准备文件</h3>
<p>将全部.v文件（不包括testbench文件）打包至文件夹，文件夹名为<code>&#123;学号&#125;_P4</code>，注意将顶层文件模块名改为<code>mips.v</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- 2237xxxx_P4</span><br><span class="line">|   |-- mips.v</span><br><span class="line">|   |-- alu.v</span><br><span class="line">|   |-- grf.v</span><br><span class="line">|   |-- ......</span><br></pre></td></tr></table></figure>
<h3 id="上传文件">上传文件</h3>
<p>在终端(如cmd中)运行</p>
<p>其中“{}”不需要被打出，下同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r &#123;包含.v文件的文件夹绝对路径&#125; stu&#123;学号&#125;@82.157.78.233:~</span><br></pre></td></tr></table></figure>
<p>按照提示输入密码，等待文件上传成功</p>
<h3 id="进行评测">进行评测</h3>
<p>在终端运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh stu&#123;学号&#125;@82.157.78.233</span><br></pre></td></tr></table></figure>
<p>按照提示输入密码，登录成功后运行指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash runP4.sh &#123;学号&#125;</span><br></pre></td></tr></table></figure>
<p>即可进行评测并获得结果反馈</p>
<blockquote>
<p>如果你已经会使用linux指令，那么这些对你来说都不是什么难事</p>
</blockquote>
<h3 id="查看评测结果">查看评测结果</h3>
<p>登录成功后运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash judgeP4.sh &#123;学号&#125;</span><br></pre></td></tr></table></figure>
<p>可以查看最近一次的评测信息，默认<strong>不显示</strong>错误数据点的信息</p>
<p>需要查看<strong>所有</strong>错误数据点的信息，可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash judgeP4.sh &#123;学号&#125; all</span><br></pre></td></tr></table></figure>
<p>需要查看<strong>第一个</strong>错误数据点的信息，可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bash judgeP4.sh &#123;学号&#125; first</span><br></pre></td></tr></table></figure>
<h2 id="评测信息解读">评测信息解读</h2>
<p>对每一个测试点，评测机会返回<code>Accepted</code>，<code>Wrong Answer</code>，<code>Output more than expected</code>，<code>Output more than expected</code>四种提示信息当中的一种，只有返回<code>Accepted</code>时才会评判为该数据点通过</p>
<p><code>$ bash runP4.sh &#123;学号&#125;</code>的返回信息示例如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User ID: /home/ubuntu/ans/P4/2237xxxx</span><br><span class="line">··············································</span><br><span class="line">Case 1: Output less than expected. Matching rate is 0.9838018990876932.</span><br><span class="line">Valid output(s): 94</span><br><span class="line">··············································</span><br><span class="line">Case 2: Output more than expected. Matching rate is 0.893569431500466.</span><br><span class="line">Valid output(s): 98</span><br><span class="line">··············································</span><br><span class="line">Case 3: Wrong Answer. Matching rate is 0.5222513089005235.</span><br><span class="line">Valid output(s): 107</span><br><span class="line">··············································</span><br><span class="line">Case 4: Accepted.</span><br><span class="line">Valid output(s): 133</span><br><span class="line">··············································</span><br><span class="line">Case 5: Accepted.</span><br><span class="line">Valid output(s): 57</span><br><span class="line">··············································</span><br><span class="line">Case 6: Accepted.</span><br><span class="line">Valid output(s): 88</span><br><span class="line">··············································</span><br><span class="line">Case 7: Accepted.</span><br><span class="line">Valid output(s): 46</span><br><span class="line">··············································</span><br><span class="line">Case 8: Accepted.</span><br><span class="line">Valid output(s): 117</span><br><span class="line">··············································</span><br><span class="line">Case 9: Accepted.</span><br><span class="line">Valid output(s): 51</span><br><span class="line">··············································</span><br><span class="line">Case 10: Accepted.</span><br><span class="line">Valid output(s): 77</span><br><span class="line">··············································</span><br><span class="line">Test Accuracy: 7 / 10.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有数据点通过，系统会额外返回<code>Congratulations!</code></p>
</blockquote>
<p>当出现错误数据点时，在<code>first</code>和<code>all</code>条件下，系统将打印你的输出与期望输出之间的差异文本，样例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @00003004: $ 5 &lt;= 3f500000</span><br><span class="line">- @00003008: $ 3 &lt;= 00003f74</span><br><span class="line">- @00003038: $20 &lt;= 00000000</span><br><span class="line">- @0000303c: $ 8 &lt;= 00000000</span><br><span class="line">  @00003040: *00001924 &lt;= 00003f74</span><br></pre></td></tr></table></figure>
<p>表示你的输出比期望输出<strong>缺失</strong>所列三行；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @0000303c: $30 &lt;= 00000000</span><br><span class="line">+ @00003040: $ 3 &lt;= 00000000</span><br><span class="line">+ @00003044: $25 &lt;= 036c3744</span><br><span class="line">+ @00003048: $13 &lt;= 1f0c0000</span><br><span class="line">  @00003040: $ 3 &lt;= 00000000</span><br></pre></td></tr></table></figure>
<p>表示你的输出比期望输出<strong>多出</strong>所列三行；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  @000030d8: $ 5 &lt;= 00000000</span><br><span class="line">- @000030dc: *000005d4 &lt;= 00000000</span><br><span class="line">?                              ^^^</span><br><span class="line"></span><br><span class="line">+ @000030dc: *000005d4 &lt;= 00000aaa</span><br><span class="line">?                              ^^^</span><br><span class="line"></span><br><span class="line">  @000030e0: $ 5 &lt;= 00000000</span><br><span class="line">- @000030e4: $19 &lt;= 01640000</span><br><span class="line">+ @000030e4: $19 &lt;= xxxxxxxx</span><br><span class="line">- @000030e8: $17 &lt;= 3b980000</span><br><span class="line">?                         ^^</span><br><span class="line"></span><br><span class="line">+ @000030e8: $17 &lt;= 3b9800cc</span><br><span class="line">?                         ^^</span><br></pre></td></tr></table></figure>
<p>表示你的输出与答案存在差异。</p>
<p>其中，<code>-</code>标记的为期望输出，<code>+</code>标记的为你的输出，<code>?</code>和<code>^</code>标记了你的输出与期望输出的不同。</p>
<h2 id="获取账号">获取账号</h2>
<p>获取账号方式，请通过邮件fysszlr@qq.com或添加我微信和我联系（保证免费）</p>
<h2 id="注意事项">注意事项</h2>
<p>请勿用本服务器进行任何与CO程序评测无关的事情！</p>
<p>包括但不限于把服务器当云盘用，用服务器来挖矿等！</p>
<h2 id="最后">最后</h2>
<p>本项目灵感来自上学期myk学长写的简易数据结构oj</p>
<p>感谢zlr同学进行服务器框架搭建、评测文件编程等工作</p>
<p>感谢lpf同学进行测试数据点随机生成、验证正确性与强度等工作</p>
<p>感谢zxw同学进行机器码、测试点导出，文本对拍评测等工作</p>
<p>受开发者水平限制，本oj难免有许多问题，还请学长和同学不吝指教🙏</p>
<p>如有问题，请截图发送到此帖下，或联系管理员fysszlr@qq.com（22373425张栗瑞）</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>CO-P7设计文档</title>
    <url>/2023/12/22/CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><a href="https://github.com/fysszlr/CO-buaa-2023">戳这里获取源代码</a></p>
<h1>P7设计文档</h1>
<h2 id="命名规则：">命名规则：</h2>
<ol>
<li>主模块为mips.v，命名为mips</li>
<li>主程序中的模块为mips_模块名，其它和P6保持一致（如下）</li>
<li>特殊模块为stall和controller，其中stall命名为_stall，controller在stall中命名为“流水线层级_judgeStall”，在mips中命名为“流水线层级_controller”</li>
<li>流水线寄存器有四个，命名为“流水线连续层级_reg“</li>
<li>其余模块命名为”_模块名“</li>
</ol>
<h2 id="整体架构">整体架构</h2>
<p>哎呀 图片走丢了（欸嘿~</p>
<h2 id="相对P6的调整">相对P6的调整</h2>
<ol>
<li>增加m_cp0模块，用于统筹中断和异常</li>
<li>增加异常判断数据通路，用以收集指令异常信息</li>
<li>将原有mips程序封装为mips_cpu，以实现cpu与系统桥的交互，从而达到“高内聚低耦合”的目标</li>
<li>增加mips_bridge，以将原有的dm接口分发到dm、timer0、timer1三个不同的区域</li>
<li>增加两个mips_timer，定期产生中断信号</li>
</ol>
<h2 id="Controller">Controller</h2>
<p>采用了分布式译码的方式，最大化减少代码重复，增加效率</p>
<p>下面对每一个信号进行阐述</p>
<hr>
<h3 id="judgeStall">judgeStall</h3>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>jal</th>
<th>jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>tuse_rs</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>\</td>
<td>0</td>
<td>\</td>
<td>0</td>
<td>\</td>
</tr>
<tr>
<td>tuse_rt</td>
<td>\</td>
<td>2</td>
<td>1</td>
<td>\</td>
<td>1</td>
<td>\</td>
<td>\</td>
<td>0</td>
<td>\</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>tnew</td>
<td>3</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>\</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>mdu_busy</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mdu_start</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="tuse-rs">tuse_rs</h4>
<p>在几个时钟周期到来后会使用grf_rs</p>
<p>\为高阻态</p>
<h4 id="tuse-rt">tuse_rt</h4>
<p>在几个时钟周期到来后会使用grf_rt</p>
<p>\为高阻态</p>
<h4 id="tnew">tnew</h4>
<p>在几个时钟周期到来后能够将写入写入寄存器的内容写入流水寄存器</p>
<p>只有当tuse&gt;=tnew时，电路才能正常流水，否则就要阻塞</p>
<h4 id="mdu-busy-mdu-start">mdu_busy mdu_start</h4>
<p>判断乘除槽当前是否被占用</p>
<p>若被占用，且当前d级指令为乘除槽相关指令，则暴力阻塞</p>
<hr>
<h3 id="d-controller">d_controller</h3>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>jal</th>
<th>jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmpOp</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>nPcOp</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>0</td>
</tr>
<tr>
<td>extOp</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>beq</th>
<th>bne</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmpOp</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<h4 id="cmpOp">cmpOp</h4>
<p>当分支判断语句到来时，控制cmp模块中进行运算的类型，输出branch</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>==</td>
<td>!=</td>
</tr>
</tbody>
</table>
<h4 id="nPcOp">nPcOp</h4>
<p>控制nPc模块跳转pc的类型</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>pc4</td>
<td>pcImm16</td>
<td>pcImm26</td>
<td>pcReg</td>
<td>epc</td>
</tr>
</tbody>
</table>
<h4 id="extOp">extOp</h4>
<p>控制ext模块中拓展立即数的类型，输出extImm</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>signext</td>
<td>signext00</td>
<td>sll16</td>
<td>ext00</td>
<td>zeroext</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ol>
<li>signex00为16位offset的拓展，结果已经加上了pc+4</li>
<li>ex00为26为立即数的拓展，结果已经在前面复制了四位pc</li>
</ol>
<hr>
<h3 id="e-controller">e_controller</h3>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>jal</th>
<th>jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>srcASel</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>srcBSel</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>aluOp</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>add</th>
<th>sub</th>
<th>and</th>
<th>or</th>
<th>slt</th>
<th>sltu</th>
<th>addi</th>
<th>andi</th>
<th>ori</th>
<th>slll</th>
</tr>
</thead>
<tbody>
<tr>
<td>aluOp</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>3</td>
<td>6</td>
<td>6</td>
<td>1</td>
<td>5</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>jal</th>
<th>jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>d1Sel</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>d2Sel</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>mduOp</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>mult</th>
<th>multu</th>
<th>div</th>
<th>divu</th>
<th>mthi</th>
<th>mtlo</th>
</tr>
</thead>
<tbody>
<tr>
<td>mduOp</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="srcASel">srcASel</h4>
<p>控制alu中srcA的类型</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>grf_rs</td>
</tr>
</tbody>
</table>
<h4 id="srcBSel">srcBSel</h4>
<p>控制alu中srcB的类型</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>grf_rt</td>
<td>extImm</td>
</tr>
</tbody>
</table>
<h4 id="aluOp">aluOp</h4>
<p>控制alu中进行运算的类型</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>+</td>
<td>-</td>
<td>|</td>
<td>&lt;&lt;</td>
<td>&amp;</td>
<td>&lt;</td>
</tr>
</tbody>
</table>
<h4 id="d1Sel">d1Sel</h4>
<p>控制被乘数，被除数和mthi，mtlo来源</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>grf_rs</td>
</tr>
</tbody>
</table>
<h4 id="d2Sel">d2Sel</h4>
<p>控制乘数和除数来源</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>grf_rt</td>
</tr>
</tbody>
</table>
<h4 id="mudOp">mudOp</h4>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>mult</td>
<td>multu</td>
<td>div</td>
<td>divu</td>
<td>mthi</td>
<td>mtlo</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="m-controller">m_controller</h3>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>j_jal</th>
<th>j_jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>memWrite</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>memOp</td>
<td></td>
<td></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>lw</th>
<th>lh</th>
<th>lb</th>
<th>sw</th>
<th>sh</th>
<th>sb</th>
</tr>
</thead>
<tbody>
<tr>
<td>memOp</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<h4 id="memWrite">memWrite</h4>
<p>dm写使能信号，1为写，0为不写</p>
<h4 id="memOp">memOp</h4>
<p>控制当前对dm进行读写操作的数据类型</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>w</td>
<td>h</td>
<td>b</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="转发相关信号">转发相关信号</h3>
<table>
<thead>
<tr>
<th></th>
<th>load</th>
<th>save</th>
<th>alu_r</th>
<th>alu_i</th>
<th>md</th>
<th>mt</th>
<th>mf</th>
<th>j_b</th>
<th>jal</th>
<th>jr</th>
<th>lui</th>
</tr>
</thead>
<tbody>
<tr>
<td>regDstSel</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>regWdSel</td>
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>mfhi</th>
<th>mhlo</th>
</tr>
</thead>
<tbody>
<tr>
<td>regWdSel</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<h4 id="regDstSel">regDstSel</h4>
<p>选择写入寄存器的位置来源</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>[15:11]</td>
<td>[20:16]</td>
<td>31</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ol>
<li>在controller中最后会直接输出regDst，而非选择信号</li>
<li>当写入位置为0时，视为regWrite为0</li>
</ol>
<h4 id="regWdSel">regWdSel</h4>
<p>选择写入寄存器的内容来源</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>nope</td>
<td>aluResult</td>
<td>memRd</td>
<td>extImm</td>
<td>pc4</td>
<td>hi</td>
<td>lo</td>
</tr>
</tbody>
</table>
<p>唯一需要注意的是pc4在转发和写入时其实为pc+8，这是由延迟槽的性质决定的</p>
<hr>
<h3 id="cp0相关信号">cp0相关信号</h3>
<table>
<thead>
<tr>
<th></th>
<th>mfc0</th>
<th>mtc0</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp0Write</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>cp0AddrIn</td>
<td>[15:11]</td>
<td></td>
</tr>
<tr>
<td>cp0AddrOut</td>
<td></td>
<td>[15:11]</td>
</tr>
<tr>
<td>cp0Wd</td>
<td></td>
<td>grf_rt</td>
</tr>
</tbody>
</table>
<h4 id="cp0Write">cp0Write</h4>
<p>决定是否对cp0进行写操作</p>
<h4 id="cp0AddrIn">cp0AddrIn</h4>
<p>从cp0中读数据的地址</p>
<h4 id="cp0AddrOut">cp0AddrOut</h4>
<p>向cp0中写数据的地址</p>
<table>
<thead>
<tr>
<th>cp0Addr</th>
<th>register</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>sr</td>
</tr>
<tr>
<td>13</td>
<td>cause</td>
</tr>
<tr>
<td>14</td>
<td>epc</td>
</tr>
</tbody>
</table>
<h4 id="cp0Wd">cp0Wd</h4>
<p>向cp0中写入的数据</p>
<h2 id="测试思路">测试思路</h2>
<ol>
<li>随机出现指令，指令为[要求支持的指令集]中的一种</li>
<li>使用c++编写单周期程序，保证测试程序合理性</li>
<li>不断生成，以得到更到强度的程序</li>
<li>对于剩余没有覆盖到的点，自己手动构造数据进行测试</li>
</ol>
<p>自己跑出的一个点</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">standard pipeline<span class="literal">-cycle</span>: <span class="number">879</span></span><br><span class="line">   slow pipeline<span class="literal">-cycle</span>: <span class="number">1695</span></span><br><span class="line">   accepted cycle range: [<span class="number">715</span>, <span class="number">1450</span>]</span><br></pre></td></tr></table></figure>
<p>在自己构造数据测试时，我发现了cpu对beq在阻塞中的行为在一些特殊情况下有异常，并成功通过改变阻塞的位置解决的问题</p>
<h2 id="思考题">思考题</h2>
<h4 id="1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被-CPU-知晓的？">1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</h4>
<p>键盘和鼠标这类的低速设备是通过中断请求的方式进行IO操作的。当键盘上按下一个按键的时候，键盘会发出一个中断信号，中断信号经过中断控制器传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，把按下的按键编码读到寄存器（或者鼠标的操作），最后放入内存中</p>
<p>这个过程可以被简化为以下几个步骤：</p>
<ol>
<li>用户通过键盘或鼠标进行操作。</li>
<li>键盘或鼠标生成中断信号。</li>
<li>中断信号被送到中断控制器。</li>
<li>中断控制器将中断信号发送到CPU。</li>
<li>CPU根据中断信号的类型，执行相应的中断处理程序。</li>
<li>中断处理程序读取键盘或鼠标的输入，并将其存储在寄存器中。</li>
<li>操作系统或应用程序使用这些信息完成相应操作。</li>
</ol>
<h4 id="2、请思考为什么我们的-CPU-处理中断异常必须是已经指定好的地址？如果你的-CPU-支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）">2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</h4>
<p>异常处理程序的地址实际上是该程序的“入口”，通过访问它可以让操作系统对中断异常进行响应，所以必须固定一个不随用户程序更改的地址，以在程序刚开始执行时就被加载到程序的特定位置；</p>
<p>如果CPU支持用户自定义入口地址，即处理中断异常的程序由用户提供，理论上是可以的。但是，这样做可能会带来一些问题：</p>
<ol>
<li><strong>安全性问题</strong>：用户提供的中断处理程序可能会包含恶意代码，这可能会导致系统崩溃或者数据泄露。</li>
<li><strong>稳定性问题</strong>：用户提供的中断处理程序可能存在bug，这可能会导致系统崩溃或者不稳定。</li>
<li><strong>兼容性问题</strong>：不同的用户可能会提供不同的中断处理程序，这可能会导致系统在不同的环境下表现不一致。</li>
</ol>
<h4 id="3、为何与外设通信需要-Bridge？">3、为何与外设通信需要 Bridge？</h4>
<p>作为程序员，内存对我们来说是透明的，所以我们将内存当作一段连续的地址空间来进行各种内存操作。而实际上，内存空间可能是由多种多样的程序由多种多样的结构组合而成的，这时就需要一个bridge将整体的地址分发到不同的程序中。这也符合“高内聚，低耦合”的原则。</p>
<h4 id="4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。">4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</h4>
<p>计时器和中断发生器是两种不同的中断模式。以下是它们的异同以及各自的状态转移图：</p>
<p><strong>计时器</strong>：</p>
<ul>
<li>计时器是一种外部设备，其主要功能是根据设定的时间来定时产生中断信号。</li>
<li>当计时器到达预设的时间，它会产生一个中断信号并发送给 CPU。</li>
<li>CPU 会响应这个中断信号，并执行相应的中断处理程序。</li>
</ul>
<p><strong>中断发生器</strong>：</p>
<ul>
<li>中断发生器是一种可以在任何时刻产生中断信号的设备。</li>
<li>当中断发生器产生一个中断信号，它会持续置高，直到微系统做出响应，才变回低位。</li>
<li>对中断发生器的响应是通过系统桥来实现的，通过 store 类指令访问地址 0x7F20，就可以达到响应中断的目的。</li>
</ul>
<p><strong>计时器状态转移图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始 -&gt; 设置时间 -&gt; 计时开始 -&gt; 时间到达 -&gt; 产生中断 -&gt; CPU 响应中断 -&gt; 结束</span><br></pre></td></tr></table></figure>
<p><strong>中断发生器状态转移图</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始 -&gt; 产生中断 -&gt; 中断信号置高 -&gt; 系统桥响应 -&gt; 中断信号置低 -&gt; 结束</span><br></pre></td></tr></table></figure>
<h4 id="5、倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU-该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？">5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</h4>
<p>这会导致存入epc寄存器的地址为0，最终使得程序无法正常返回正确中断地址；</p>
<p>空泡应保持pc信息，以保证eret正确</p>
<h4 id="6、为什么-jalr-指令为什么不能写成-jalr-31-31？">6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</h4>
<p>当执行 <code>jalr $31, $31</code> 时，由于指令的执行是顺序的，CPU 首先会将 PC+4 （返回地址）保存到 <code>$31</code>，然后再跳转到 <code>$31</code> 中的地址。但是，由于 <code>$31</code> 已经被修改，所以跳转的地址已经不再是原来 <code>$31</code> 中的地址，而是新保存的返回地址。这就导致了跳转地址和返回地址相同，形成了一个无限循环，程序无法继续执行</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>CO P0上机记录</title>
    <url>/2023/10/10/CO-P0%E4%B8%8A%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><strong>十分侥幸地通过了P0，但也暴露了许多问题，于是和几位同学讨论反思后做一些记录，希望对自己对大家能够有所裨益，为接下来的P3做一点准备~</strong></p>
<p><strong>本文中展示的方法仅为我和一些同学的做法，无法代表大多数人的思路。如大家发现错误或不严谨处，请务必不吝加以斧正！</strong></p>
<p><strong>鸣谢</strong>：朱雄伟（T1五线谱作者）</p>
<p>​			廖鹏飞（手点2^12真值表一次过）</p>
<p>​			卞卓航（狠狠学习了）</p>
<p>​			魏新明（思路打开）</p>
<hr>
<h2 id="T1：P0-L2-nonexist-2023">T1：<a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1149&amp;PieId=1120">P0_L2_nonexist_2023</a></h2>
<p>未出现的正整数  题目编号 1120-1149</p>
<h3 id="题解：">题解：</h3>
<p>这道题初看时曾经以为是算法题或者位运算题，经过思考排除了这两种可能</p>
<p>本题有两种常见的做法，<strong>直接比较</strong>（较简单）和<strong>排序判断</strong>（较繁琐）</p>
<p><s>比如我的狠人舍友，选择了排序判断（最有勇气的一集）</s></p>
<ul>
<li>
<h4 id="直接比较">直接比较</h4>
</li>
</ul>
<p>根据抽屉原理，由于无符号数只有5个，本题的<strong>最终答案只可能在1~6范围内</strong>（最关键一步），想到这一点后，电路的搭建就十分清晰了</p>
<ol>
<li>
<p>依次判断出数1~5在所给的无符号数中有没有出现</p>
<p>这部分可以使用<strong>比较器</strong>和<strong>门电路</strong>等器件方便地得出结果</p>
</li>
<li>
<p>通过组合逻辑分析或位运算等方式求出最小未出现的正整数</p>
</li>
</ol>
<p>Tips：</p>
<ol>
<li>建议将比较器的判断类型调为unsigned，和题目所给数据一致</li>
<li>题目要求输出8位二进制数，若位数不满，则需要bit extender拓展</li>
<li>记得调appearance!!记得调appearance!!记得调appearance!!</li>
</ol>
<ul>
<li>
<h4 id="排序比较">排序比较</h4>
</li>
</ul>
<blockquote>
<p>本来是没有这部分的，但出于对我舍友的尊敬，经过他本人同意，将他的做法展示于此</p>
</blockquote>
<ol>
<li>
<p>将5个数进行冒泡排序</p>
<p>在之前的学习中，大家学习了多个数进行排序输出的方法，本题也可以如此操作：先抽象出一个两个数间排序的模块，再按照冒泡排序的方法对5个数排序</p>
</li>
<li>
<p>判断哪两个数之间存在没有出现的正整数</p>
<p>将排序好的五个数两两间做差（第一个数和0做差），若某个差大于1，则说明在这两个数之间有没有出现的正整数</p>
</li>
<li>
<p>输出所求正整数</p>
<p>通过组合逻辑得到差值大于1的两个数中最小的一对，答案即为较小数+1，可以使用MUX来简化电路</p>
</li>
</ol>
<hr>
<h2 id="T2：P0-L3-walker-2023">T2：<a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1158&amp;PieId=1120">P0_L3_walker_2023</a></h2>
<p>回字楼游走 题目编号 1120-1158</p>
<h3 id="题解：-2">题解：</h3>
<p>题目十分类似课下的<a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=393&amp;PieId=1119">navigation</a>题，画出状态转换图、列出真值表、搭建标准电路，就能够解决（留了个超链接，方便大家回顾www）</p>
<p>需要注意的地方有两点：</p>
<ol>
<li>
<p><strong>题目默认房间号为1-8</strong>，但假如直接这样子打表的话需要<strong>四位</strong>来存储房间，为了简化可以<strong>规定房间号默认减一为0-7</strong>，这样只需要<strong>三位</strong>就可以存储了，可以<strong>省下50%的打表时间</strong>（最后答案别忘了用一个mux或者加一）。</p>
<p>我下图的状态机和电路也采用了这种优化~</p>
</li>
<li>
<p>记得调appearance!!记得调appearance!!记得调appearance!!</p>
</li>
</ol>
<hr>
<h2 id="T3：-十六进制数匹配">T3： 十六进制数匹配</h2>
<h3 id="题意：">题意：</h3>
<p>串行输入一个4位数，根据之前输入的三个4位数按要求输出：</p>
<ul>
<li>若三个数为A0E，输出01</li>
<li>若三个数为EEE，输出10</li>
<li>若三个数为0A0，输出11</li>
<li>若都不满足，输出00</li>
</ul>
<p>因为题目有些忘了，输出的数据可能顺序不对，请大家谅解www</p>
<h3 id="题解：-3">题解：</h3>
<ul>
<li>
<h4 id="法一">法一</h4>
</li>
</ul>
<p>整体思想为通过寄存器来维护之前读入的三个4位数（状态），每个周期通过组合逻辑判断输出，形成一个样子不是很标准的状态机</p>
<ol>
<li>
<p>使用三个寄存器维护状态</p>
<p>每次状态转移时都进行如下操作：<br>
$$<br>
in\rightarrow reg1\rightarrow reg2\rightarrow reg3<br>
$$<br>
（类比移位寄存器，但每次移4位）</p>
<p><strong>注意</strong>：这部分也可以使用一个12位寄存器或者RAM来解决</p>
</li>
<li>
<p>使用组合逻辑分析判断答案</p>
<p>创建三个模块cirA0E,curEEE,cur0A0，分别判断是否满足A0E,EEE,0A0的条件（满足输出1，不满足输出0），最后哪个亮了输出哪个</p>
</li>
<li>
<p>添加counter</p>
<p>上面的电路虽然看起来完善了，但是提交后并不能够通过</p>
<p>注意到题面中有一个要求的序列为0A0，当我们reset后输入A0时，尽管只输入了两个数，但是由于reg3此时也恰好为0，电路会错误地输出11</p>
<p>解决方法是在最后部分添加一个counter，并设置为stay at value，只有当计数到3时，电路才会有输出（这部分可以使用MUX或组合逻辑）</p>
</li>
<li>
<p>消除毛刺</p>
<blockquote>
<p>这是本场考试我花时间最多的地方aaa~</p>
</blockquote>
<p><strong>（一些用其它方法实现的同学可以跳过此步）</strong></p>
<p>上面的电路虽然看起来完善了，但是提交后并不能够通过（似曾相识www）</p>
<p>原因是：我的<strong>reset接在了counter上，这样就可以将counter异步复位的同时将输出清零</strong>，想法是好的，但是这样的<strong>组合逻辑清零方式会导致毛刺的出现</strong>，使清零有一个很小的延迟，<strong>让oj认为电路没有正确清零</strong></p>
<p>解决方法：让reset清零时会将输出也清零</p>
</li>
</ol>
<p>​		<strong>提交 通过！</strong></p>
<p>不得不说，从这道题中我确实体会到了很多思想，有所长进www</p>
<ul>
<li>
<h4 id="法二">法二</h4>
<p>这是另一位佬的做法：</p>
<ol>
<li>这个题可以2位控制输入，4位控制状态，然后通过多路选择器确定输入与原状态</li>
</ol>
<table>
<thead>
<tr>
<th>输入</th>
<th>A O E X(X代表无效字符)</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>00</td>
</tr>
<tr>
<td>A</td>
<td>01</td>
</tr>
<tr>
<td>0</td>
<td>10</td>
</tr>
<tr>
<td>E</td>
<td>11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>状态</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>0000</td>
</tr>
<tr>
<td>A</td>
<td>0001</td>
</tr>
<tr>
<td>0</td>
<td>0010</td>
</tr>
<tr>
<td>E</td>
<td>0011</td>
</tr>
<tr>
<td>A0</td>
<td>0100</td>
</tr>
<tr>
<td>0A</td>
<td>0101</td>
</tr>
<tr>
<td>EE</td>
<td>0110</td>
</tr>
<tr>
<td>A0E</td>
<td>0111</td>
</tr>
<tr>
<td>0A0</td>
<td>1000</td>
</tr>
<tr>
<td>EEE</td>
<td>1001</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>模拟出所有state0情况下，面对不同输入的new state</p>
<p>右上的小寄存器需要9个，每个对应一种state0（这里只画了state0=0000的情况）， 4路对应4种In</p>
</li>
<li>
<p>根据state打表得到输出</p>
</li>
</ol>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>CO pre上机记录</title>
    <url>/2023/09/25/CO-pre%E4%B8%8A%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>之前打noip的时候经常看别人的心路历程，现在终于轮到我写了~~(bushi)~~</p>
<hr>
<h3 id="T1-MIPS">T1:MIPS</h3>
<p>题意：初始海拔为0，输入n个相对海拔(即h[i]-h[i-1])，求最高海拔</p>
<p>水题，5min写完</p>
<hr>
<h3 id="T2-Verilog">T2:Verilog</h3>
<p>题意：输入16位data，每四位当作一个数字，若数字不下降则输出1，否则输出0</p>
<p>水题，5min写完</p>
<p>但暴露了很多问题，比如忘了类似always的其它东西的用法，比如忘了verilog里面for循环怎么写，说实话很慌</p>
<hr>
<h3 id="T3-Logism">T3:Logism</h3>
<p>题意：很基本的状态机。串行输入8位独热码，分情形有三种不同输出</p>
<p>本来应该是水题的，但是因为🐭🐭没注意appearance，导致挂了一次,写了40min</p>
<hr>
<p>总结：据说P5之后才是真CO，现在有一个好的开始，希望保持吧</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>CO-P2上机记录</title>
    <url>/2023/10/23/CO-P2%E4%B8%8A%E6%9C%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>在十分紧张的情况下幸运完成了P2，于是结合考试中做的一些笔记与大家略微分享我的思路</p>
<p>由于大家编写MIPS代码时主要以翻译为主，且选择工具链不一（指各种语言），所以本文将只展示思路，以伪代码形式呈现，并将我遇到的MIPS难点单独列出</p>
<p><s>和《算法设计与分析》考试是笔试一个道理www</s></p>
<hr>
<h2 id="T1：P2-L2-merorder-2023"><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1141&amp;PieId=1122">T1：P2_L2_merorder_2023</a></h2>
<h3 id="Main-Idea">Main Idea</h3>
<p>由于两个序列均为已经排好序的不下降数组，所以在编写程序时只需要遍历两个数组一遍，将较小者逐一合入新数组即可</p>
<h3 id="Pseudo-Code">Pseudo Code</h3>
<p>输入：两个长度分别为m，n的不下降数组a[] b[]</p>
<p>输出：一个长度为(m+n)的数组ans[]，为所求合并后的数组<br>
$$<br>
\begin{aligned}<br>
&amp;i\leftarrow 0;\<br>
&amp;j\leftarrow 0;\<br>
&amp;while\ (i&lt;n\ &amp;&amp;\ j&lt;m)\ do\<br>
&amp;\quad while\ (A[i]&lt;=B[j])\ do\<br>
&amp;\qquad print\ (A[i++]);\<br>
&amp;\quad end\<br>
&amp;\quad while\ (A[i]&gt;B[j])\ do\<br>
&amp;\qquad print\ (B[j++]);\<br>
&amp;\quad end\<br>
&amp;end\<br>
&amp;while\ (i&lt;n)\ do\<br>
&amp;\quad print(A[i++]);\<br>
&amp;end\<br>
&amp;while\ (j&lt;m)\ do\<br>
&amp;\quad print(B[j++]);\<br>
&amp;end\<br>
\end{aligned}<br>
$$<br>
复杂度分析：i和j需要遍历完两个数组一遍，所以复杂度为O(n+m)</p>
<h3 id="注意点：">注意点：</h3>
<ol>
<li>
<p>这种写法由于是while套while，会导致lable上增加难度，建议提前在代码中为不同的while注释不同的名字，方便程序写作，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;</span><br><span class="line"><span class="comment">//while1</span></span><br><span class="line">    <span class="keyword">while</span>()<span class="comment">/*do something*/</span>;</span><br><span class="line">    <span class="comment">//while2</span></span><br><span class="line">    <span class="keyword">while</span>()<span class="comment">/*do something*/</span>;</span><br><span class="line">	<span class="comment">//while3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>()<span class="comment">/*do something*/</span>;</span><br><span class="line"><span class="comment">//while4</span></span><br><span class="line"><span class="keyword">while</span>()<span class="comment">/*do something*/</span>;</span><br><span class="line"><span class="comment">//while5</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在实际写作中，因为不考虑效率要求，也可以将内层循环中的while改为if，设置标签时会更简单一些</p>
</li>
<li>
<p>本题数据范围较小，所以也可以使用类似计数排序的方法，期望复杂度和遍历两个数组一致</p>
</li>
<li>
<p>说出来给大家乐呵一下，在下<code>.space</code>忘乘4了，de了好一会儿🙏</p>
</li>
</ol>
<hr>
<h2 id="T2：P2-L1-asteroids-2023"><a href="http://cscore.buaa.edu.cn/#/problem?ProblemId=1162&amp;PieId=1122">T2：P2_L1_asteroids_2023</a></h2>
<p>题目编号 1122-1162</p>
<p>本题的代码已经给出来啦~而且方法很巧妙，对着翻译就好！</p>
<p><s>甚至可以不看题面</s></p>
<p>没有想到可以补充的地方，过~</p>
<hr>
<h2 id="T3：LeetCode-390-消除游戏"><a href="https://leetcode.cn/problems/elimination-game">T3：LeetCode: 390. 消除游戏</a></h2>
<p>为大家找到了代码的提交入口（误）</p>
<p>除用标程的递归外（标程的参数可以减少至一个），本题也可以使用位运算完成</p>
<h3 id="Main-Idea-2">Main Idea</h3>
<p>将这n个数标记为0…n-1</p>
<p>若当前为奇数轮，则删除操作为从0开始，隔一个删除一个，可以等效为“删除所有二进制末尾为0的数字“，答案当前位的二进制赋1</p>
<p>若当前为偶数轮，则删除操作为从最后一个数开始，隔一个删除一个，可以等效为”删除所有二进制下末尾数与最大数末位数相同的数字“，答案当前位的二进制赋最大数末位数的反</p>
<p>换种说法，就是：<br>
$$<br>
(ans)_2[i]=\left{<br>
\begin{aligned}<br>
&amp;1&amp;i\equiv 0(mod\ 2)\<br>
&amp;(n)_2[i]&amp;i\equiv 1(mod\ 2)\<br>
\end{aligned}<br>
\right.<br>
$$<br>
注意，在上式中：</p>
<ol>
<li>
<p>i代表的是二进制第i位，奇数轮的i为偶数，偶数轮的i为奇数</p>
</li>
<li>
<p>编号从0开始，所以<br>
$$<br>
(n)_2[i]==\sim (n-1)_2[i]<br>
$$</p>
</li>
</ol>
<p>我们的编号是从0开始的，最后别忘了将答案加一</p>
<h3 id="Pseudo-Code1">Pseudo Code1</h3>
<p>$$<br>
\begin{aligned}<br>
&amp;ans\leftarrow 0;\<br>
&amp;for\ i\ from\ 0\ to\ \log(n)-1\ do\<br>
&amp;\quad if\ (i&amp;1)\ then\<br>
&amp;\qquad ans\leftarrow ans\ |\ (2^i\ &amp;\ n);\<br>
&amp;\quad else\<br>
&amp;\qquad ans\leftarrow ans\ |\ 2^i;\<br>
&amp;\quad endif\<br>
&amp;end\<br>
&amp;ans\leftarrow ans+1;\<br>
&amp;print(ans);<br>
\end{aligned}<br>
$$</p>
<p>复杂度分析：i从0循环到logn-1，整体复杂度为O(log)</p>
<h3 id="Pseudo-Code2">Pseudo Code2</h3>
<p>或者我们换一种实现方法，将for循环拆开<br>
$$<br>
\begin{aligned}<br>
&amp;mod\leftarrow 2^{[\log(n)]};\<br>
&amp;ans\leftarrow (n\ |\ 1431655765);\<br>
&amp;ans\leftarrow ans\mod mod;\<br>
&amp;ans\leftarrow ans+1;\<br>
&amp;print(ans);\<br>
\end{aligned}<br>
$$<br>
其中：</p>
<ul>
<li>
<p>mod为n二进制下最高位1对应的数</p>
</li>
<li>
<p>$$<br>
1431655765=2^0+2^2+…2^{2k}<br>
$$</p>
</li>
</ul>
<p><strong>复杂度分析：O(1)</strong></p>
<p>(家人们谁懂啊 把nlog的朴素方法优化到O(1)，真的是一件很酷的事~)</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言系统级编程</title>
    <url>/2024/09/03/C%E8%AF%AD%E8%A8%80%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1>C语言系统级编程</h1>
<blockquote>
<p>荣老师太帅了aaaa！！（成熟男人的魅力谁懂😭）</p>
</blockquote>
<h2 id="为什么开这门课？">为什么开这门课？</h2>
<p><strong>”基础不牢，地动山摇“</strong></p>
<h3 id="这门课的目标">这门课的目标</h3>
<p>能够自己理解<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3096.pdf">C语言标准</a>中的内容</p>
<ol>
<li>属于规则的一般化</li>
<li>概念组织的系统化</li>
</ol>
<p>介绍C语言标准背后的设计思想</p>
<h3 id="引例：C语言中有没有变量（variable）">引例：C语言中有没有变量（variable）</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//芝士什么？ 变量</span></span><br><span class="line"><span class="type">const</span> inst b = <span class="number">0</span>; <span class="comment">//芝士什么？ 常量？？ 常量也是变量？？？</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> c = <span class="number">0</span>; <span class="comment">//芝士什么？ （无法解释）</span></span><br></pre></td></tr></table></figure>
<h3 id="引例2：常量-vs-常量表达式">引例2：常量 vs. 常量表达式</h3>
<table>
<thead>
<tr>
<th>形式</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>整数常量</td>
</tr>
<tr>
<td>+10</td>
<td>常量表达式</td>
</tr>
</tbody>
</table>
<h3 id="现有学习资料和标准的概念体系有一定差异">现有学习资料和标准的概念体系有一定差异</h3>
<ol>
<li>核心概念介绍缺失<br>
对象、lvalue、rvalue等核心概念介绍不详细或者不涉及</li>
<li>部分概念混淆有误<br>
变量、常量的划分方法，常量和常量表达式的混淆等</li>
<li>存在许多自创概念<br>
常变量、只读变量、行指针、列指针、数组指针、指针数组、多级指针、模拟引用传递</li>
</ol>
<h3 id="标准一般化为什么重要？">标准一般化为什么重要？</h3>
<p>都是语法糖，没有意义？会用就行了？</p>
<p>如果使用变量术语，只有<code>int a = 0;</code>是变量，其它定义均不知所谓<br>
实际上，它们都是“变量标识符”</p>
<p><strong>标准中的逻辑规则强调的就是一般化</strong></p>
<h3 id="一般化的基础：以对象为核心构建概念体系">一般化的基础：以对象为核心构建概念体系</h3>
<ol>
<li>对象的基本概念（对象的各种属性）</li>
<li>如何分配一个对象（4种分配方式）</li>
<li>如何定位一个对象（17类表达式）</li>
<li>如何获得lvalue和non-lvalue表达式的相关信息</li>
<li>如何释放对象占用的内存</li>
</ol>
<h2 id="本课程内容简介">本课程内容简介</h2>
<h3 id="C语言知识类别">C语言知识类别</h3>
<ol>
<li>语法类知识</li>
<li><strong>概念类知识</strong></li>
<li>策略类知识</li>
</ol>
<h3 id="学习周期和考核方法">学习周期和考核方法</h3>
<p>学习时长1-9周（16学时，1学分）</p>
<p>考核方法：考试（开卷，带什么资料都行）+随堂测验（上课的时候带张草稿纸）</p>
<hr>
<p>（正片开始）</p>
<h2 id="内存基本概念简单回顾">内存基本概念简单回顾</h2>
<h3 id="1byte-8bits？">1byte=8bits？</h3>
<p>&lt;limits.h&gt;定义了一个宏CHAR_BIT</p>
<p>C语言规定一个byte等于CHAR_BIT个bit</p>
<p>CHAR_BIT的限制是&gt;=8（即不一定是8位）</p>
<p>地址是字节在内存中的编号，只有字节才有地址</p>
<h2 id="C语言最重要的概念：对象">C语言最重要的概念：对象</h2>
<blockquote>
<ol>
<li>对象的概念</li>
<li>如何刻画对象的属性</li>
<li>理解对象该类别</li>
<li>理解指针和数组也是一种普通的对象类型</li>
</ol>
</blockquote>
<h3 id="对象表示（Object-Representation）">对象表示（Object Representation）</h3>
<ul>
<li>一个对象各个bit组成的二进制串就是这个对象的<strong>对象表示</strong></li>
<li>对象表示$\leftarrow$对象类型$\rightarrow$对象的值</li>
</ul>
<h3 id="对象表示-vs-对象的值">对象表示 vs. 对象的值</h3>
<ul>
<li>对象表示一样，对象的值一定一样</li>
<li>对象的值一样，对象表示<strong>不一定</strong>一样</li>
</ul>
<h3 id="对象类型T">对象类型T</h3>
<p>C语言任何一个对象类型都可以形式化定义为一个T</p>
<ul>
<li>sizeof(T)<br>
规定了任何一个对象包含的字节个数，n为size，sizeof(T)=n * CHAR_BIT</li>
<li>alignof(T)<br>
对象地址（Address）：对象所占用的连续字节中lowest字节的编号<br>
对齐要求（Alignment）：要求对象的地址能被对齐要求整除</li>
</ul>
<p>所有的算数类型和指针类型统称为标量类型，<strong>只有标量类型支持加减操作</strong></p>
<h3 id="对象分类——算术类型（Arithmetic-Type）">对象分类——算术类型（Arithmetic Type）</h3>
<p>C23正式增加bool类型</p>
<p>算术类型都是完全对象类型（即size确定）</p>
<p>char、signed char、unsigned char是三种不同的类型，编译器会指定char和另外两种中的一个表现相同</p>
<ul>
<li>标准有符号整数类型对象</li>
</ul>
<p>1个sign bit 若干value bit 若干padding bit</p>
<p>signed char、signed short int、signed int、signed long int、signed long long int</p>
<ul>
<li>标准无符号整数类型对象</li>
</ul>
<p>若干value bit 若干padding bit</p>
<p>unsigned char、unsigned short int、unsigned int、unsigned long int、unsigned long long int、unsigned bool</p>
<h4 id="typedef">typedef</h4>
<p>tepedef是一个能够为类型设置别名的关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T alias</span><br></pre></td></tr></table></figure>
<p>typedef可以提高系统移植能力</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ImplementationA</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">int</span> INT32;</span><br><span class="line"><span class="meta">#<span class="keyword">elifdef</span> ImplementationB</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">int</span> INT16;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T alias; <span class="comment">//非数组非指针</span></span><br><span class="line"><span class="keyword">typedef</span> T Alias[N]; <span class="comment">//数组类型</span></span><br><span class="line"><span class="keyword">typedef</span> T* Alias; <span class="comment">//指针类型</span></span><br></pre></td></tr></table></figure>
<h4 id="对齐要求">对齐要求</h4>
<p>对象对齐要求一定是$2^n$</p>
<p>n越小越weak，越大约strong</p>
<h4 id="枚举类型">枚举类型</h4>
<ol>
<li>
<p>在枚举定义时指定类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不指定类型，自动指定为char、标准有符号类型、标准无符号类型、扩展有符号证书类型、扩展无符号整数类型的一种</p>
</li>
</ol>
<h3 id="对象分类——派生类型（Derived-Type）">对象分类——派生类型（Derived Type）</h3>
<blockquote>
<p>重点介绍数组类型和指针类型</p>
</blockquote>
<h4 id="数组类型">数组类型</h4>
<p>形式化定义：T[N]</p>
<ul>
<li>T：元素类型，必须是完全对象类型</li>
<li>N：元素类型的个数</li>
</ul>
<p>N为表达式：</p>
<ol>
<li>无N，不完全对象类型</li>
<li>有N，N为整数常量或整数常量表达式，普通数组类型</li>
<li>有N，不为整数常量或整数常量表达式，变长数组类型</li>
</ol>
<p>数组类型也是一个合法的对象类型，有大小和对齐要求</p>
<h4 id="typeof">typeof</h4>
<p>数组类型可以视为一个整体，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> AINT[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>由于写法过于恶臭（确实），C23提供了一个关键字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">typeof</span><span class="params">(<span class="type">int</span>[<span class="number">5</span>])</span> AINT;</span><br><span class="line"><span class="comment">// typeof T Alias;</span></span><br></pre></td></tr></table></figure>
<h4 id="从数组类型T继续派生">从数组类型T继续派生</h4>
<p>由于数组类型也为<strong>完全对象类型</strong>，所以仍可继续派生</p>
<p>于是出现了二维数组！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> AINT[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">typedef</span> AINT AAINT[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line">AAINT a;</span><br></pre></td></tr></table></figure>
<p><strong>数组都是“一维”的</strong></p>
<h4 id="指针类型">指针类型</h4>
<p>形式化定义：T*</p>
<ul>
<li>T：Referenced Type：对象类型或函数类型</li>
<li>*：指针类型标志</li>
</ul>
<p>T*为从T派生的类型</p>
<p>注意：T包括完全函数类型，也包括不完全对象类型，还包括函数类型</p>
<p>指针类型是<strong>完全对象类型</strong></p>
<p>sizeof(T*)</p>
<p>alignof(T*)</p>
<h4 id="指针类型再派生">指针类型再派生</h4>
<p>指针类型也能用于构造数组类型，指针类型也有自己的指针类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>派生数组</th>
<th>派生指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>T</td>
<td>T[N]</td>
<td>T*</td>
</tr>
<tr>
<td>T[M]</td>
<td>T[N][M]</td>
<td>T(*)[M]</td>
</tr>
<tr>
<td>T*</td>
<td>T*[N]</td>
<td>T**</td>
</tr>
</tbody>
</table>
<p>你已经学会了，现在为<code>int*(**[])[4][5]</code>派生指针类型吧<br>
答案：<code>int*(**(*)[])[4][5]</code></p>
<h3 id="限定类型-限定符（Qualifier）">限定类型/限定符（Qualifier）</h3>
<h4 id="const-volatile-restrict">const volatile restrict</h4>
<p>若T为类型，Q为限定符。当T为一个整体的时候，限定符在T的左边右边都一样（T Q = Q T）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Q T = T Q //非数组非指针</span><br><span class="line">Q T[N] //数组类型，元素类型Q T</span><br><span class="line">T[N] Q //不合法</span><br><span class="line">Q T*//类型为Q T</span><br><span class="line">T* Q //Q限制T*类别 &lt;-------推荐的</span><br></pre></td></tr></table></figure>
<h4 id="理解const-int-const">理解<code>const int* const</code></h4>
<ol>
<li>
<p><code>const int</code>，限定类型，限定int</p>
</li>
<li>
<p><code>const int*</code>，指针类型，Referenced Type为const int</p>
</li>
<li>
<p><code>const int* const</code>，限定类型，限定const int*</p>
</li>
</ol>
<p>Q typeof(T[N]) = Q typeof(T)[N]</p>
<ul>
<li>多个不同限定符限定同一个类型等价</li>
<li>多个同样限定符限定同一个类型等价于一个</li>
</ul>
<h2 id="认识对象的属性">认识对象的属性</h2>
<p>{A, Obj_T, N, S, V, V_T, Align}</p>
<ul>
<li>对象名称 T<br>
有名称的对象被称为具名对象(Named Object)</li>
<li>大小 Size<br>
sizeof(T)</li>
<li>地址<br>
最低位地址</li>
<li>对齐要求<br>
对齐要求：alignof(T)</li>
<li>对象值和对象表示<br>
之前讲过了喵（善用<code>ctrl+f</code>）</li>
<li>表示值 Value</li>
<li>表示类型 Value Type</li>
</ul>
<p><strong>&lt;表示值，表示值类型&gt;</strong></p>
<p>非数组对象类型：&lt;object value，typeof_unqual(object Type)&gt;</p>
<p>数组对象类型：&lt;第一个元素对象的地址，元素类型对应的指针类型&gt;</p>
<h2 id="分配对象：通过对象声明">分配对象：通过对象声明</h2>
<h3 id="分配对象的方法">分配对象的方法</h3>
<blockquote>
<p>rwg：建议一次只声明一个对象🤓</p>
</blockquote>
<h4 id="对象声明">对象声明</h4>
<ul>
<li>基本形式：<code>T O = initalizer;</code></li>
<li>T应当看作一个整体，即typeof(T)</li>
<li><code>int(*d)[10]; = typeof(int(*)[10]) d;</code></li>
</ul>
<h4 id="String-Literal">String Literal</h4>
<p>String Literal是由<strong>编码前缀</strong>和<strong>双引号引导的字符序列</strong>构成的</p>
<p>编码前缀包括：</p>
<table>
<thead>
<tr>
<th>编码前缀</th>
<th>字符类型</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>无编码</td>
<td>\</td>
<td>\</td>
</tr>
<tr>
<td>u8</td>
<td>char8_t</td>
<td>UTF-8</td>
</tr>
<tr>
<td>u</td>
<td>char16_t</td>
<td>UTF-16</td>
</tr>
<tr>
<td>U</td>
<td>char32_t</td>
<td>UTF-32</td>
</tr>
<tr>
<td>L</td>
<td>wchar_t</td>
<td>实现定义</td>
</tr>
</tbody>
</table>
<p>字符序列中的字符包括：</p>
<ol>
<li>所有char，除了&quot; \ 实际的回车</li>
<li>\引导的转义字符</li>
</ol>
<p>步骤（以初始化“hello”为例）：</p>
<ol>
<li>在内存中分配一个大小合适的char类型数组对象</li>
<li>用’h’,‘e’,‘l’,‘l’,‘o’,'\0’初始化数组的每一个元素</li>
<li>该对象为匿名对象</li>
<li>当第二次初始化“hello”时，不一定需要分配一个新的地址空间（如&quot;hello&quot;和L&quot;hello&quot;）</li>
</ol>
<p>String Literal vs. String</p>
<p>双引号内不包含&quot;\0&quot;的String Literal叫做String，String Literal包含String</p>
<h4 id="Compound-Literal">Compound Literal</h4>
<h4 id="内存管理函数">内存管理函数</h4>
<p>malloc</p>
<ol>
<li>分配一个匿名对象，该对象<strong>无对象类型</strong></li>
<li>大小为size</li>
<li>对象表示为indeterminate</li>
<li>返回值为空指针（未成功）或者这个对象的首地址</li>
<li>该对象的Storage Duration是allocated</li>
<li>对齐要求为Fundamental Alignment，保证了返回的void*指针可以强转成任意类型</li>
</ol>
<h4 id="initalizier">initalizier</h4>
<p>初始化对象的<strong>对象表示</strong></p>
<p>标量类型initiallizer形式：</p>
<ul>
<li>{}，空初始化列表
<ul>
<li>将对象的值设置为该类型的缺省值</li>
</ul>
</li>
<li>除逗号表达式之外的任意表达式epx或{exp}</li>
</ul>
<p>数组类型initiallizer形式：</p>
<ul>
<li>{}，空初始化列表
<ul>
<li>将对象的值递归设置为该类型的缺省值</li>
</ul>
</li>
<li>{sub-initalizer1，…}
<ul>
<li>设置前n个对象，剩下设置为缺省值</li>
</ul>
</li>
</ul>
<p>当对<strong>变长数组</strong>初始化时，只能使用{}进行初始化</p>
<p>没有initializer时，对象值初始化为indeterminate representation（不确定值）</p>
<p>对象值、对象表示一一对应</p>
<h2 id="表达式">表达式</h2>
<blockquote>
<p>C语言中，定位一个对象，只能通过lvalue（locate value）</p>
</blockquote>
<ul>
<li>表达式（Exp）由一些列符号和操作数组成</li>
<li>共有17种表达式</li>
</ul>
<h3 id="Evaluation-of-Expression">Evaluation of Expression</h3>
<ul>
<li>Evaluate的过程包括
<ol>
<li>Value Computation（计算值）</li>
<li>Initiation of Side Effect（确定副作用）</li>
</ol>
</li>
<li>Value Computation得到表达式的rvalue，包含值和类型</li>
</ul>
<h3 id="基础表达式（Primary-Expression）">基础表达式（Primary Expression）</h3>
<h4 id="标识符：包括对象标识符和函数标识符">标识符：包括对象标识符和函数标识符</h4>
<ul>
<li>对象声明 T O = Initializer，其中O就是对象标识符</li>
<li>对象标识符是合法的lvalue</li>
<li>Value Computation：非数组——对象值，数组——第一个元素首地址</li>
<li>Side Effect：无</li>
</ul>
<h4 id="常量">常量</h4>
<ul>
<li>
<p>非左值，无法定位对象</p>
</li>
<li>
<p>整数常量、浮点数常量、枚举常量、字符常量、预定义常量</p>
</li>
<li>
<p>整数常量：进制前缀+数字序列+类型后缀</p>
<ul>
<li>
<p>前缀</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0b/0B</td>
<td>二进制</td>
</tr>
<tr>
<td>无</td>
<td>十进制</td>
</tr>
<tr>
<td>0</td>
<td>八进制</td>
</tr>
<tr>
<td>0x/0X</td>
<td>十六进制</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>后缀（重点）</strong></p>
<blockquote>
<p>敲不动了，放个图</p>
</blockquote>
<p>从上至下为类型匹配顺序<br>
不考虑BitInt系列，整数常量的类型，最小是int（涉及到整型提升的概念）</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240924163425852.png" alt=""></p>
</li>
<li>
<p>数字分隔符不能出现在第一个数字前，不能出现在最后一个数字后</p>
</li>
</ul>
</li>
<li>
<p>浮点数常量：进制前缀+符号序列+后缀</p>
<ul>
<li>十进制符号序列形式：1.1e-3
<ul>
<li>科学计数部分不一定有</li>
</ul>
</li>
<li>十六进制符号序列形式：0x100.5p2
<ul>
<li>幂的底数为2，指数部分为十进制</li>
</ul>
</li>
</ul>
</li>
<li>
<p>枚举常量，比较简单</p>
</li>
<li>
<p>字符常量：编码前缀+单引号引导的有效字符</p>
<ul>
<li>
<p>前缀<br>
当没有给定前缀时，系统会默认类型，所以中文字符在一些系统会变成乱码</p>
<table>
<thead>
<tr>
<th>字符常量</th>
<th>rvalue类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>‘a’</td>
<td><strong>int</strong></td>
</tr>
<tr>
<td>u8’a’</td>
<td>char8_t</td>
</tr>
<tr>
<td>u’a’</td>
<td>char16_t</td>
</tr>
<tr>
<td>U’a’</td>
<td>char32_t</td>
</tr>
<tr>
<td>L’a’</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>有效字符</p>
<ul>
<li>基本源代码字符集</li>
<li>基本执行字符集</li>
<li>扩展源代码字符集、扩展执行字符集</li>
</ul>
</li>
<li>
<p>‘\x31’ ：以十六进制整数表示的字符，十进制值是49，依然是字符’1’</p>
</li>
</ul>
</li>
<li>
<p>预定义常量：false、true、nullptr</p>
<ul>
<li>false和true分别为0和1，rvalue类型为bool</li>
<li>nullptr是一个空指针类型，rvalue类型为在&lt;stddef.h&gt;中定义的nullptr_t类型</li>
</ul>
</li>
</ul>
<h4 id="字符串">字符串</h4>
<p>字符串不是常量</p>
<ul>
<li>字符串可以用来分配（或重用）一个对象</li>
<li>同时，字符串是一个lvalue，能够定位分配出来（或重用）的那个对象</li>
</ul>
<p>字符串分配（或重用）的对象类型是字符数组类型</p>
<p>如果lvalue定位的对象是一个数组类型对象，则lvalue表达式Evaluate之后的rvalue就是该对象第一个元素的首地址，rvalue类型是元素对象类型对应的指针类型</p>
<h4 id="括号表达式">括号表达式</h4>
<p>evaluate的优先级最高，rvalue和类型等于括号内表达式的值</p>
<h3 id="后缀表达式">后缀表达式</h3>
<p>给定一个表达式exp，与后缀操作符结合构成的仍然是一个表达式</p>
<p>后缀操作符：[]、.、-&gt;、++/–、(type-name){Initializer-list}、()</p>
<h3 id="一元表达式">一元表达式</h3>
<p>给定一个表达式exp，与一元操作符结构构成的仍然是一个表达式</p>
<p>一元操作符：++/–、&amp;、*、+/-、~/!、sizeof、_Alignof</p>
<h2 id="evaluate">evaluate</h2>
<h3 id="定位非数组对象lvalue的evaluate">定位非数组对象lvalue的evaluate</h3>
<p>对形如如下形式的lvalue不做evaluate，表达式整体evaluate由特殊规则确定</p>
<ul>
<li>sizeof(a)，编译时确定</li>
<li>typeof(a)，编译时确定</li>
<li>&amp;a，在main外时称为<strong>地址常量表达式</strong></li>
<li>a++/a–，rvalue为a的rvalue加1或减1，同时将a的value改变（有副作用，可能两个不同时发生）</li>
<li>++a/–a，rvalue为a的rvalue加1或减1，同时将a的value改变（有副作用，可能两个不同时发生）</li>
<li>a=2，rvalue为等号右边表达式的rvalue，同时将左值的value改变（有副作用，可能两个不同时发生）</li>
</ul>
<p>常量不可修改的原因是左值为<strong>不可修改左值</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>c++&amp;c#</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre Lec3-如何管理对象</title>
    <url>/2023/09/20/OOpre%20Lec3-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>开个坑，更新OOpre(简称op)的学习内容<br>
<s>原神，启动！</s><br>
<s>（别问为什么没有前两周的内容，问就是传错仓库没了）</s></p>
<p>在这里放个佬的文章orz orz <a href="https://swkfk.top/books/oopre/lecture_1.html">Lec1</a> <a href="https://swkfk.top/books/oopre/lecture_2.html">Lec2</a> （但他应该不知道我看到了）</p>
<hr>
<h1>Lec3-如何管理对象</h1>
<h2 id="对象与引用">对象与引用</h2>
<ul>
<li>
<p>对象是程序通过new产生的实例，引用是程序中声明的变量</p>
</li>
<li>
<h5 id="对象究竟是什么"><strong>对象</strong>究竟是什么</h5>
<ul>
<li>对象是对内存的一个区域</li>
<li>对象包含属性数据和指向类的指针</li>
</ul>
</li>
</ul>
<p>​		这部分内容参考c++&amp;c#</p>
<ul>
<li>
<h5 id="引用究竟是是什么"><strong>引用</strong>究竟是是什么</h5>
<ul>
<li>
<p>对象引用指向对象的地址</p>
</li>
<li>
<p>对象引用存在null的可能性，但对象不可能</p>
<p>这句话的含义是，在编程中，你可能会有一个引用（或者说指针）指向一个对象，但是这个引用可能为null。换句话说，这个引用并不指向任何对象。当你尝试使用这个引用访问对象时，如果它是null，你的程序就会产生错误。但是，对象本身不可能为null，因为它始终存在于内存中的某个位置。</p>
<p>例如，在Java语言中，你可以创建一个对象的引用，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj;</span><br></pre></td></tr></table></figure>
<p>在这个情况下，<code>obj</code> 是一个引用，但它并没有指向任何对象。也就是说，<code>obj</code> 是null。如果你尝试调用 <code>obj</code> 的任何方法或访问其属性，程序就会抛出一个 <code>NullPointerException</code>。</p>
<p>为了解决这个问题，你需要确保在使用引用之前，它已经被初始化为一个实际的对象。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>
<p>在这个情况下，<code>obj</code> 是一个引用，并且它指向一个实际的 <code>Object</code> 对象。现在你可以安全地调用 <code>obj</code> 的方法和访问其属性，而不会抛出 <code>NullPointerException</code>。</p>
</li>
</ul>
</li>
<li>
<h5 id="Java与C的联系与区别">Java与C的联系与区别</h5>
<p>Java的对象引用相当于c中的指针变量，指向一片内存空间</p>
</li>
<li>
<h5 id="对象与引用-2">对象与引用</h5>
<ul>
<li><strong>区别</strong>
<ul>
<li>对象有实际存在的内存区域；引用是一个标识符，指向对象所在地址</li>
<li>只能通过对象引用去访问或改变对象的方法或数据</li>
</ul>
</li>
<li><strong>联系</strong>
<ul>
<li>对象引用与对象息息相关</li>
<li>一个对象可能对应多个对象引用</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="常见容器及其作用">常见容器及其作用</h2>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>HashMap</li>
<li>HashSet</li>
<li>Queue</li>
<li>Deque</li>
<li>TreeMap</li>
<li>PriorityQueue</li>
<li>…</li>
</ul>
<p>这么多容器，该如何挑选呢?</p>
<ol>
<li>
<h5 id="ArrayList-LinkedList">ArrayList &amp;&amp; LinkedList</h5>
<p><strong>逻辑特征</strong>：ArrayList——数组</p>
<p>​					LinkedList——链表</p>
<p><strong>优点</strong>：两者均可以<strong>按照顺序关系或按照下标</strong>访问对象</p>
<p><strong>缺点</strong>：查找某个对象需要遍历，<strong>查找速度比较慢</strong></p>
</li>
<li>
<h5 id="HashMap">HashMap</h5>
<p><strong>逻辑特征</strong>：基于哈希表的键值映射，可以使用键来快速查找和访问值。没有固定顺序，不允许重复的键</p>
<p><strong>优点</strong>：**快速查找（或删除）**某元素，尤其是该元素有唯一的id时</p>
<p><strong>缺点</strong>：存储<strong>无序</strong>，难以按照存储先后大小访问</p>
</li>
<li>
<h5 id="HashSet">HashSet</h5>
<p><strong>逻辑特征</strong>：基于哈希表实现的无序集合，不允许存储重复元素。常数时间的插入和查找</p>
<p><strong>优点</strong>：保持集合元素的唯一性互异性。便于<strong>自动去重</strong></p>
<p><strong>缺点</strong>：内部存储无序，与HashMap相同的问题</p>
</li>
<li>
<h5 id="Queue-Deque-TreeMap-PriorityQueue">Queue Deque TreeMap PriorityQueue</h5>
<p><strong>Queue</strong>：队列，LinkedList是其具体实现</p>
<p><strong>Deque</strong>：双向队列，java老版本的Stack已经过时，推荐使用Deque</p>
<p><strong>TreeMap</strong>：有序映射，红黑树实现，根据键值来排序，可以<strong>自定义比较器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;id, object&gt;</span><br></pre></td></tr></table></figure>
<p><strong>PriorityQueue</strong>：优先队列，基于Heap(堆)实现</p>
<hr>
</li>
</ol>
<h2 id="层次化对象管理方法">层次化对象管理方法</h2>
<p>针对不同的需求，需要建立不用类型、不同层次的容器加以进行数据的处理</p>
<p><strong>组合关系（Composition）</strong>：有多个对象组合形成一个更大对象，整体与部分存在</p>
<p><strong>聚合关系（Aggregation）</strong>：若关联关系，以对象引用作为其成员变量，向印度对象引用可以为null</p>
<p>本质上是属性识别问题</p>
<h2 id="作业内容介绍">作业内容介绍</h2>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre Lec4-输入解析的结构性设计</title>
    <url>/2023/10/08/OOpre-Lec4-%E8%BE%93%E5%85%A5%E8%A7%A3%E6%9E%90%E7%9A%84%E7%BB%93%E6%9E%84%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><s>明明应该是国庆假期的，🐭🐭却要来上op（哭）</s></p>
<hr>
<h1>Lec4-输入解析的结构性设计</h1>
<h2 id="输入序列结构的特征分析">输入序列结构的特征分析</h2>
<h4 id="为什么需要输入解析？">为什么需要输入解析？</h4>
<ul>
<li>
<p>如果用户输入的数据格式不正确获证解析出错，就会导致结果错</p>
<p>garbage in$\rightarrow$garbage out</p>
</li>
<li>
<p>方便用户交互与体验</p>
</li>
<li>
<p>便于维护</p>
</li>
</ul>
<h4 id="输入解析的步骤">输入解析的步骤</h4>
<ol>
<li>获取输入</li>
<li>提取数据</li>
<li>验证数据</li>
<li>转换为程序内部数据</li>
</ol>
<h2 id="输入序列结构到对象层次结构的映射">输入序列结构到对象层次结构的映射</h2>
<ul>
<li>
<p>输入解析</p>
<p>将输入数据从原始格式转换为程序所能处理的**数据（结构）**的过程</p>
</li>
<li>
<p>对象构造</p>
<p>将输入解析的**数据（结构）<strong>映射到</strong>对象（层次结构）**的过程</p>
<p>需要设计合适的<strong>对象模型（数据结构设计）</strong></p>
</li>
</ul>
<h2 id="正则表达式的模式结构介绍">正则表达式的模式结构介绍</h2>
<p><s>啊啊啊都一节课过去了，这个最重要的部分他怎么还没开始讲（小声）</s></p>
<h4 id="语法介绍">语法介绍</h4>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>匹配前面的模式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的模式一次或多次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前面的模式零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配前面的模式恰好 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前面的模式至少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面的模式至少 n 次且不超过 m 次</td>
</tr>
<tr>
<td>[ ]</td>
<td>匹配括号内的任意一个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>匹配除了括号内的字符以外的任意一个字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结尾</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
</tr>
<tr>
<td>( )</td>
<td>用于分组和捕获子表达式</td>
</tr>
<tr>
<td>( ?)</td>
<td>非贪婪匹配</td>
</tr>
<tr>
<td>(?: )</td>
<td>用于分组但不捕获子表达式</td>
</tr>
<tr>
<td>\</td>
<td>转义字符，用于匹配特殊字符本身</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意字符（除了换行符）</td>
</tr>
<tr>
<td>|</td>
<td>用于指定多个模式的选择</td>
</tr>
<tr>
<td>\d</td>
<td>匹配任意数字字符</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意\d不能匹配的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配任意字母数字或下划线字符</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任意\w不能匹配的字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意非空白字符</td>
</tr>
</tbody>
</table>
<h4 id="贪婪匹配">贪婪匹配</h4>
<p>正则表达式默认采用<strong>贪婪匹配</strong>——任何一个模式，都会尽可能匹配多个字符</p>
<p>在模式表达式后添加？，即代表<strong>非贪婪匹配</strong></p>
<h4 id="层次正则">层次正则</h4>
<p>如果查找元字符本身，比如查找.,或者*，就出现了问题：没法指定它们，因为被解释成其它的意思，这时必须使用\来取消这些字符的特殊意义</p>
<h2 id="作业内容">作业内容</h2>
<p>引入战斗模式和战斗日志（原神怎么你了）🤣👉🤡</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre Lec5-JAVA程序常见错误分析</title>
    <url>/2023/10/13/OOpre-Lec5-JAVA%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>难道这周是习题课？ ——wxm</p>
<hr>
<h1>Lec5-JAVA程序常见错误分析</h1>
<h2 id="推荐的层次化架构">推荐的层次化架构</h2>
<ol>
<li>Main：负责代码顶层逻辑</li>
<li>MyScanner：输入处理</li>
<li>Manager：进行指令的具体分类处理</li>
<li>FightLogEntry：战斗日志项，存战斗日志</li>
<li>Adventurer：实现冒险家的操作</li>
</ol>
<p>要追求高内聚，低耦合！各部分逻辑<strong>不胡乱参杂</strong></p>
<h2 id="各种类型错误">各种类型错误</h2>
<p>这个老师给了十几种不同的错误类型及常见的错误代码</p>
<p>不想记录了…</p>
<hr>
<p>真被wxm说中了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre Lec6-继承与接口的使用</title>
    <url>/2023/10/20/OOpre-Lec6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1>Lec6-继承与接口的使用</h1>
<hr>
<h2 id="继承及其应用">继承及其应用</h2>
<h3 id="extends">extends</h3>
<ul>
<li>子类可以访问父类的公共（public）和受保护 （protected）成员</li>
<li>私有（private）成员无法被直接被访问，但可以通过调用父类的方法来访问</li>
</ul>
<p>可以使用obj instanceof MyCLass 表达式来判断对象 obj是否为MyClass的实例化对象</p>
<h3 id="super">super</h3>
<ul>
<li>
<p>使用 super.attribute 可以 引用父类中定义的非私有属性</p>
</li>
<li>
<p>如果子类重写了父类的某个方法，那么子类通过super.methodName() 可以 调用父类所实现的那个方法</p>
<p>(this.methodName()是子类自己重写的方法)</p>
</li>
<li>
<p>一般<strong>使用 super(arguments) 来调用父类的构造方法</strong>，从而完成对父类所定义属性的初始化</p>
</li>
</ul>
<h3 id="Override">@Override</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> “XBottle<span class="string">&quot;; </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>可在子类重写父类方法时标注，非强制要求，可选</p>
<p>子类方法的<strong>方法名</strong>和<strong>参数列表</strong>必须与父类方法<strong>完全相同</strong></p>
<hr>
<h2 id="接口及其应用">接口及其应用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Myinterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span> <span class="keyword">implements</span> <span class="title class_">Myinterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod1</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Implementation of myMethod1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod2</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Implementation of myMethod2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod3</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;Implementation of myMethod3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>要求接口中的所有方法都被实现（覆写）</li>
<li>可以用a instanceof B判断对象a是否实现了接口B，即是否类型B的实例</li>
<li>若父类实现了某个接口，则子类也可以使用父类的接口方法</li>
</ul>
<hr>
<h2 id="接口和继承的区别">接口和继承的区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>数量</th>
<th>关系</th>
<th>概念本质</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td>一个类只能有一个父类</td>
<td>子类继承了父类的所有属性和方法</td>
<td>建立了数据抽象层次</td>
</tr>
<tr>
<td>接口</td>
<td>一个类可以实现多个接口</td>
<td>实现接口中所定义的全部方法</td>
<td>建立了行为抽象层次</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="作业内容与建议">作业内容与建议</h2>
<ul>
<li>仍为冒险者游戏，在第四次作业的基础上迭代开发</li>
<li>允许冒险者雇佣另一个冒险者，且赋予装备、药水瓶、食物、冒 险者价值的概念</li>
<li>细化装备和药水瓶的类型，具有不同的功效</li>
<li>建议把装备、药水瓶、食物和冒险者都看作是价值体 （commodity）</li>
<li>建议引入Commodity接口来建立行为层次关系</li>
<li>冒险者 Adventurer 类、装备 Equipment 类、药水瓶 Bottle 类、食物 Food  类实现该接口</li>
<li>装备和药水瓶的细分，建议通过继承实现</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Solitude(Acrylic)博客配置教程</title>
    <url>/2024/08/15/Hexo-Solitude(Arclicy)%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Hexo-Solitude-Acrylic-博客配置教程">Hexo-Solitude(Acrylic)博客配置教程</h2>
<blockquote>
<p>在嘈杂的互联网中寻求属于自己的一方净土，并非遥不可及…</p>
<p>也许你才刚刚踏上旅程、也许你已经踩过坑坑洼洼，但是…让我们继续出发~</p>
<p>注：Acrylic目前已经停止维护，项目文件已经不兼容许多库，建议使用Solitude</p>
</blockquote>
<h3 id="配置">配置</h3>
<ul>
<li>Windows 11</li>
<li>2024年7月</li>
<li>已经提前安装并配置好git（这部分建议搜索相关git教程）</li>
</ul>
<h4 id="技术路线">技术路线</h4>
<p>node.js + hexo + github  + solitude</p>
<h3 id="主要流程">主要流程</h3>
<ol>
<li>安装node.js</li>
<li>安装hexo</li>
</ol>
<h3 id="1-安装node-js">1 安装node.js</h3>
<h4 id="1-1-打开node-js官网，在上方选项栏选择“下载”栏目">1.1 打开<a href="https://nodejs.org/zh-cn">node.js官网</a>，在上方选项栏选择“下载”栏目</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723150847771.png" alt="1"></p>
<h4 id="1-2-选择自己需要的版本下载">1.2 选择自己需要的版本下载</h4>
<p><s>我的建议是不要选择太新的node.js，与hexo很可能不匹配，这里我选择v14.21.3</s>（也不一定）</p>
<p>不太会用命令行的同学可以点“预构建安装程序”傻瓜式下载（会用命令行的同学也推荐傻瓜式下载）</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723151249900.png" alt="2"></p>
<h4 id="1-3-打开下载好的安装程序，一键安装">1.3 打开下载好的安装程序，一键安装</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723151405702.png" alt="3"></p>
<h4 id="1-4-测试node-js安装情况">1.4 测试node.js安装情况</h4>
<p>打开命令行（win+R 输cmd），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>出现如下提示即为安装成功：</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723151723583.png" alt="4"></p>
<h3 id="2-安装hexo">2 安装hexo</h3>
<h4 id="2-1-通过镜像站安装hexo">2.1 通过镜像站安装hexo</h4>
<p><s>吐槽一句，很多这里博客会推荐大家下载cnpm，然后用cnpm下载hexo，但实际上cnpm的下载过程中往往伴随着各种出错（楽）</s></p>
<p>打开命令行（win+R 输cmd），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli -registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p>稍微解释一下，<code>-g</code>指定了安装包的名称，<code>-registry=</code>指定了远程仓库的位置（默认是海外的服务器，科学上网可以不加这个）</p>
<p><code>registry.npmmirror.com</code>是淘宝的npm镜像站，原名称是<code>registry.npm.taobao.org</code>，现在使用老网址会提示证书过期</p>
<p>如果出现以下提示即可能为安装成功：</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723153644542.png" alt="5"></p>
<h4 id="2-2-验证hexo安装">2.2 验证hexo安装</h4>
<p>打开命令行（win+R 输cmd），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>出现以下提示即为安装成功：</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723153833477.png" alt="6"></p>
<h4 id="2-3-初始化hexo">2.3 初始化hexo</h4>
<p>在你喜欢的地方（建议全英文路径），创建一个名为<code>blog</code>的文件夹，它以后就是我们的博客的主文件夹了</p>
<p>在blog文件夹中打开命令行（推荐blog文件夹地址栏输cmd，回车），输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>如果没有科学上网，很可能出现在以下地方卡住的情况：<br>
<img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723160030095.png" alt="7"></p>
<p>让我们来hexo的<a href="https://github.com/hexojs/hexo-cli/blob/master/lib/console/init.ts">源码</a>中来找找原因：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BlueBirdPromise</span> <span class="keyword">from</span> <span class="string">&#x27;bluebird&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; join, resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magenta &#125; <span class="keyword">from</span> <span class="string">&#x27;picocolors&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; existsSync, readdirSync, rmdir, unlink, copyDir, readdir, stat &#125; <span class="keyword">from</span> <span class="string">&#x27;hexo-fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> tildify <span class="keyword">from</span> <span class="string">&#x27;tildify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> spawn <span class="keyword">from</span> <span class="string">&#x27;hexo-util/dist/spawn&#x27;</span>; <span class="comment">// for rewire</span></span><br><span class="line"><span class="keyword">import</span> &#123; sync <span class="keyword">as</span> commandExistsSync &#125; <span class="keyword">from</span> <span class="string">&#x27;command-exists&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> <span class="title class_">Context</span> <span class="keyword">from</span> <span class="string">&#x27;../context&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ASSET_DIR</span> = <span class="title function_">join</span>(__dirname, <span class="string">&#x27;../../assets&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">GIT_REPO_URL</span> = <span class="string">&#x27;https://github.com/hexojs/hexo-starter.git&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InitArgs</span> &#123;</span><br><span class="line">  <span class="attr">_</span>: <span class="built_in">string</span>[];</span><br><span class="line">  install?: <span class="built_in">boolean</span>;</span><br><span class="line">  clone?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">initConsole</span>(<span class="params"><span class="attr">this</span>: <span class="title class_">Context</span>, <span class="attr">args</span>: <span class="title class_">InitArgs</span></span>) &#123;</span><br><span class="line">  args = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123; <span class="attr">install</span>: <span class="literal">true</span>, <span class="attr">clone</span>: <span class="literal">true</span> &#125;, args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseDir = <span class="variable language_">this</span>.<span class="property">base_dir</span>;</span><br><span class="line">  <span class="keyword">const</span> target = args.<span class="property">_</span>[<span class="number">0</span>] ? <span class="title function_">resolve</span>(baseDir, args.<span class="property">_</span>[<span class="number">0</span>]) : baseDir;</span><br><span class="line">  <span class="keyword">const</span> &#123; log &#125; = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">existsSync</span>(target) &amp;&amp; <span class="title function_">readdirSync</span>(target).<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    log.<span class="title function_">fatal</span>(<span class="string">`<span class="subst">$&#123;magenta(tildify(target))&#125;</span> not empty, please run \`hexo init\` on an empty folder and then copy your files into it`</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">BlueBirdPromise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;target not empty&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&#x27;Cloning hexo-starter&#x27;</span>, <span class="variable constant_">GIT_REPO_URL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (args.<span class="property">clone</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">spawn</span>(<span class="string">&#x27;git&#x27;</span>, [<span class="string">&#x27;clone&#x27;</span>, <span class="string">&#x27;--recurse-submodules&#x27;</span>, <span class="string">&#x27;--depth=1&#x27;</span>, <span class="string">&#x27;--quiet&#x27;</span>, <span class="variable constant_">GIT_REPO_URL</span>, target], &#123;</span><br><span class="line">        <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      log.<span class="title function_">warn</span>(<span class="string">&#x27;git clone failed. Copying data instead&#x27;</span>);</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">copyAsset</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">copyAsset</span>(target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">BlueBirdPromise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">removeGitDir</span>(target),</span><br><span class="line">    <span class="title function_">removeGitModules</span>(target)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">if</span> (!args.<span class="property">install</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&#x27;Install dependencies&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> npmCommand = <span class="string">&#x27;npm&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">commandExistsSync</span>(<span class="string">&#x27;pnpm&#x27;</span>)) &#123;</span><br><span class="line">    npmCommand = <span class="string">&#x27;pnpm&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">commandExistsSync</span>(<span class="string">&#x27;yarn&#x27;</span>)) &#123;</span><br><span class="line">    npmCommand = <span class="string">&#x27;yarn&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (npmCommand === <span class="string">&#x27;yarn&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> yarnVer = <span class="keyword">await</span> <span class="title function_">spawn</span>(npmCommand, [<span class="string">&#x27;--version&#x27;</span>], &#123;</span><br><span class="line">        <span class="attr">cwd</span>: target</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> yarnVer === <span class="string">&#x27;string&#x27;</span> &amp;&amp; yarnVer.<span class="title function_">startsWith</span>(<span class="string">&#x27;1&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">spawn</span>(npmCommand, [<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--production&#x27;</span>, <span class="string">&#x27;--ignore-optional&#x27;</span>, <span class="string">&#x27;--silent&#x27;</span>], &#123;</span><br><span class="line">          <span class="attr">cwd</span>: target,</span><br><span class="line">          <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        npmCommand = <span class="string">&#x27;npm&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (npmCommand === <span class="string">&#x27;pnpm&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">spawn</span>(npmCommand, [<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--prod&#x27;</span>, <span class="string">&#x27;--no-optional&#x27;</span>, <span class="string">&#x27;--silent&#x27;</span>], &#123;</span><br><span class="line">        <span class="attr">cwd</span>: target,</span><br><span class="line">        <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (npmCommand === <span class="string">&#x27;npm&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="title function_">spawn</span>(npmCommand, [<span class="string">&#x27;install&#x27;</span>, <span class="string">&#x27;--only=production&#x27;</span>, <span class="string">&#x27;--optional=false&#x27;</span>, <span class="string">&#x27;--silent&#x27;</span>], &#123;</span><br><span class="line">        <span class="attr">cwd</span>: target,</span><br><span class="line">        <span class="attr">stdio</span>: <span class="string">&#x27;inherit&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    log.<span class="title function_">info</span>(<span class="string">&#x27;Start blogging with Hexo!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    log.<span class="title function_">warn</span>(<span class="string">`Failed to install dependencies. Please run &#x27;npm install&#x27; in &quot;<span class="subst">$&#123;target&#125;</span>&quot; folder.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copyAsset</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">copyDir</span>(<span class="variable constant_">ASSET_DIR</span>, target, &#123; <span class="attr">ignoreHidden</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeGitDir</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> gitDir = <span class="title function_">join</span>(target, <span class="string">&#x27;.git&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">stat</span>(gitDir).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; err.<span class="property">code</span> === <span class="string">&#x27;ENOENT&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">stats</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stats) &#123;</span><br><span class="line">      <span class="keyword">return</span> stats.<span class="title function_">isDirectory</span>() ? <span class="title function_">rmdir</span>(gitDir) : <span class="title function_">unlink</span>(gitDir);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">readdir</span>(target)).<span class="title function_">map</span>(<span class="function"><span class="params">path</span> =&gt;</span> <span class="title function_">join</span>(target, path)).<span class="title function_">filter</span>(<span class="function"><span class="params">path</span> =&gt;</span> <span class="title function_">stat</span>(path).<span class="title function_">then</span>(<span class="function"><span class="params">stats</span> =&gt;</span> stats.<span class="title function_">isDirectory</span>())).<span class="title function_">each</span>(removeGitDir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">removeGitModules</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">unlink</span>(<span class="title function_">join</span>(target, <span class="string">&#x27;.gitmodules&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; err.<span class="property">code</span> === <span class="string">&#x27;ENOENT&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = initConsole;</span><br></pre></td></tr></table></figure>
<p>虽然洋洋洒洒一百来行，但翻译下来只有两行对我们来说是有用的</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules --depth=<span class="number">1</span> --quiet https://github.com/hexojs/hexo-starter.git .</span><br><span class="line">npm install --only=prodection --optional=false --silent</span><br></pre></td></tr></table></figure>
<p>可以发现，正是<code>npm install --only=prodection --optional=false --silent</code>导致了卡死</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723160839120.png" alt="8"></p>
<p>还记得我们安装hexo的操作嘛？没错~<br>
加入<code>--registry=https://registry.npmmirror.com</code><br>
在blog文件夹里打开cmd，输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules --depth=<span class="number">1</span> --quiet https://github.com/hexojs/hexo-starter.git .</span><br><span class="line">npm install --only=prodection --optional=false --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure>
<p>观察到：</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723161219071.png" alt="9"></p>
<p>无视warning，安装成功！（如果加入了–silent，则观察不到这么多额外输出）</p>
<h4 id="2-4-启动hexo（搭建第一个本地网站）">2.4 启动hexo（搭建第一个本地网站）</h4>
<p>在blog文件夹打开cmd，输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>这个命令会启动hexo服务器，观察到以下输出即为启动成功：</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723161901953.png" alt="10"></p>
<p>打开任意浏览器，输入<code>http://localhost:4000/</code>，成功Hello World~</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240723162007530.png" alt="11"></p>
<h3 id="3-Solitude下载安装运行">3 Solitude下载安装运行</h3>
<p>这部分请参考<a href="https://solitude.js.org/zh/guide/quick-start">官方文档</a>~</p>
<h3 id="4-魔改">4 魔改</h3>
<p>会把自己研究的小玩意儿以及遇到的bug放在这里，施工中ing</p>
<h4 id="4-1-hexo-g后不自动产生-archives页面">4.1 hexo g后不自动产生/archives页面</h4>
<p>archives生成需要hexo-generator-archive</p>
<p>解决方案：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-archive --save</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++&amp;c#</title>
    <url>/2023/09/18/c++&amp;csharp/</url>
    <content><![CDATA[<h1>C++&amp;C#</h1>
<h1>第一讲&amp;第二讲：A Better C</h1>
<p>刘禹老师的课真火喵~100人的课硬是来了150人左右~教室都坐不下了喵)🤣~</p>
<h2 id="over-loading-重载">over loading 重载</h2>
<p>允许定义多个<strong>参数不同的</strong>同名函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">char</span>* p)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但不允许定义<strong>返回值不同</strong>的同名函数（对于一些函数，返回值不重要 exp. scanf() ）</p>
<h2 id="default-parameter-默认参数">default parameter 默认参数</h2>
<p>允许在调用函数但是传入参数不够时，为参数置初值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c=<span class="number">3</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>!!注意!!</strong>：默认参数放在后面，防止一会儿默认一会儿不默认 <s>不能像python一样指名点姓地默认</s></p>
<h2 id="占位参数">占位参数</h2>
<p>允许以下行为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定要传递，但程序中不能加以调用（可以下个版本再用👌）</p>
<h2 id="字节对齐">字节对齐</h2>
<p>c++中会自动对变量进行<a href="https://blog.csdn.net/qq_30534935/article/details/100692417">字节对齐</a>👈看这个</p>
<p>虽然方便程序控制，但是损耗了一些空间（大多数时候都忽略不计）</p>
<p>但是如果加入了此命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br></pre></td></tr></table></figure>
<p>c++就会以1为最小单位进行空间分配，即字节对齐</p>
<p><s>微信的空间压缩做得特别好，所以信号很差也能收到消息（忽略）</s></p>
<h2 id="封装-分治">封装 分治</h2>
<p><strong>member</strong>中包括两部分：<strong>attribute data member</strong> &amp; <strong>method function member</strong></p>
<p>c++中将struct升级为class（来源Simula语言），既能封装数值又能封装函数</p>
<h2 id="class类-vs-class-a-对象">class类  vs.  class a 对象</h2>
<ul>
<li>类是抽象，对象是客观存在</li>
<li>类是唯一的，对象是无穷的</li>
<li>对象就是一段连续的内存</li>
</ul>
<h2 id="Object-Oriented-喜欢OO的没有坏人！！！">Object Oriented(喜欢OO的没有坏人！！！)</h2>
<p><a href="https://t.bilibili.com/841124861968384021">正好老师提到了</a>www(逃~)</p>
<h2 id="access-control">access control</h2>
<p>为安全需要，一些东西需要上锁</p>
<p>分为<kbd>pritvate</kbd>和<kbd>public</kbd> (和<kbd>protected</kbd>)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(string a,<span class="type">double</span> s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="the-hidden-this-pointer">the hidden this pointer</h2>
<p>在类的函数内部，调用类中变量时，默认加入this</p>
<p>即若age是Student中变量，在Init中被调用，则<kbd>age</kbd>等于<kbd>this-&gt;age</kbd></p>
<p>但经我测试，这样的程序也是可以正常执行的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string id;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(string,<span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">getId</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> id;&#125;;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> score;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::Init</span><span class="params">(string id,<span class="type">double</span> score)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">	<span class="keyword">this</span>-&gt;score=score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Student x;</span><br><span class="line">	cout&lt;&lt;x.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x.<span class="built_in">getScore</span>()&lt;&lt;endl;</span><br><span class="line">	x.<span class="built_in">Init</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">99.9</span>);</span><br><span class="line">	cout&lt;&lt;x.<span class="built_in">getId</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x.<span class="built_in">getScore</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>第三讲：封装</h1>
<h2 id="class与struct默认访问权限不同">class与struct默认访问权限不同</h2>
<p>如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">//默认为pravite</span></span><br><span class="line">    <span class="type">int</span> ID；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="comment">//默认为public</span></span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="constructor-构造函数">constructor 构造函数</h2>
<p><strong>要求</strong>：与类同名，传递任意参数，没有返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   	<span class="built_in">Student</span>(<span class="type">char</span>*,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">char</span> *aname,<span class="type">int</span> aage)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=aname;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=aage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">((<span class="type">char</span>*)<span class="string">&quot;ZhangSan&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与在class里自己写void InitStudent相比，设置构造函数可以要求程序员必要在创建对象时赋初值</p>
<p>同时，<a href="https://fysszlr.github.io/2023/09/18/c-c-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%AC%AC%E4%BA%8C%E8%AE%B2%EF%BC%9AA-Better-C/">上一讲</a>介绍的同名参数和默认参数也可以在这里使用</p>
<hr>
<h2 id="default-constructor-默认构造">default constructor 默认构造</h2>
<p>在类的内部一直存在一个默认的构造函数，它<strong>初始没有任何作用</strong>，直到你写一个自己的构造函数为止</p>
<p>例如，假如你已经写了一个构造函数，但新建对象时没有进行构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student s0;</span><br></pre></td></tr></table></figure>
<p>此时便会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no appropriate default constructor available</span><br></pre></td></tr></table></figure>
<p>即找不到适合的默认构造</p>
<p>此时可以定义并声明一个<kbd>Student();</kbd>来解决</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s0;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别注意</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//这句话问题很大，可能被编译器认为是声明了一个函数，导致出错（而且编译不会报错）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="char-和char-比较">char[]和char*比较</h2>
<p><strong>char</strong>*</p>
<ul>
<li>优点：占用内存小，复制方便</li>
<li>缺点：很容易导致丢失，如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">char</span> *p=<span class="string">&quot;name&quot;</span>;</span><br><span class="line">    	s1-&gt;name=p;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时p作为动态空间已经被释放了，导致s1中name出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>char[]</strong></p>
<p>与char*相反~~（懒得写了）~~</p>
<hr>
<h2 id="类型也是类">类型也是类</h2>
<p>我们所使用的int等类型也是类</p>
<p>所以此两语句等价</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若以后遇到想要使用一个变量的地址，但又害怕该变量为动态变量，可以使用如下语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test::<span class="built_in">Test</span>(<span class="type">int</span> ID)&#123;</span><br><span class="line">    <span class="comment">//Test中有int* p</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(ID);</span><br><span class="line">    <span class="comment">//创建新整型，并传回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="destructor-析构函数-new-delete">destructor 析构函数(new delete)</h2>
<p>不同于java会自动删除内存，c++的内存释放必须要自己进行</p>
<p>上个部分的例子中，new int会将ID创建在堆区，而Test创建的对象在栈区，导致内存泄漏(memory leak)</p>
<p>此时便可以用析构函数在Test释放时自动清楚内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">Test</span>();</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>(<span class="type">int</span> ai,<span class="type">int</span> ID)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = ai;</span><br><span class="line">    <span class="keyword">this</span>-&gt;p = <span class="keyword">new</span> <span class="built_in">int</span>(ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test::~<span class="built_in">Test</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">1</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">//自动调用~Test();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="malloc-free-vs-new-delete">malloc/free vs. new/delete</h2>
<ul>
<li>
<p>malloc free是一对库函数</p>
</li>
<li>
<p>new delete是一对运算符</p>
</li>
</ul>
<p>看以下代码</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test *p = (Test*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Test));</span><br><span class="line">Test *p = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用malloc中，p在栈区，生成的Test<strong>在堆区</strong><br>
使用new中，p在栈区，生成的Test<strong>也在堆区</strong><br>
总结：new = malloc + constructor<br>
delete = deconstructor + free</p>
<hr>
<h2 id="handle-句柄">handle 句柄</h2>
<p>一个例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> * handle;<span class="comment">//句柄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>第四讲：封装(第二部分)</h1>
<hr>
<h2 id="reference-引用">reference 引用</h2>
<blockquote>
<p>指针的不安全处：</p>
<ol>
<li>fly pointer 野指针<br>
指针允许初始化不赋值</li>
<li>指针可以多次赋值</li>
</ol>
</blockquote>
<p>声明并定义一个引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> $r = i;</span><br><span class="line">r = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; r; <span class="comment">//控制台输出30</span></span><br></pre></td></tr></table></figure>
<p>引用的安全处：</p>
<ol>
<li>引用必须赋初值</li>
<li>引用在全程不能改变（即例子中的r必须一直指向i）</li>
</ol>
<p><strong>引用是一个安全的指针!</strong></p>
<p>address包括pointer和reference——引用是一个地址</p>
<p>所以可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">(<span class="type">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    a++; <span class="comment">//注意：访存不需要加地址符号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> &amp;r = a;</span><br><span class="line">    <span class="built_in">fun</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个总结：</p>
<ul>
<li>指针——复杂的、丑陋的</li>
<li>引用——简洁的、晦涩的</li>
</ul>
<p>JAVA舍弃了指针和变量本身，一切东西都是引用（恍然大悟!!!）</p>
<p>小彩蛋：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> p </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; r</span><br></pre></td></tr></table></figure>
<p>这两个等价</p>
<hr>
<h2 id="copy-constructor-拷贝构造函数">copy constructor 拷贝构造函数</h2>
<p>在C++中，我们允许一下操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(string,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>(string name,<span class="type">int</span> id)&#123;</span><br><span class="line">	name=name;</span><br><span class="line">	id=id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意main中s2的初始化，直接将s1作为参数传入了构造函数。这个程序的目的是将s1拷贝一份到s2里。</p>
<p>此时的构造函数，称作<strong>copy constructor 拷贝构造函数</strong></p>
<p>（在其它程序中，这个操作一般被称为clone）</p>
<p>注意！小心以下情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> *url;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(string,<span class="type">int</span>,<span class="type">int</span>*);</span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>(string name,<span class="type">int</span> id,<span class="type">int</span> p)&#123;</span><br><span class="line">	name=name;</span><br><span class="line">	id=id;</span><br><span class="line">	url=*p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>,<span class="number">100</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较于上一个程序，这段代码的改动之处在于为Student类提供了一个int*类属性，此时初始化s2便会产生有两个指针同时指向一段相同的堆区地址的情况，导致出错（尤其是在析构的时候），出现十分诡异的情况</p>
<hr>
<h2 id="深拷贝-logical-copy-vs-浅拷贝-bitwise-copy">深拷贝(logical copy) vs 浅拷贝(bitwise copy)</h2>
<p>顾名思义（指英文题目），深拷贝是将需要的部分以某种规则拷下来(logical)，浅拷贝是默认的拷贝方式(bitwise)（如上一部分的拷贝构造）</p>
<p>借用上一部分的例子，将默认的修改方式由浅拷贝修改为深拷贝的方式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	string name;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> *url;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(string,<span class="type">int</span>,<span class="type">int</span>*);</span><br><span class="line">    <span class="built_in">Student</span>(Student &amp;s);</span><br><span class="line">&#125;;</span><br><span class="line">Student::<span class="built_in">Student</span>(string name,<span class="type">int</span> id,<span class="type">int</span> p)&#123;</span><br><span class="line">	name=name;</span><br><span class="line">	id=id;</span><br><span class="line">	url=*p;</span><br><span class="line">&#125;</span><br><span class="line">Student::<span class="built_in">Student</span>(Student &amp;s)&#123; <span class="comment">//这里一定是s的引用</span></span><br><span class="line">    name=s.name;</span><br><span class="line">    id=s.name;</span><br><span class="line">    url=<span class="keyword">new</span> <span class="built_in">int</span>(*s.url);</span><br><span class="line">    <span class="comment">//为s的url在堆区创建一个值相同的不同地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;abc&quot;</span>,<span class="number">100</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们创建了一个新的构造方式，并通过自己写的逻辑方式规避了指针冲突的情况，所以是深拷贝</p>
<p>更进一步，如何保证自己使用的一定是深拷贝捏？或者怎么保证对象不被浅拷贝捏？</p>
<p>答案是使用私有拷贝构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;t);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，只能通过私有拷贝函数来深拷贝</p>
<p>或者干脆拷贝函数留空，杜绝浅拷贝的可能性</p>
<hr>
<h2 id="pass-by-value-vs-pass-by-address">pass by value vs. pass by address</h2>
<table>
<thead>
<tr>
<th>方面</th>
<th>value</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>sizeof(v)</td>
<td>sizrof(int)</td>
</tr>
<tr>
<td>功能</td>
<td>read only</td>
<td>read/return</td>
</tr>
<tr>
<td>麻烦</td>
<td>copy-structor</td>
<td>nothing</td>
</tr>
</tbody>
</table>
<p><strong>总结：never pass by value!!!</strong></p>
<hr>
<h2 id="static">static</h2>
<h3 id="1-static-local-variable-静态局部变量">1. static local variable 静态局部变量</h3>
<p>无论何时创造，只在main后析构</p>
<h3 id="2-static-global-function-静态全局函数">2. static global function 静态全局函数</h3>
<p>一旦函数被修饰为static，则该函数被限制为对外部透明，只在此文件可用</p>
<p>在多人开发项目时，可以将每个函数修饰static，不会影响其它项目部分</p>
<p>与此相反，extern指外连接，即“我有一个东西，在外部去找”，可以用于全局变量</p>
<h3 id="3-static-global-variable-静态全局变量">3. static global variable 静态全局变量</h3>
<p>只在本文件中可以使用，没有意义</p>
<h3 id="4-static-data-member-静态类对象">4. static data member 静态类对象</h3>
<p>当一个类中的对象被修饰为static，则该对象被认为是属于所有对象</p>
<p><strong>注意：静态类对象不应该在任何对象中初始化（因为是共有的）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">static</span> cnt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Student::j=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></table></figure>
<h3 id="5-static-function-member-静态函数">5. static function member 静态函数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyTime</span> &#123;</span><br><span class="line"><span class="keyword">public</span> : </span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">long</span> <span class="title">GetCurTime</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">MyTime::GetCurTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    MyTime t1;</span><br><span class="line">    t<span class="number">1.</span><span class="built_in">GetCurTime</span>();</span><br><span class="line">    MyTime::<span class="built_in">GetCurTime</span>();<span class="comment">//注意这行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为函数修饰static后，该函数可以在没有对象的情况下直接被调用（即 MyTime::GetCurTime();）</p>
<p>同时，静态函数要求不能访问<strong>非静态属性</strong>，否则很明显会引发问题</p>
<p>收获满满的一节课喵~</p>
<hr>
<h1>第五讲：封装(第三部分)</h1>
<hr>
<h2 id="design-pattern-中的单件（单例）模式">design pattern 中的单件（单例）模式</h2>
<p>design pattern指根据实际情况为代码确定的具体要求，共有二十多种场景</p>
<p>其中一个场景为<strong>单件（单例）模式</strong>，即在程序中只能实例化一个对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>&#123;</span><br><span class="line">	<span class="built_in">Single</span>();</span><br><span class="line">	<span class="type">static</span> Single* self;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="function"><span class="type">static</span> Single* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Single* Single::self = <span class="literal">NULL</span>;</span><br><span class="line">Single::<span class="built_in">Single</span>()&#123;&#125;</span><br><span class="line"><span class="function">Single* <span class="title">Single::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(self==<span class="literal">NULL</span>)self=<span class="keyword">new</span> <span class="built_in">Single</span>();</span><br><span class="line">	<span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	Single *s=Single::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Single类将构造函数设置为了private，所以在程序执行过程中无法实例化新对象</p>
<p>同时，为了不让这个类与世隔绝，设置了一个静态方法GetInstance()，当主程序执行这个方法时，会实例一个静态对象self，并传回引用，保证了单例模式的实现</p>
<hr>
<h2 id="const">const</h2>
<p><strong>最大作用</strong>：<strong>修饰函数参数</strong></p>
<h3 id="1-const-parameter">1. const parameter</h3>
<p>防止传入的地址变量被修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span></span>&#123;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>凡是const修饰的一定是in，反之一定是out</p>
<h3 id="2-const-data-member">2. const data member</h3>
<p>没别的意思，就是不许变</p>
<p>老师顺便扯到了<a href="https://blog.csdn.net/qq_35902025/article/details/127567837">enum</a>，狠狠学习了www~</p>
<h3 id="3-const-function">3. const function</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::fun</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">const</span> Test t;</span><br><span class="line">    t.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有不修改类内变量的函数才能被const修饰</p>
<p>（若const放在方法前，则为修饰返回值）</p>
<hr>
<h2 id="运算符重载">运算符重载</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="built_in">Test</span>();</span><br><span class="line">    Test <span class="keyword">operator</span> + (<span class="type">int</span> m)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt += m;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Test::<span class="built_in">Test</span>()&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	Test t0=<span class="built_in">Test</span>();</span><br><span class="line">	cout&lt;&lt;t<span class="number">0.</span><span class="built_in">getCnt</span>();</span><br><span class="line">	t0=t0<span class="number">+1</span>;</span><br><span class="line">	cout&lt;&lt;t<span class="number">0.</span><span class="built_in">getCnt</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老师还教了前++和后++，但太麻烦了，不想学了喵~</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test&amp; <span class="keyword">operator</span> ++();<span class="comment">//前++</span></span><br><span class="line">Test operstor ++(<span class="type">int</span>);<span class="comment">//后++</span></span><br></pre></td></tr></table></figure>
<p>可以卷其它课了喵www~</p>
<hr>
<h1>第六讲：继承 与 多态</h1>
<blockquote>
<p>性能问题出现之前不考虑性能问题</p>
<p>​																																——刘禹</p>
</blockquote>
<hr>
<h2 id="继承">继承</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : People&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>继承是特性与个性的划分</strong></p>
<p>很容易理解</p>
<hr>
<h2 id="子类构造">子类构造</h2>
<p>构造子类构造，必调用父类构造</p>
<p>先调父类构造，再调子类构造</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Dervied::<span class="built_in">Dervied</span>(<span class="type">int</span> ai,<span class="type">int</span> aj) ： <span class="built_in">Base</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>👆：在子类构造中调用父类构造</p>
<hr>
<h2 id="多重继承">多重继承</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span> : <span class="keyword">public</span> b, <span class="keyword">public</span> c &#123;</span><br><span class="line"></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="多态">多态</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pet::speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Pet::speak&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Pet &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Cat::speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;miao~&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Pet &#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dog::speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;wang!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多态：在类型传递过程中，保证类型行为正确</p>
<hr>
<h2 id="upcasting-向上类型转换">upcasting 向上类型转换</h2>
<p>子类可以当作父类处理或传递，父类不能被视为子类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line"> 	<span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">needle</span><span class="params">(Pet &amp;pet)</span></span>&#123;</span><br><span class="line">    pet.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ol>
<li>Pet类中的speak函数前有virtual关键字(虚函数)</li>
<li>传入函数的为引用，而非值</li>
</ol>
<p>原理为每个实例都有一个<strong>虚指针</strong>，表示该实例的类型</p>
<p>父类有<strong>虚指针索引</strong>，记录所有的子类</p>
<p>当传值时，子类会调用<strong>父类的拷贝构造</strong>，导致出错</p>
<hr>
<h2 id="局部析构">局部析构</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span>&#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>();</span><br><span class="line">    <span class="comment">//若不加virtual，则认为析构函数非多态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span> : <span class="keyword">public</span> base &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	base *p = <span class="keyword">new</span> derived;</span><br><span class="line">    <span class="comment">//正确析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="pure-virtual-纯虚函数">pure virtual 纯虚函数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>若一个类含有至少一个纯虚函数，则该类被称为<strong>抽象类</strong></p>
<hr>
<h2 id="abstract-class-抽象类">abstract class 抽象类</h2>
<ol>
<li>
<p>提纲挈领</p>
<p>规定一个类中的接口——抽象类确实和接口差不多，但是可以实例化</p>
</li>
<li>
<p>串联不同家族的共性行为</p>
<p>更像接口了()但是可以总结不同家族的特点</p>
</li>
</ol>
<p>原来如此：C++抽象类=Java接口</p>
<hr>
<h2 id="补充：python——接口型的多态">补充：python——接口型的多态</h2>
<p>鸭子类型</p>
<p>不纠结是否确实是类型上的多态，只考虑行为一致</p>
<hr>
<h2 id="补充：C-vs-Java-C">补充：C++ vs. Java/C#</h2>
<p>c++为了做类库，专门做了个stl</p>
<p><strong>s</strong>tandard <strong>t</strong>emplate <strong>l</strong>ibrery</p>
<p>动态增长的万能容器</p>
<p><strong>性能问题出现之前不考虑性能问题</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>c++&amp;c#</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记：从时序到时空再到城市大模型的演进</title>
    <url>/2024/09/23/%E4%BB%8E%E6%97%B6%E5%BA%8F%E5%88%B0%E6%97%B6%E7%A9%BA%E5%86%8D%E5%88%B0%E5%9F%8E%E5%B8%82%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<h2 id="论文笔记：从时序到时空再到城市大模型的演进">论文笔记：从时序到时空再到城市大模型的演进</h2>
<h3 id="引言">引言</h3>
<p>在大语言模型（large language model，LLM）快速发展的当下，研究人员对聊天、代码生成等各种LLM显然擅长的领域中进行了充分而广泛的探索，已经产生了一批诸如GPT、BERT、Llama、Qwen等快速迭代的模型。同时，为了最大化利用大语言模型强大的泛化和推理能力，许多研究开始尝试让大语言模型解决其它领域的问题。一方面，LLM可以嵌入原始模型内部，为模型提供外部信息或加快收敛速度（如RAG）；另一方面，LLM也可以将原始问题进行拓宽，从而产生新赛道新问题。近年来，在金融、医疗、时序等诸多领域，都产生了重量级的成果。</p>
<p>本文总结了近两年来时间序列领域（尤其是与轨迹、大模型相结合）的重要文章，并对他们进行梳理，以期找到时序、时空、城市大模型等方向的发展线索与未来启示。</p>
<h3 id="时序">时序</h3>
<h4 id="1-TimeGPT-1">1. TimeGPT-1</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240922011624061.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2310.03589">https://arxiv.org/pdf/2310.03589</a></p>
<p>在这篇文章中，作者构建了第一个时间序列领域的基座模型TimeGPT-1，并开辟了使用预训练大模型用于时间序列的新赛道。由于不同数据集的时间尺度、波动范围以及样本量差异很大，因此使用大模型捕捉时间序列内的深层次规律是合理的想法，特别是训练样本很少时（zero-shot）。作者还使用了conformal prediction来量化大模型的波动性，进行了简单的异常检测。论文的实验部分较为完整，可惜缺失zero-shot下与相似基座模型的比较；模型代码没有公开；文章的行文也有几处较为发散。</p>
<h4 id="2-Timer-Generative-Pre-trained-Transformers-Are-Large-Time-Series-Models">2. Timer: Generative Pre-trained Transformers Are Large Time Series Models</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240922115008555.png" alt=""></p>
<p>论文：<a href="https://aacrjournals.org/cancerres/article/77/21/e108/662567/TIMER-A-Web-Server-for-Comprehensive-Analysis-of">https://aacrjournals.org/cancerres/article/77/21/e108/662567/TIMER-A-Web-Server-for-Comprehensive-Analysis-of</a></p>
<p>作者首先通过数据证明深度学习模型在样本量较少时效果会指数级变差，所以使用大模型技术构建一个大时间序列模型（large time series models，LTSM）是必要的。由于现有数据集无法满足作者要求，作者构建了一个约12G的复杂时间序列数据集，涵盖了7个主要时间序列领域。模型方面，作者将所有不同的序列统一化首尾拼接，并利用类似滑动窗口的技术构建输入单一序列（single-series sequence，S3）作为输入，最后用标准的transformer架构模型解决问题。这篇文章的模型架构较为简单，但复杂数据集的构建弥补了这一点。</p>
<h4 id="3-Time-llm-Time-series-forecasting-by-reprogramming-large-language-models">3. Time-llm: Time series forecasting by reprogramming large language models</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240922202341563.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2310.01728">https://arxiv.org/pdf/2310.01728</a></p>
<p>Time-llm同样想用LLM强大的推理能力强化时间序列预测的性能，但与先前工作不同的是，Time-llm想要使用NLP相关的大模型进行推理。为了解决从时间序列数据到自然语言的转化，作者将原始数据分patch进行了从数据到语义的对应。同时，作者将其它信息整合为辅助信息同时输入也是一个亮点。这种包括先验prompt和数据reprogramming的prompt驱动的LLM-时间序列分析方法在2024年的论文中成为了一股潮流。Time-llm在零样本和少样本时的实验效果提升较大。</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240922203816370.png" alt="Time-llm模型架构"></p>
<h3 id="时空">时空</h3>
<h4 id="4-TrajGDM-A-New-Trajectory-Foundation-Model-for-Simulating-Human-Mobility">4. TrajGDM: A New Trajectory Foundation Model for Simulating Human Mobility</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923082844394.png" alt=""></p>
<p>论文：<a href="https://dl.acm.org/doi/pdf/10.1145/3589132.3628362">https://dl.acm.org/doi/pdf/10.1145/3589132.3628362</a></p>
<p>TrajGDM尝试用扩散模型的方法构建轨迹基座模型，以此统一地指导各种下游任务。具体到方法层面，作者将轨迹映射到了轨迹图中；然后使用轨迹扩散器往轨迹图中不断加噪声直到达到正态分布；最后使用轨迹生成器找到原始轨迹。作者采用了Generative Adversarial Network (GAN)和马尔科夫链相结合的方式计算轨迹的位置。美中不足的是，TrajGDM似乎没有考虑轨迹的时序，仅仅将轨迹的地理位置嵌入模型；对于轨迹领域除轨迹生成外其它下游任务也有些言之不详。</p>
<h4 id="5-Towards-A-Foundation-Model-For-Trajectory-Intelligence">5. Towards A Foundation Model For Trajectory Intelligence</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923084830968.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2312.00076">https://arxiv.org/pdf/2312.00076</a></p>
<p>作者在这篇文章中想要构建一个预训练大轨迹模型（large trajectory model，LTM），并通过fine-tune解决轨迹下游任务，当某地区轨迹数量少时，这种思路尤其有效。数据处理方面，作者为了合并相似轨迹点以减少收敛时间和vocabulary大小，提出了使用&lt;地点，时序&gt;输入+编码+聚类+hash的轨迹tokenizer方法。训练中，作者将轨迹随机遮盖（Masked Trajectory modeling，MTM）来构建子监督学习模型。模型在子轨迹预测、终点预测和轨迹-用户对应三个不同的下游任务中都展现出了较好的效果。但这篇文章的时序可能没有考虑具体的时间戳信息，这限制了模型质量。</p>
<h4 id="6-TrajFM-A-Vehicle-Trajectory-Foundation-Model-for-Region-and-Task-Transferability">6. TrajFM: A Vehicle Trajectory Foundation Model for Region and Task Transferability</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923091336570.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2408.15251">https://arxiv.org/pdf/2408.15251</a></p>
<p>万怀宇老师近期在时空大模型方面成果频出，TrajFM是较新的一篇。TrajFM认为区域的轨迹和周围的POI密不可分，所以可以使用POI中蕴含的信息增强大轨迹模型效果。TrajFM将每个轨迹点表示为（位置、时间戳、POI信息）三部分，其中POI部分是使用openAI的text2embedding增强POI语义理解实现的，让人眼前一亮。作者还设计了Learnable Spatio-Temporal Rotary Position Embedding (STRPE)来计算轨迹点之间的相关性。实验部分，作者比较了TrajFM与多种方法在时间预测方面的效果，TrajFM在跨区域的实验中也展现出了不俗的结果，这展现了模型的通用性。</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923091920661.png" alt="TrajFM模型架构"></p>
<h3 id="城市大模型">城市大模型</h3>
<h4 id="7-Urbangpt-Spatio-temporal-large-language-models">7. Urbangpt: Spatio-temporal large language models</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923145451570.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2403.00813">https://arxiv.org/pdf/2403.00813</a></p>
<p>时间序列预测致力于从过往数据中得到未来数据的信息，这与城市治理这一领域不谋而合，因此最近出现了多篇以城市治理为故事、主要进行时间或时空序列任务的论文。UrbanGPT使用编码器和额外的回归层将时空依赖信息编码到向量空间，然后进行数据到文字的对齐。为了向大模型中输入复杂的城市相关信息，所有的prompt都被分为了时间信息、空间信息、任务描述三部分，便于多模态模型理解语言和时序信息。最终大模型预测出的数据也会使用卷积层与输入一起解码成答案。UrbanGPT与Time-llm有相似之处，但UrbanGPT通过城市信息的注入增强了模型对空间信息的泛化能力。</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923152858339.png" alt="UrbanGPt模型架构"></p>
<h4 id="8-UniST-a-prompt-empowered-universal-model-for-urban-spatio-temporal-prediction">8. UniST: a prompt-empowered universal model for urban spatio-temporal prediction</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923154447141.png" alt=""></p>
<p>论文：<a href="https://dl.acm.org/doi/pdf/10.1145/3637528.3671662">https://dl.acm.org/doi/pdf/10.1145/3637528.3671662</a></p>
<p>UniST采用了大规模预训练和提示学习，通过捕捉复杂的时空动态，提高了在少样本和零样本场景中的泛化能力。与UrbanGPT不同的是，UniST将时空数据编码后，使用多种不同的切片方式获取轨迹片段，再进行注入，从而捕获时空数据内部的特征。除此之外，作者在生成prompt时将时空信息分别投入记忆池，方便使用时空数据的编码从中获取额外信息。UniST在20多个时空场景中表现优异，尤其在少样本和零样本预测任务中，实现了比当前最先进模型更好的性能.</p>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923154604353.png" alt="UniST模型架构"></p>
<h4 id="9-CityGPT-Empowering-Urban-Spatial-Cognition-of-Large-Language-Models">9. CityGPT: Empowering Urban Spatial Cognition of Large Language Models</h4>
<p><img src="https://raw.githubusercontent.com/fysszlr/blog-image/main/image-20240923161104862.png" alt=""></p>
<p>论文：<a href="https://arxiv.org/pdf/2406.13948">https://arxiv.org/pdf/2406.13948</a></p>
<p>CityGPT的框架包括两个核心组件：CityInstruction是一个多样化的数据集，通过构建包含地理信息的自然语言示例，使模型能够理解不同地点的地理位置及其相互关系；CityEval是一个评估基准，分为四个任务组：城市图像、城市语义、空间推理和综合任务，用于评估LLMs在不同城市场景下的能力。CityGPT使用原创数据集训练小型LLM，这些模型在城市任务（如出行预测、空间导航和城市语义理解）中表现出色，甚至在某些城市场景中超越了商业LLMs。</p>
<h3 id="总结">总结</h3>
<p>本文总结了近几年在时序、时空以及城市大模型领域的代表性研究，展示了大语言模型在时间序列和时空数据中的应用潜力，并探讨了从时序模型到城市大模型的演进路径。</p>
<p>总体而言，从时间序列到时空模型再到城市大模型的演进，展现了大语言模型在这些新兴领域的巨大潜力。未来，如何更好地将时空信息与城市数据整合，并进一步提升模型的泛化和推理能力，将是这一领域的主要挑战和发展方向。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>OOpre 课程总结</title>
    <url>/2023/11/04/OOpre-%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1>OOpre 课程总结</h1>
<p>大纲：</p>
<ol>
<li>作业最终的架构设计, 在迭代中的架构调整及考虑</li>
<li>使用junit的心得体会</li>
<li>学习oopre的心得体会（包括但不限于从面向过程编程过渡到面向对象编程的体会）</li>
<li>对oopre课程的简单建议（不多于两条）</li>
</ol>
<h2 id="作业最终的架构设计-在迭代中的架构调整及考虑">作业最终的架构设计, 在迭代中的架构调整及考虑</h2>
<p>先附上一张图，展现各个类及其大致关系（其中commodity为接口）</p>
<p><img src="data:image/png;base64,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" alt="很丑的架构图"></p>
<p><strong>和其它同学相比，我的类较少</strong>，究其原因是往往用一个类做的其它同学多个类的事情。如：在我的<code>Fight</code>类中，既有<code>fightStart()</code>方法，控制战斗相关命令，也有<code>fightLog</code>数组，保存战斗记录。这样做的好处是实现简单，不需要额外写类和方法，缺点点是结构不够清晰，并造成调试方面的困难</p>
<h4 id="在历次迭代中，调整比较大的有两次：">在历次迭代中，调整比较大的有两次：</h4>
<ol>
<li>
<p>增加<code>Fight</code>类</p>
<p>由于战斗发生在多个冒险者之间，所以<code>Fight</code>类应当独立于<code>Adventurer</code>存在。但是由于我前期完成代码时没有对各类的<strong>各种属性</strong>提供足够多的<strong>访问方法</strong>，导致在实现过程中对多个类进行了比较大的更改</p>
</li>
<li>
<p>增加<code>Commodity</code>接口</p>
<p>问题集中在添加<code>getClassName()</code>这个方法的过程中。我因为一开始对<strong>子类重写父类函数</strong>不够熟悉，所以不加思索地写出了几个非常丑的if判断，对后面的开发造成了许多困难</p>
</li>
</ol>
<h2 id="使用junit的心得体会">使用junit的心得体会</h2>
<ol>
<li>
<p>junit的重点是<strong>分支测试</strong></p>
<p>在使用junit的过程中，往往会出现弱测和junit都能通过，但在和同学对拍的过程中发现问题的现象。一般来说这种情况都是<strong>junit分支测试不全面</strong>导致的。</p>
</li>
<li>
<p>同一个类的测试可以套模板</p>
<p>在测试同一个类的不同方法时（尤其是<code>Bottle</code>这样的类），往往要先预创建其它实例对象，此时如果给每一个方法都写一个单独的实例化过程会非常耽误时间。可以先写一段比较万能的初始化语句，方便进行测试</p>
</li>
<li>
<p>不同类的测试有先后顺序</p>
<p>应当按照如上面流程图的拓扑序进行测试，否则在测试子类时会出现”子类是对的，父类错了“的尴尬情况</p>
</li>
</ol>
<h2 id="学习oopre的心得体会">学习oopre的心得体会</h2>
<p>在编程的世界里，我经历了从面向过程编程（POP）到面向对象编程（OOP）的转变。这一转变让我对编程有了更深的理解，也让我对软件设计有了新的视角。</p>
<p>在POP的世界里，我们关注的是<strong>单个过程</strong>，如何一步步解决问题。这种思维方式在处理一些简单的问题时非常有效，但对于复杂的问题，POP就显得力不从心。因为复杂的问题往往涉及多个过程，各个过程之间相互影响，难以用单一的过程来理解和解决。</p>
<p>而OOP则为我们提供了一个新的视角。它把世界看作是由许多对象组成的，每个对象都有自己的属性和行为。这些对象通过消息传递<strong>相互协作，共同解决问题</strong>。这种思维方式更接近现实世界，也更适合解决复杂的问题。</p>
<p>从POP到OOP的转变，对我来说是一个挑战，但也是一个成长的机会。我开始理解到，面向对象编程不仅仅是一种编程技术，更是一种思考问题的方式。它帮助我更好地理解和组织代码，使代码更易于维护和扩展。</p>
<p>同时，OOP也让我理解到，编程不仅仅是写代码，更是设计和规划。在设计和规划的过程中，我们需要考虑代码的结构、模块的划分、对象的交互等问题。这些问题的解决，需要我们对问题有深入的理解，也需要我们有足够的创新思维。</p>
<h2 id="对oopre课程的简单建议">对oopre课程的简单建议</h2>
<ol>
<li>当前OOpre中讨论区活跃度较低，希望在OO正课中能有所改善</li>
<li>对git的介绍并不够清晰，建议将创建sshkey的过程写入教程</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>OOpre</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次の建站</title>
    <url>/2023/09/17/%E7%AC%AC%E4%B8%80%E6%AC%A1%E3%81%AE%E5%BB%BA%E7%AB%99/</url>
    <content><![CDATA[<h4 id="喂喂喂-！听得见嘛？">喂喂喂~！听得见嘛？</h4>
<h2 id="这里是-fysszlr">这里是  fysszlr</h2>
<p>因为还没有想好要说什么就先到这里吧</p>
<p>总之，和大家见面真的很不容易（真的），要多来看我哦~!</p>
<hr>
<p><s>以后可能会在这个页面下更新主题魔改日志（网上全是butterfly呜呜呜）</s></p>
<hr>
<p>2023.10.16更新</p>
<p>什么，主题开发者润了（大悲）</p>
<p>开始思考后路：</p>
<p>选项1：换一个主题（你说butterfly那么好，为啥不用捏）</p>
<p>选项2：自己把主题文件吃透了自己魔改QwQ</p>
<p>（纠结ing）</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>fysszlr</tag>
      </tags>
  </entry>
  <entry>
    <title>西方音乐鉴赏</title>
    <url>/2023/09/25/%E8%A5%BF%E6%96%B9%E9%9F%B3%E4%B9%90%E9%89%B4%E8%B5%8F/</url>
    <content><![CDATA[<p>上了三节课之后发现这节课并不水~~（哭唧唧）<s>，必须要随手记点东西</s>（不然真挂科了）~~</p>
<hr>
<h4 id="巴洛克时期音乐特点">巴洛克时期音乐特点</h4>
<ul>
<li>速度变化</li>
<li>低音驱动的和弦(数字低音)——通奏低音</li>
<li>很多装饰音(上波音，下波音)，和建筑、服装相呼应，有华丽感觉</li>
<li>首次在乐曲中出现力度对比，在乐谱上出现力度标注</li>
</ul>
<p><u>巴洛克时期开始大量使用羽管键琴</u></p>
<hr>
<h4 id="巴洛克早期音乐">巴洛克早期音乐</h4>
<p>意大利歌剧家蒙特威尔创作了第一部成熟歌剧《奥菲欧》</p>
<ol>
<li>托卡塔 小号三段反复，标志歌剧开始</li>
<li>咏叹调  用华丽的装饰音持续，木管号等各种乐器铺垫</li>
</ol>
<hr>
<h4 id="巴洛克中期音乐">巴洛克中期音乐</h4>
<p>17世纪，器乐的普及和流行开始与声乐竞争</p>
<p>小提琴家族逐渐流行</p>
<p>当时贵族娱乐：骑马、击剑、跳舞，由此出现芭蕾舞</p>
<p>吕利</p>
<ul>
<li>
<p>小提琴家 宫廷音乐家</p>
</li>
<li>
<p>创作法国歌剧</p>
<ul>
<li>
<p>序曲：快——慢——快</p>
<p>​			二拍——三拍——二拍</p>
</li>
</ul>
</li>
<li>
<p>创作巴洛克奏鸣曲：器乐的室内乐</p>
<ul>
<li>
<p>教堂奏鸣曲</p>
</li>
<li>
<p>室内奏鸣曲</p>
<ul>
<li>独奏奏鸣曲</li>
<li>三重奏鸣曲</li>
</ul>
<p>由一组舞曲组成：阿拉曼德、萨拉班德、加沃特、吉格</p>
<p>通奏低音演奏</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="巴洛克晚期音乐">巴洛克晚期音乐</h4>
<p>复调音乐：难写、难弹、难听懂——听线条</p>
<ul>
<li>卡农</li>
<li>赋格</li>
</ul>
<p>主调音乐：听纵向的和声</p>
<p>塞巴斯蒂安·巴赫</p>
<ul>
<li>管风琴音乐 《d小调托卡塔与赋格》</li>
<li>羽管键琴音乐《十二平均律》</li>
<li>古诺 《圣母颂》</li>
<li>古组曲 《b小调第二号管弦乐组曲》</li>
</ul>
<p>巴洛克时期协奏曲</p>
<ul>
<li>大协奏曲</li>
<li>独奏协奏曲</li>
</ul>
<p>乔治·弗里德里希·亨德尔</p>
<ul>
<li>阉人歌手大放异彩……真恶心</li>
</ul>
<h1>第三章 古典主义时期的音乐（1750-1820）</h1>
<h3 id="关于“古典主义”音乐">关于“古典主义”音乐</h3>
<ol>
<li>指古希腊、古罗马时期的音乐</li>
<li>指“严肃”音乐或艺术类音乐</li>
<li>指1750-1820期间的音乐</li>
</ol>
<hr>
<h2 id="一、社会文化对音乐的影响">一、社会文化对音乐的影响</h2>
<h3 id="（一）启蒙运动">（一）启蒙运动</h3>
<ul>
<li>
<p>古典音乐风格的形成和18世纪社会风气、环境有直接关系</p>
<p>艺术是生活中必不可少的装饰</p>
</li>
<li>
<p>宫廷音乐继续盛行</p>
</li>
<li>
<p>启蒙思想开花结果促进维也纳古典乐派的形成 “狂飘运动”</p>
</li>
</ul>
<h4 id="海顿">海顿</h4>
<p>​	清唱剧《创世纪》《四季》</p>
<h4 id="莫扎特">莫扎特</h4>
<p>​	4部喜歌剧：</p>
<p>​	《费加罗的婚礼》《唐·璜》</p>
<p>​	《女人心》《魔笛》</p>
<h4 id="贝多芬">贝多芬</h4>
<p>​	32首钢琴奏鸣曲：</p>
<p>​	《c小调（悲怆）奏鸣曲》</p>
<p>​	《f小调（热情）奏鸣曲》</p>
<p>​	9部交响曲：</p>
<p>​	《c小调第五（命运）交响曲》</p>
<p>​	《d小调第九（合唱）交响曲》</p>
<h4 id="启蒙运动影响了“听”音乐的人">启蒙运动影响了“听”音乐的人</h4>
<p>公众音乐会：</p>
<ul>
<li>巴黎：圣灵音乐会（1725）</li>
<li>伦敦：沃克斯花园音乐会（1764）</li>
</ul>
<p>18世纪中叶，中产阶级取得古典音乐控制权，古典音乐成为普通人享受的公众娱乐</p>
<h4 id="启蒙运动影响了“演奏”音乐的人">启蒙运动影响了“演奏”音乐的人</h4>
<p>新富足起来的中产阶级希望演奏音乐</p>
<p>古钢琴：Pianoforte</p>
<h3 id="（二）古典时期的建筑、绘画、服装">（二）古典时期的建筑、绘画、服装</h3>
<h4 id="绘画">绘画</h4>
<p>“新古典主义”</p>
<h4 id="服装">服装</h4>
<p>由巴洛克时期的繁复华丽变为简单垂挂式的衣衫</p>
<h4 id="建筑">建筑</h4>
<p>古希腊几何图案、均衡对称的圆柱</p>
<h2 id="二、音乐风格与表演实践">二、音乐风格与表演实践</h2>
<h3 id="（一）古典音乐的语言">（一）古典音乐的语言</h3>
<ol>
<li>
<h4 id="旋律：方正对称、比例均衡">旋律：方正对称、比例均衡</h4>
<ul>
<li>简单、短小</li>
<li>对称、均衡的组合：4+4、8+8乐句</li>
<li>“上下句”的问答式</li>
</ul>
<p>莫扎特《小星星变奏曲》4+4 乐句</p>
<p>莫扎特《第21钢琴协奏曲》k467第二乐章 问答式（3+3）</p>
</li>
<li>
<h4 id="曲式结构">曲式结构</h4>
<p>通谱歌，二部曲式，三部曲式（ABA），回旋曲式，变奏曲式</p>
<p>奏鸣曲式快板（唯独这个产生于维也纳古典主义时期）</p>
<ul>
<li>
<p>奏鸣曲与奏鸣曲式不同</p>
</li>
<li>
<p>包括（引子）、呈示部、展开部、再现部、（尾声）</p>
<p><s>海顿经常用慢的引子（不重要）</s></p>
<p>呈示部必具备2个核心主题（主部与副部）且调性不同：主调大调，副调属大调；主调小调，副调平行大调</p>
<p>碎片式的展开，不断转调</p>
<p>再现部与呈示部对称</p>
</li>
</ul>
<p>莫扎特《G小调第40交响曲》第一乐章</p>
</li>
<li>
<h4 id="和声">和声</h4>
<p>1750年之后，古典主义音乐都具有主调更多，复调更少的特点</p>
<ul>
<li>作曲家发明：阿尔贝蒂低音 伴奏音型</li>
<li>主调
<ul>
<li>建立再大小调基础之上</li>
<li>巴洛克时期的通奏低音消失</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="节奏、节拍">节奏、节拍</h4>
<ol>
<li>
<p>简单持续性的节奏模式：</p>
<p>产生重复的节奏音型</p>
<p>（阿尔贝蒂低音：三和弦分解）</p>
</li>
<li>
<p>休止：强而有力的终止式后出现一小节休止…各个乐章的速度从头到尾保持一致</p>
</li>
</ol>
</li>
<li>
<h4 id="速度">速度</h4>
<p>变拍子-速度的变化（休止的作用）</p>
<p>莫扎特歌剧《费加罗的婚礼》——咏叹调——小伯爵之舞</p>
<ul>
<li>A段：3/4拍——宫廷小步舞</li>
<li>D段：2/4拍——速度加快</li>
<li>旋律方正对称</li>
<li>调式：A段（大调）——C段（小调）</li>
<li>曲式结构：ABCDA</li>
</ul>
</li>
</ol>
<h3 id="（二）古典音乐“非标题”性">（二）古典音乐“非标题”性</h3>
<p>海顿《升f小调第45（告别）交响曲》第四乐章 终曲乐章</p>
<h3 id="（三）音乐体裁">（三）音乐体裁</h3>
<p>歌剧</p>
<p>协奏曲</p>
<p>奏鸣曲</p>
<p>弦乐四重奏</p>
<p>交响曲</p>
<h2 id="三、古典主义作曲家海顿">三、古典主义作曲家海顿</h2>
<p>“交响乐之父”、”弦乐四重奏之父”</p>
<h3 id="（一）海顿弦乐四重奏">（一）海顿弦乐四重奏</h3>
<p>第一小提琴</p>
<p>第二小提琴</p>
<p>中提琴</p>
<p>大提琴</p>
<p>海顿《第76（皇帝）弦乐四重奏》第二乐章——现德国国歌 大调、变奏曲式、</p>
<h3 id="（二）海顿的交响乐">（二）海顿的交响乐</h3>
<h4 id="海顿《G大调第94（惊愕）交响曲》（含引子）">海顿《G大调第94（惊愕）交响曲》（含引子）</h4>
<p>四个乐章</p>
<ul>
<li>
<p>第一乐章：快板（奏鸣曲快板）</p>
</li>
<li>
<p>第二乐章：慢板（主题与变奏）</p>
<p>变奏曲旋律</p>
<ul>
<li>
<p>简单的旋律</p>
</li>
<li>
<p>容易记住的主题如：流行曲调、国歌</p>
<p>变奏曲主题：奥地利民歌《小星星》</p>
</li>
</ul>
</li>
<li>
<p>第三乐章：小步舞曲（三声中部）</p>
<p>三部曲式</p>
<p>A（小步舞曲）B（三声中部）A（小步舞曲）</p>
</li>
<li>
<p>第四乐章：快板（奏鸣曲快板）</p>
</li>
</ul>
<p>只有在第四乐章后才可以鼓掌</p>
<h2 id="四、“音乐神童”莫扎特">四、“音乐神童”莫扎特</h2>
<p>早期  跟随家人四处巡演</p>
<p>中期（1774-1781）主要在科洛雷多亲王府工作</p>
<p>晚期（1781-1791）自由的艺术家</p>
<p>早期学徒（1756-1774）</p>
<p>音乐神童</p>
<ul>
<li>出色的钢琴家、小提琴家</li>
<li>优秀的耳朵（固定音高-音准）</li>
<li>即兴演奏和即兴创作的能力</li>
<li>非凡的记忆（教堂弥撒）</li>
<li>作曲速度</li>
</ul>
<h3 id="（一）莫扎特的喜歌剧">（一）莫扎特的喜歌剧</h3>
<p>意大利喜歌剧：</p>
<ul>
<li>《唐璜》</li>
<li>《女人心》</li>
<li>《费加罗婚礼》</li>
</ul>
<p>德国歌唱剧：</p>
<ul>
<li>《魔笛》</li>
</ul>
<p>莫扎特被后人成为“意大利喜歌剧之王”</p>
<h4 id="意大利喜歌剧和意大利正歌剧不同？">意大利喜歌剧和意大利正歌剧不同？</h4>
<p>《费加罗的婚礼》第三幕</p>
<p>西风吹拂-二重唱-苏珊娜与夫人</p>
<p><strong>意大利喜歌剧增加了重唱，最多七重唱</strong></p>
<p>名剧赏析：《费加罗的婚礼》</p>
<p>意大利喜歌剧的特点</p>
<ul>
<li>内容：普通人物</li>
<li>序曲：奏鸣曲式快板</li>
<li>急口令：喜歌剧独有</li>
<li>创新：引入“多声部声乐重唱”</li>
<li>羽管键琴：为宣叙调伴奏</li>
</ul>
<h3 id="（二）钢琴协奏曲之父">（二）钢琴协奏曲之父</h3>
<p>协奏曲特点</p>
<ol>
<li>
<p>奏鸣曲式快板结构——独奏乐队和合奏乐队轮流演奏，双呈示部</p>
</li>
<li>
<p>华彩乐段：用一个和弦把乐队收住，开始炫技；用颤音提示乐队进入</p>
</li>
<li>
<p>根据观众的不同谱写不同的华彩篇章——多种版本</p>
</li>
<li>
<p>作品编号：k</p>
</li>
</ol>
<p>莫扎特《d小调（第20）钢琴协奏曲》第一乐章</p>
<ul>
<li>
<p>套曲：共三个乐章：快板——慢板——快板</p>
</li>
<li>
<p>奏鸣曲式快板（双呈示部）：第一乐章</p>
</li>
<li>
<p>三者合一：作曲家、指挥、演奏者</p>
</li>
<li>
<p>华彩乐章：一个和弦…装饰音</p>
</li>
</ul>
<p>同时，莫扎特为各种乐器创作协奏曲</p>
<h3 id="（三）莫扎特的室内乐">（三）莫扎特的室内乐</h3>
<p>（1）莫扎特：弦乐四重奏</p>
<p>莫扎特《第17号弦乐四重奏（狩猎）》第二乐章：小步舞曲</p>
<p>曲式结构：（带三声中部的小步舞曲）</p>
<p>(A A B A B A) (C C D C D C) (A B A)</p>
<p>（2）莫扎特的五重奏</p>
<h3 id="（四）莫扎特的交响曲">（四）莫扎特的交响曲</h3>
<p>莫扎特《G小调第40交响曲》第一乐章</p>
<p>音乐节奏非常快，伴奏从疏到密，使乐曲既快乐又悲伤</p>
<h3 id="（五）莫扎特钢琴音乐">（五）莫扎特钢琴音乐</h3>
<p>羽管键琴与早期钢琴的比较</p>
<ul>
<li>巴洛克：羽管键琴，金属音</li>
<li>古典时期：早期钢琴，有强弱对比</li>
</ul>
<p>莫扎特《土耳其交响曲》</p>
<ul>
<li>曲式结构：回旋曲式</li>
</ul>
<h2 id="五、乐圣——贝多芬">五、乐圣——贝多芬</h2>
<p>贝多芬创作的第一阶段（1802年之前）</p>
<p>（一）贝多芬钢琴奏鸣曲</p>
<hr>
<p>这节课一直在忙工作的东西</p>
<p>什么东西都没记</p>
<p>要亖力……</p>
<hr>
<h1>第四章：浪漫主义时期</h1>
<h2 id="一、浪漫音乐风格与表演实践">一、浪漫音乐风格与表演实践</h2>
<h3 id="速度-2">速度</h3>
<p>浪漫派作曲家常常在乐谱上标注速度</p>
<p>自由速度</p>
<h3 id="和声-2">和声</h3>
<p>三个特点：</p>
<ul>
<li>半音和声</li>
<li>大胆的和弦转换</li>
<li>不和谐和弦——持续的时间更长</li>
</ul>
<h3 id="调式、调性">调式、调性</h3>
<p>半音和声：转调、离调变得非常频繁</p>
<p>转调：终止式</p>
<p>离调：短暂的离开</p>
<h3 id="力度">力度</h3>
<p>自由速度处理——由于力度的波动而加强</p>
<p>速度放慢——力度减弱</p>
<p>速度加快——力度渐强</p>
<p>勃拉姆斯《匈牙利舞曲第19号》</p>
<p>ffff~pppp</p>
<p>谱面上的力度记号——明确、强烈</p>
<h2 id="二、艺术歌曲">二、艺术歌曲</h2>
<p>浪漫主义时期特征之一：加速了对文学的兴趣</p>
<h3 id="舒伯特：被后人成为“歌曲之王”">舒伯特：被后人成为“歌曲之王”</h3>
<p>艺术歌曲特点：</p>
<ol>
<li>歌词：主要采用诗人的诗作</li>
<li>钢琴伴奏：伴奏起到烘托背景的作用</li>
<li>歌唱：意大利美声唱法</li>
</ol>
<h3 id="舒曼歌曲《桃金娘》——献给妻子克拉拉">舒曼歌曲《桃金娘》——献给妻子克拉拉</h3>
<p>曲式结构：ABA三段式</p>
<p>降A大调——降E大调（半音）</p>
<h2 id="三、音乐会序曲">三、音乐会序曲</h2>
<p>特点：单音节的标题音乐</p>
<p>门德尔松音乐特点：甜得发蜜</p>
<p>《仲夏夜之梦序曲》被成为<strong>音乐史上第一部浪漫主义标题行音乐会序曲</strong></p>
<h2 id="四、浪漫主义标题音乐">四、浪漫主义标题音乐</h2>
<p>19世纪浪漫主义时期被称为“标题音乐的时代”</p>
<h3 id="标题交响曲">标题交响曲</h3>
<p>法国作曲家：埃克托·柏辽兹</p>
<p>《幻想交响曲》</p>
<ol>
<li>
<p>自传性质的作品</p>
</li>
<li>
<p>用标题概述作品内容</p>
<p>用文学的手法把<strong>主题</strong>和具体人物或<strong>反复出现的场景</strong>结合在一起</p>
</li>
<li>
<p>“固定乐思”成为衔接故事的有机结合物</p>
<p>贯穿在五个乐章之中</p>
</li>
<li>
<p>精彩的<strong>配器手法</strong></p>
<p>柏辽兹被尊称为“近代管弦乐之父”</p>
</li>
</ol>
<h3 id="交响诗">交响诗</h3>
<p>匈牙利作曲家：弗朗兹·李斯特</p>
<p>《前奏曲》 自由——奏鸣曲式结构</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>昇思MindSpore介绍</title>
    <url>/2024/07/10/%E6%98%87%E6%80%9DMindSpore%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="昇思MindSpore介绍">昇思MindSpore介绍</h2>
<blockquote>
<p>第一次浪潮：符号主义+逻辑推理</p>
<p>第二次浪潮：专家系统+机器学习</p>
<p>第三次浪潮：深度学习</p>
<p><strong>第四次浪潮：智能内容生成（chatGPT）</strong></p>
</blockquote>
<p>（重点：分布式并行，transformer配置文件、高性能推理）</p>
<p>一些吹捧昇思的内容…</p>
<h3 id="MindSpore-vs-PyTorch">MindSpore vs PyTorch</h3>
<p>MindSpore模型开发风格和PyTorch保持一致，部分API接口名称不同</p>
<ul>
<li>MindSpore继承Cell类，Pytorch继承Module类</li>
<li>MindSpore应用construct接口，pytorch应用forward接口</li>
<li>数据预处理方面，MS采用流水线形式，定义一系列数据操作，作用到数据集上<br>
PT采用多进程形式，目前也在推出流水线形式（TorchData)</li>
</ul>
<h3 id="acllite">acllite</h3>
<p>在华为Ascend AI处理器的开发环境中，<code>device</code>、<code>context</code>、<code>stream</code>和<code>resource</code>这几个概念是用于管理和组织计算资源的基本元素。</p>
<h4 id="1-Device（设备）">1. Device（设备）</h4>
<p><code>Device</code> 是计算的基本单元。每个 <code>device</code> 代表一个物理的Ascend AI处理器。初始化设备是执行计算任务的第一步。</p>
<h4 id="2-Context（上下文）">2. Context（上下文）</h4>
<p><code>Context</code> 是对设备上的计算环境的抽象。一个 <code>device</code> 可以包含一个或多个 <code>context</code>。<code>context</code> 提供了一个独立的执行环境，管理其内存和其他资源。多个 <code>context</code> 可以在同一个 <code>device</code> 上并行运行，彼此独立。</p>
<h4 id="3-Stream（流）">3. Stream（流）</h4>
<p><code>Stream</code> 是一种用于控制计算和内存操作的顺序的机制。一个 <code>context</code> 中可以包含一个或多个 <code>stream</code>。每个 <code>stream</code> 内的操作按顺序执行，但不同 <code>stream</code> 之间可以并行执行。<code>stream</code> 使得程序能够在同一个 <code>context</code> 中实现并行计算。</p>
<h4 id="4-Resource（资源）">4. Resource（资源）</h4>
<p><code>Resource</code> 包括内存、事件和其他硬件资源。这些资源在 <code>context</code> 和 <code>stream</code> 中被分配和管理，用于支持计算任务的执行。</p>
<h4 id="关系图">关系图</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device</span><br><span class="line">  └── Context</span><br><span class="line">        ├── Stream</span><br><span class="line">        │     ├── Resource</span><br><span class="line">        │     └── Resource</span><br><span class="line">        └── Stream</span><br><span class="line">              ├── Resource</span><br><span class="line">              └── Resource</span><br></pre></td></tr></table></figure>
<h4 id="示例代码">示例代码</h4>
<p>以下示例代码展示了如何在华为Ascend AI处理器环境中初始化设备、创建上下文和流，并分配资源：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> acl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 初始化ACL</span></span><br><span class="line">    acl.init()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置设备ID</span></span><br><span class="line">    device_id = <span class="number">0</span></span><br><span class="line">    acl.rt.set_device(device_id)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建上下文</span></span><br><span class="line">    context, ret = acl.rt.create_context(device_id)</span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;acl.rt.create_context failed with error code <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建流</span></span><br><span class="line">    stream, ret = acl.rt.create_stream(context)</span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;acl.rt.create_stream failed with error code <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 分配内存资源（示例）</span></span><br><span class="line">    input_size = <span class="number">1024</span></span><br><span class="line">    input_ptr, ret = acl.rt.malloc(input_size, acl.const.ACL_MEM_MALLOC_HUGE_FIRST)</span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&quot;acl.rt.malloc failed with error code <span class="subst">&#123;ret&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放资源</span></span><br><span class="line">    acl.rt.free(input_ptr)</span><br><span class="line">    acl.rt.destroy_stream(stream)</span><br><span class="line">    acl.rt.destroy_context(context)</span><br><span class="line">    acl.rt.reset_device(device_id)</span><br><span class="line">    acl.finalize()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>导入模型</p>
<ol>
<li>
<p>通过ms.export将已有权重导入成onnx形式的模型</p>
</li>
<li>
<p>使用atc工具将原始模型转化为om模型</p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>陈震：创业及并购经验分享</title>
    <url>/2023/11/24/%E9%99%88%E9%9C%87%EF%BC%9A%E5%88%9B%E4%B8%9A%E5%8F%8A%E5%B9%B6%E8%B4%AD%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1>陈震：创业及并购经验分享</h1>
<h2 id="个人经历">个人经历</h2>
<h3 id="学习方面">学习方面</h3>
<ul>
<li>2013年担任北航微软技术俱乐部主席，进入微软亚洲研究院实习（世界top公司CEO孵化基地，学长大力推荐）</li>
<li>2013年了解机器人定位导航系统，2015年产业大爆发抓住风口</li>
<li>2015保送”清华大学计算机系“硕士、研究生，机器人/人机交互方向</li>
<li>2021攻读”清华大学未来实验室“博士研究生，机器人/人机交互方向</li>
<li>本科进入”北航软件开发环境国家重点实验室“进行机器人定位导航技术及系统设计、开发等研究工作</li>
</ul>
<h3 id="创业方面">创业方面</h3>
<ul>
<li>2014年创立“速感科技”任CEO</li>
<li>2017年全国互联网+创业大赛金奖（第二名）</li>
<li>2018年福布斯亚洲30Under30，北京市中关村“高举工程”高端领军人才</li>
<li>2019年北京市优秀人才（青年骨干个人）</li>
<li>2020年1月“速感科技”被JS全资收购</li>
<li>2021年10月任九阳（北京）产品负责人</li>
<li>2023年1月，二次创业，创办“享刻智能”，专注人工智能在厨房场景的落地及应用</li>
</ul>
<h2 id="速感科技：2014-2020">速感科技：2014~2020</h2>
<h3 id="时间线">时间线</h3>
<p>大二下加入软国重，获得冯如杯一等奖</p>
<p>开始在中国技术创业社区、媒体演讲“vSLAM”技术及其重要作用</p>
<p>2014年，获得超过百万的投资，租小办公室</p>
<p>2014~2015，密集的路演和融资计划讨论</p>
<p><s>锦秋家园，互联网公司的风水宝地</s></p>
<p>2015~2016，参加创业邦Demo China大赛，获得美国中经合集团A轮投资</p>
<p>扫地机器人技术迭代：无规则运动–&gt;惯性导航–&gt;有slam技术的第三代扫地机器人</p>
<p>2016~2017，迅速推出大量家用清洁机器人</p>
<p>2017~2018，参加美国拉斯维加斯消费电子展，获得头部公司关注</p>
<p>2018~2019，与大量公司进行合作洽谈；与shark|ninja公司合作推出扫地机器人，占领大量北美市场</p>
<p>2019~2020，SharkNinja正式对速感提出收购意向；同时资金流出现严重问题，拖延交易谈判进度；2020年1月正式签署收购协议，（2.1亿）</p>
<h3 id="核心观点：为什么同意并购">核心观点：为什么同意并购</h3>
<ol>
<li>2019年，家用扫地机器人没有保持高增长态势，团队担心行业增长到达顶峰</li>
<li>当时行业入局者纷至沓来，核心技术的优势和行业壁垒快速降低。行业过度分化导致无法“赚大钱”</li>
<li>当时行业的主导公司iRobot存在技术和市场两方面问题，速感科技和SharkNinja的合作能够打破对手的防守</li>
<li>一个学生团队是存在天花板的，并购才能打破僵局</li>
</ol>
<h3 id="总结感想">总结感想</h3>
<ol>
<li>作为典型的学生创业，核心团队从朋友创业到市场化运营需要不断变化</li>
<li>资本市场的加持使得资源获得更加容易，而非单单是货币的支持（当然货币支持也很重要）</li>
<li>创始人的意志和对行业的判断极其重要</li>
</ol>
<h2 id="如何看待并购">如何看待并购</h2>
<ol>
<li>
<p>并购成为技术型创业公司的重要退出方式</p>
</li>
<li>
<p>上市并非一片坦途</p>
<p>科沃斯、石头科技、商汤科技市值纷纷跳水</p>
</li>
<li>
<p>正确地表达传递信息至关重要</p>
<ul>
<li>选修交流谈判相关课程</li>
<li>观看《硅谷传奇》（）</li>
<li>知道自己的底线，维护核心利益，做好团队内部沟通</li>
</ul>
</li>
</ol>
<h2 id="享刻智能">享刻智能</h2>
<p>经过思考，陈震学长认为具身智能模型及系统有可能带来与vSlam相似的成功，于是创办了享刻智能公司</p>
<p>使机器人具备自主思考及行动能力，具体在厨房行业进行实践</p>
<p>新公司董事会</p>
<ol>
<li>学长北航导师</li>
<li>学长清华导师</li>
<li>九阳公司董事</li>
<li>SharkNinja机器人事业部CTO</li>
</ol>
<h2 id="最后总结">最后总结</h2>
<h3 id="无法复制">无法复制</h3>
<ol>
<li>无法复刻“大众创新，万众创业”的社会趋势</li>
<li>无法复刻2013年的美元体系</li>
</ol>
<h3 id="可以复制">可以复制</h3>
<ol>
<li>抓住行业趋势，<strong>顺势而为</strong></li>
<li>思考未来身份，<strong>掌控大局</strong></li>
<li>格局、视野、勇气</li>
</ol>
<h2 id="同学提问">同学提问</h2>
<ol>
<li>
<p>为什么选择厨房这个场景？除了厨房还有什么行业可以应用具身智能？</p>
<ol>
<li>对厨房场景了解；认为厨房行业（如茶艺、预置菜、餐饮）当下成本较高，具身智能在厨房行业依然有较大潜力；在传统万亿级行业赛道利用新技术出现的窗口期进行弯道超车；需要成本的大幅降低和鲁棒性大幅提升以抢占市场</li>
<li>家政服务；类人型通用机器人</li>
</ol>
</li>
<li>
<p>创业时还没有本科毕业，如何从技术团队转变成管理团队？（周学长太强了吧）</p>
<ul>
<li>并行地做科研和管理，不需要太多担心</li>
<li>快速学习的能力，快速弥补不足</li>
</ul>
</li>
<li>
<p>对创新创业有一定向往，对缺乏核心技术，如何走出困境？</p>
<ul>
<li>大学中对未来迷茫是正常现象</li>
<li>要和更多比你年长的学长交流，以了解未来的发展，辅助决策</li>
</ul>
</li>
<li>
<p>计算机系的学生如何寻求在机器人行业找突破点</p>
<p>具身智能、视觉推演、人工智能会是大爆发</p>
</li>
</ol>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>许可：关于算法的一些思考</title>
    <url>/2024/09/02/%E8%AE%B8%E5%8F%AF%EF%BC%9A%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h1>许可：关于算法的一些思考</h1>
<blockquote>
<p>时隔一年，终于又听到许可老师讲课了</p>
</blockquote>
<h2 id="计算机学科的算法研究简介">计算机学科的算法研究简介</h2>
<h3 id="最大团问题的思考">最大团问题的思考</h3>
<h4 id="计算机学科关于算法的定义">计算机学科关于算法的定义</h4>
<p>算法：设计<strong>有限条</strong>规则或指令的<strong>序列</strong>，在<strong>有限步</strong>得到正确的输出</p>
<h4 id="最大团问题">最大团问题</h4>
<p>给定一个图，寻找一个含<strong>顶点数最多</strong>的团</p>
<h4 id="如何评价算法的优劣">如何评价算法的优劣</h4>
<ol>
<li>理论分析<br>
严格，实际不可行</li>
<li>算法标准测试集<br>
1992-1993，美国离散数学与理论计算机科学中心，DIMACS<br>
2004-2005，许可，BHOSLIB</li>
</ol>
<h4 id="最大团的20年挑战难题">最大团的20年挑战难题</h4>
<table>
<thead>
<tr>
<th>时间</th>
<th>成绩</th>
</tr>
</thead>
<tbody>
<tr>
<td>2005.02</td>
<td>许可教授构造4000顶点，最大团100点的图</td>
</tr>
<tr>
<td>2005</td>
<td>找到96个点</td>
</tr>
<tr>
<td>2007</td>
<td>找到97个点</td>
</tr>
<tr>
<td>2010</td>
<td>找到98个点</td>
</tr>
<tr>
<td>2011</td>
<td>找到98个点</td>
</tr>
<tr>
<td>2014</td>
<td>找到99个点</td>
</tr>
</tbody>
</table>
<h3 id="P-NP问题的思考">P/NP问题的思考</h3>
<h4 id="计算是科学吗？">计算是科学吗？</h4>
<p>维特根斯坦 vs 图灵<br>
维特根斯坦：物理命题包含时间因素，而数学命题不包含时间因素<br>
图灵：如果说一个数学命题很难呢?<br>
<strong>计算不是数学，也不是物理，可以说计算形似数学，神似物理（是客观存在的基本规律，且用逻辑的方式证明）</strong></p>
<h4 id="P-NP问题">P/NP问题</h4>
<p>P=求出的问题的解很容易<br>
NP=验证问题的解很容易<br>
容易验证的问题是否也容易求解？</p>
<h4 id="NP完全问题">NP完全问题</h4>
<p>NP，即 Nondeterministic Polynomial time（非确定性多项式时间）<br>
对于一个问题，如果存在一个算法能够在多项式时间内验证一个给定的解是否正确，那么这个问题就属于 NP 类</p>
<h4 id="NP完全问题的里程碑">NP完全问题的里程碑</h4>
<p>1971 Cook-Levin定理<br>
1972 21个NP完全问题<br>
1979 NP完全问题的书</p>
<h4 id="人工智能会取代天才吗？">人工智能会取代天才吗？</h4>
<p>天才具有创造力 vs 常人欣赏创造力<br>
从计算机来看是否有本质区别？</p>
<h4 id="难解问题的本质">难解问题的本质</h4>
<p>算法的本质就是机械性<br>
算法设计的本质就是压缩<br>
计算复杂性的本质就是压缩的极限<br>
组合问题都能压缩吗？是否存在不可压缩的组合问题？</p>
<h4 id="算法发展的两条路线及趋势">算法发展的两条路线及趋势</h4>
<p>图像分类问题<br>
问题的描述依赖与暑假，无法抽象定义为一个数学问题</p>
<h4 id="算法研究的两条路线">算法研究的两条路线</h4>
<p>数据—&gt;问题—&gt;算法<br>
算法是语法的有穷序列，设计算法就是用语法代替语义<br>
优化算法属于理性主义，以语义为中心<br>
学习算法属于经验主义，以数据为中心</p>
<h4 id="学习还是优化">学习还是优化</h4>
<ul>
<li>基于大数据的算法设计方法提高了算法的生产效率，带来了算法偏见和算法黑箱问题</li>
<li>学习还是优化，这是个问题</li>
</ul>
<h4 id="学习与优化终有一战">学习与优化终有一战</h4>
<p>背景：大数据被大公司垄断<br>
关系到数据霸权能否被打破</p>
<h4 id="优化算法求解极其学习问题">优化算法求解极其学习问题</h4>
<p>基于结构信息原理的结构优化算法不依赖数据<br>
人天生具有对全局信息的处理能力</p>
<h2 id="我的思考">我的思考</h2>
<p>去年的这个时候，我和一群当时大三的同学们坐在教三的某个屋子中，同样听许老师讲同样题目的讲座。犹记得去年我听后的感受只有无限的膜拜与敬仰，被许老师身上的书生气深深折服，今年不止于此，也多了一份别的感受。</p>
<p>其实许老师的讲座全程只回答了两个问题：为什么学习类方法会占优？为什么要坚持优化类方法？结合许老师所讲内容，我认为：当前人类所面对的问题，不是人脑能通过整合全局信息而找到最优化方法的（特别是np hard问题），所以机器学习这种黑箱方法便会大行其道。学习类方法占据市场带来的恶性效应便是数据成为了算法的衡量指标（参考百模大战），垄断大数据的大型公司便垄断了话语权。因此，更需要在这种情况下寻求不刚需数据的优化类方法的出路。</p>
<p>我在中学时是由衷地喜欢优化算法的：将O(n^2)一步步优化成O(nlog)的过程，对我来说充满着乐趣。然而大学后，身边的老师同学都在一股脑地搞学习，说这个才是未来。最近做课题时我也有些染上了这种”规矩“，觉得不是学习，就有些掉价。细细想来，如果我的眼界不被机器学习所限的话，一定能到更开阔的境界吧。</p>
<p>我不禁又想起许老师被很多知乎er抨击的<a href="https://zhuanlan.zhihu.com/p/656236500">GPT-4在97轮对话中探索世界难题，给出P≠NP结论</a>，这正是许老师的过人之处：他想用学习的方法反哺优化类算法，以推动优化算法边界的拓展。一年过去，再上谷歌学术搜索，《Large Language Model for Science: A Study on P vs. NP》被引用了14次，不知道许老师对这个结果是否会满意呢？希望有生之年，能有幸看到”轻舟已过万重山“的日子。</p>
<h2 id="最后附首诗">最后附首诗</h2>
<h3 id="三垂冈">三垂冈</h3>
<p>英雄立马起沙陀，奈此朱梁跋扈何。</p>
<p>只手难扶唐社稷，连城且拥晋山河。</p>
<p>风云帐下奇儿在，鼓角灯前老泪多。</p>
<p>萧瑟三垂冈畔路，至今人唱《百年歌》。</p>
<p>2024.9.2</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法设计与分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库Database课程笔记-BUAA</title>
    <url>/2025/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1>数据库Database课程笔记-BUAA</h1>
<h2 id="第一章-概述">第一章 概述</h2>
<blockquote>
<ul>
<li>
<p>数据库技术，是一种数据管理技术</p>
</li>
<li>
<p>数据库技术的软件实现就是DBMS（数据库管理系统）</p>
</li>
<li>
<p>数据库系统是在数据库管理系统基础上建立的具有数据处理功能的系统</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A[数据库系统]</span><br><span class="line">B[数据库]</span><br><span class="line">C[数据库管理系统（DBMS）]</span><br><span class="line">D[数据库技术]</span><br><span class="line">E[应用程序]</span><br><span class="line">F[数据管理技术]</span><br><span class="line">C&lt;-.数据处理.-&gt;B</span><br><span class="line">C--数据管理--&gt;A</span><br><span class="line">B--&gt;A</span><br><span class="line">E--&gt;A</span><br><span class="line">D--软件实现--&gt;C</span><br><span class="line">D--属于--&gt;F</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="数据管理技术的发展">数据管理技术的发展</h3>
<blockquote>
<p>数据库与其它数据管理技术相比有什么特点？</p>
<p>数据库技术要解决的基本问题是什么？</p>
</blockquote>
<h4 id="数据库技术产生与发展背景">数据库技术产生与发展背景</h4>
<ul>
<li>1960s 操作系统、算法与数据结构、软件工程日趋成熟，出现数据库技术（业务数据处理）（科学计算）</li>
<li>层次、网状、关系三类数据库经过发展，关系数据库最终成为主流</li>
<li>今天 出现NewSQL、NoSQL（延申到智能化数据处理领域）</li>
</ul>
<h4 id="数据管理技术的发展过程">数据管理技术的发展过程</h4>
<ul>
<li>
<p>人工管理阶段</p>
<ul>
<li>
<p>时间：&lt;1950s</p>
<ul>
<li>
<p>背景：只有磁带、卡片等；没有操作系统；主要用于科学计算</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>数据不在计算机上存储</p>
</li>
<li>
<p>程序规定数据的逻辑结构与物理结构，数据与程序不具有独立性（由程序员设计）</p>
</li>
<li>
<p>应用程序与数据组一一对应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[应用程序1]-.-D[文件1]</span><br><span class="line">B[应用程序2]-.-E[文件2]</span><br><span class="line">C[应用程序3]-.-F[文件3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统阶段</p>
<ul>
<li>
<p>时间：1950s-1960s</p>
<ul>
<li>
<p>背景：出现磁盘、磁鼓；出现文件系统；计算机不但用于科学计算，还用于管理</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>
<p>数据以文件形式保留在外存上</p>
</li>
<li>
<p>数据存取以记录为单位</p>
</li>
<li>
<p>程序与数据有一定独立性</p>
</li>
<li>
<p>文件与程序基本上是一一对应关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">G[存取系统]</span><br><span class="line">A[应用程序1]-.-G-.-D[文件1]</span><br><span class="line">B[应用程序2]-.-G-.-E[文件2]</span><br><span class="line">C[应用程序3]-.-G-.-F[文件3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​</p>
<pre><code>* 问题：数据冗余度大、存储空间浪费、易造成数据的不一致性、维护难度大
</code></pre>
<ul>
<li>数据库系统阶段</li>
</ul>
<h4 id="数据库系统基本问题与关键技术">数据库系统基本问题与关键技术</h4>
<ul>
<li>需求：
<ul>
<li>集成：将特定应用环境中的所有相关的数据，进行统一地、集中地按照一定数据结构进行存储</li>
<li>共享：数据可为多个不同的用户所共享</li>
</ul>
</li>
<li>核心技术：
<ul>
<li>数据模型</li>
<li>数据独立性</li>
</ul>
</li>
<li>核心软件：数据库管理系统DBMS（Database Manage System）
<ul>
<li>最早的DBMS——IMS，IDS</li>
<li>查尔斯·巴赫曼 数据库技术之父：在《IDS与DBTG报告》中提出“<strong>三级模式、两级映像</strong>”</li>
</ul>
</li>
</ul>
<h4 id="数据库系统数据管理特点">数据库系统数据管理特点</h4>
<ul>
<li>
<p>面向全组织的复杂的数据结构</p>
<ul>
<li>
<p>在描述数据时，不仅描述数据本身，还要描述数据之间的联系，使整个组织的<strong>数据结构化</strong></p>
</li>
<li>
<p>数据库与文件系统的根本区别</p>
</li>
</ul>
</li>
<li>
<p>数据冗余度小，易扩充</p>
<ul>
<li>
<p>数据库可以随时选择子集，灵活度高</p>
</li>
<li>
<p>具有较高的数据和程序的独立性</p>
<ul>
<li>
<p>三级模式、两级映像</p>
</li>
<li>
<pre><code class="language-mermaid">graph BT
a[应用1]
b[应用2]
c[应用3]
d[应用4]
e[局部逻辑结构（外模式1）]
f[局部逻辑结构（外模式2）]
g[全局逻辑结构（模式）]
h[物理结构（内模式）]
i[数据库]
e--&gt;a
e--&gt;b
f--&gt;c
f--&gt;d
g--外模式/模式映像1--&gt;e
g--外模式/模式映像2--&gt;f
h&lt;--模式/内模式映像--&gt;g
i&lt;--&gt;h
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* 统一的数据控制功能</span><br><span class="line"></span><br><span class="line">  * 数据的安全性控制（保护非法操作）</span><br><span class="line"></span><br><span class="line">  * 数据的完整性控制（数据的正确性）</span><br><span class="line"></span><br><span class="line">  * 并发控制</span><br><span class="line"></span><br><span class="line">  * 数据库恢复</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 数据的最小存取单位是数据项</span><br><span class="line">  * 既可以存取一个或一组记录，也可以存取数据中某个或一组数据项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 数据模型</span><br><span class="line"></span><br><span class="line">&gt; 数据库技术要解决的基本问题是什么？数据的集成问题</span><br><span class="line"></span><br><span class="line">#### 数据模型定义</span><br><span class="line"></span><br><span class="line">* 数据模型用来抽像和表示现实世界中的数据和信息</span><br><span class="line"></span><br><span class="line">* 目标：现实世界数据和机器世界数据的转换</span><br><span class="line"></span><br><span class="line">#### 数据模型的层次</span><br><span class="line"></span><br><span class="line">* 将现实世界业务的数据进行认识、抽象，转化为信息世界中的**概念模型**（也称信息模型）</span><br><span class="line">* 将概念模型转化为机器世界数据中的**数据模型**（如层次、网状、关系）</span><br><span class="line"></span><br><span class="line">#### 概念模型</span><br><span class="line"></span><br><span class="line">* 基于信息世界的概念，表达各种信息</span><br><span class="line">* 有较强的语义表达能力，简单、清晰、便于理解</span><br><span class="line">* 常用E-R法进行表示</span><br><span class="line"></span><br><span class="line">#### E-R法（Entity-Relation Approach）</span><br><span class="line"></span><br><span class="line">* 目标：描述显示世界，并转换成相应的数据模型</span><br><span class="line"></span><br><span class="line">* 基本概念</span><br><span class="line"></span><br><span class="line">  * **实体**（Entity）：客观存在并可相互区分的事物 **长方体**</span><br><span class="line"></span><br><span class="line">  * **属性**（Attribute）：实体所具有的某一特性 **椭圆形**</span><br><span class="line"></span><br><span class="line">  * **码/键**（Key）：唯一标识实体的属性集</span><br><span class="line"></span><br><span class="line">  * **域**（Domain）：某个属性的取值范围</span><br><span class="line"></span><br><span class="line">  * **实体型**（Entity Type）：表示一类实体，用实体名及其属性名集合来抽象、刻画</span><br><span class="line"></span><br><span class="line">  * **联系**（Relation）：实体型之间的联系，是实体之间的相互关联 **菱形**</span><br><span class="line">    * 名称</span><br><span class="line">    * 类型：一对一、一对多、多对多</span><br><span class="line">    * 可以具有属性</span><br><span class="line"></span><br><span class="line">* 联系的语义扩充</span><br><span class="line"></span><br><span class="line">  &gt; 我从没在这章以外的题目中碰到这几个</span><br><span class="line"></span><br><span class="line">  * 存在依赖</span><br><span class="line">    某实体存在依赖于另一实体的存在，称该实体为弱实体，该实体**存在依赖**另一实体</span><br><span class="line">  * 标识依赖</span><br><span class="line">    如果实体不能由它自己的属性来唯一标识，而必须通过与它相联系的另一实体一起来标识 ，那么称该实体**标识依赖**于另一个实体</span><br><span class="line">  * 实体的子类</span><br><span class="line">    子类可以继承父类属性，并定义自己的属性；子类间交集不一定为空</span><br><span class="line"></span><br><span class="line">* 注意：</span><br><span class="line"></span><br><span class="line">  * 同一个实体机内部各实体之间也可以存在不同类型的联系</span><br><span class="line">  * 三个或多个实体型间可能具有联系（按语义确定类型）</span><br><span class="line">  * 两个实体型之间可具有多种联系</span><br><span class="line"></span><br><span class="line">#### 数据模型</span><br><span class="line"></span><br><span class="line">* 定义：数据模型是概念的集合，精确描述数据库系统的**静态特性、动态特性和完整性约束**</span><br><span class="line">* 三要素：数据结构、数据操作、完整性约束</span><br><span class="line">* 数据结构（怎么存）</span><br><span class="line">  * 由描述数据对象以及对象之间联系的一组概念组成</span><br><span class="line">  * 描述对象的类型、内容、性质的概念，如关系模型中的域、属性等；描述对象之间联系的概念，如关系模型中的关系</span><br><span class="line">  * 是数据**静态特性**的描述</span><br><span class="line">  * 是刻画数据模型**最重要**的方法，通常按照数据结构的类型来命名数据模型</span><br><span class="line">* 数据操作（怎么改）</span><br><span class="line">  * 是对数据库中各种数据对象（型）的实例（值）允许执行的操作集合，包括操作及操作规则</span><br><span class="line">  * 定义操作的确切含义、操作符号、操作规则及操作语言</span><br><span class="line">  * 是数据**动态特性**的描述</span><br><span class="line">  * 数据库主要有**检索和更新**（插、删、改）两大类操作</span><br><span class="line">* 完整性约束</span><br><span class="line">  * 是**完整性规则**的集合</span><br><span class="line">  * 完整性规则是给定的数据模型中数据及其联系所有的制约和依存规则，用以保证数据的正确、相容；</span><br><span class="line">  * 完整约束条件包括：</span><br><span class="line">    * 符合这种数据模型所必须遵守的基本的通用的完整性约束条件</span><br><span class="line">    * 针对具体数据的特定语义约束条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据模型的分类</span><br><span class="line"></span><br><span class="line">* 层次模型</span><br><span class="line">  * ”树结构“表示联系</span><br><span class="line">* 网状模型</span><br><span class="line">  * ”图结构“表示联系</span><br><span class="line">* 关系模型</span><br><span class="line">  * ”二维表“表示联系</span><br><span class="line">  * 关系中的每个分量是不可分的数据项</span><br><span class="line"></span><br><span class="line">### 数据库系统结构</span><br><span class="line"></span><br><span class="line">&gt; 有效解决这些问题的技术是什么？</span><br><span class="line"></span><br><span class="line">#### 逻辑结构 vs. 物理结构</span><br><span class="line"></span><br><span class="line">* 逻辑结构：数据在程序中定义的结构</span><br><span class="line">* 物理结构：文件在存储介质上的结构</span><br><span class="line"></span><br><span class="line">#### 数据独立性</span><br><span class="line"></span><br><span class="line">&gt; 解决数据库的共享问题</span><br><span class="line"></span><br><span class="line">* 数据独立性由数据和程序共同决定</span><br><span class="line">* 如果数据**物理结构**改变，不需要修改程序，则有**物理独立性**（通过文件系统解决）</span><br><span class="line">* 如果数据**逻辑结构**改变，不需要修改程序，则有**逻辑独立性**（通过SQL解决）</span><br><span class="line">* 如果修改数据，则必须修改程序，则无数据独立性（如果不具有物理独立性或逻辑独立性，则无数据独立性）</span><br><span class="line"></span><br><span class="line">#### 三级模式、两级映像</span><br><span class="line"></span><br><span class="line">* 用于实现物理独立性及逻辑独立性</span><br><span class="line"></span><br><span class="line">* 数据库结构多层次抽象，层次之间建立映射/对应关系</span><br><span class="line"></span><br><span class="line">* ```mermaid</span><br><span class="line">  graph BT</span><br><span class="line">  a[应用1]</span><br><span class="line">  b[应用2]</span><br><span class="line">  c[应用3]</span><br><span class="line">  d[应用4]</span><br><span class="line">  e[局部逻辑结构（外模式1）]</span><br><span class="line">  f[局部逻辑结构（外模式2）]</span><br><span class="line">  g[全局逻辑结构（模式）]</span><br><span class="line">  h[物理结构（内模式）]</span><br><span class="line">  i[数据库]</span><br><span class="line">  e--&gt;a</span><br><span class="line">  e--&gt;b</span><br><span class="line">  f--&gt;c</span><br><span class="line">  f--&gt;d</span><br><span class="line">  g--外模式/模式映像1--&gt;e</span><br><span class="line">  g--外模式/模式映像2--&gt;f</span><br><span class="line">  h&lt;--模式/内模式映像--&gt;g</span><br><span class="line">  i&lt;--&gt;h</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库由OS管理，其它部分由DBMS管理；OS和DBMS统一由DBA管理</p>
</li>
<li>
<p><strong>模式</strong></p>
<ul>
<li>是数据库中全体数据的<strong>逻辑结构和特性</strong>的描述</li>
<li>是所有用户的公共数据视图</li>
<li>也称为逻辑模式、概念模式</li>
<li>用DDL（Data Description Language）进行定义</li>
<li>三级模式的<strong>核心</strong></li>
</ul>
</li>
<li>
<p><strong>外模式</strong></p>
<ul>
<li>与某一特定应用有关的数据的逻辑表示</li>
<li>是个别用户的数据视图</li>
<li>也称为子模式、用户模式</li>
<li>通常是<strong>模式的子集</strong></li>
</ul>
</li>
<li>
<p><strong>内模式</strong></p>
<ul>
<li>对数据的<strong>物理结构和存储方式</strong>的描述</li>
<li>通常用内模式DDL定义</li>
<li>我们程序员不用管🐶</li>
</ul>
</li>
<li>
<p>外模式/模式映像</p>
<ul>
<li>解决数据的逻辑独立性</li>
</ul>
</li>
<li>
<p>模式/内模式映像</p>
<ul>
<li>解决数据的物理独立性</li>
</ul>
</li>
<li>
<p>优点</p>
<ul>
<li>保证数据的独立性</li>
<li>简化用户接口，方便用户使用</li>
<li>有利于数据共享</li>
<li>有利于数据的安全保密</li>
</ul>
</li>
</ul>
<h4 id="DBMS主要功能">DBMS主要功能</h4>
<blockquote>
<p>DBMS是数据库系统的核心软件，在操作系统的支持下工作</p>
</blockquote>
<ul>
<li>数据库定义功能
<ul>
<li>提供DDL语言描述外模式、模式、内模式</li>
<li><strong>模式翻译程序</strong>将源模式翻译成目标模式</li>
</ul>
</li>
<li>数据存取功能
<ul>
<li>提供DML语言（Data manipulation language）对数据库进行检索、插入、修改、删除</li>
</ul>
</li>
<li>数据库运行管理
<ul>
<li>并发控制、存取控制、完整性约束条件检查和执行，日志组织和管理，事务管理和自动恢复</li>
</ul>
</li>
<li>数据组织、存储和管理</li>
<li>数据库的建立和维护功能</li>
</ul>
<h2 id="第二章-关系数据库">第二章 关系数据库</h2>
<blockquote>
<p>E.F.Codd于70年代初提出关系数据模型与关系数据理论，因此获得1981年的ACM图灵奖</p>
<p>~~没想到四十多年后的今天我还在学这个（吐槽）~~🥹</p>
</blockquote>
<h3 id="引言">引言</h3>
<p>关系理论建立在集合代数理论基础上，有着坚实的数学基础</p>
<p>早期系统</p>
<ul>
<li>System R：IBM</li>
<li>INGRES：Berkeley</li>
</ul>
<p>目前主流系统</p>
<ul>
<li>Oracle、MySQL、PostgreSQL、DB2，SQL-Server等</li>
<li>国内：武汉达梦、人大金仓、华为OpenGauss</li>
</ul>
<p>GaussDB vs. OpenGauss</p>
<p>GaussDB：华为云数据库统称，包括多个版本，如 GaussDB(for MySQL)、GaussDB(for PostgreSQL) 等</p>
<p>OpenGauss：基于 PostgreSQL 的扩展和优化的开源数据库系统</p>
<hr>
<blockquote>
<p>关系数据模型是如何定义的？</p>
<p>关系模型的优点和缺点是什么？</p>
</blockquote>
<h3 id="关系模型的基本概念">关系模型的基本概念</h3>
<h4 id="关系的数学定义">关系的数学定义</h4>
<ul>
<li>
<p><strong>域（Domain）</strong><br>
一组具有相同数据类型值的集合</p>
</li>
<li>
<p><strong>元组</strong>和<strong>分量</strong><br>
给定一组域$D1,D2…$，$D1\times D2…$得到的笛卡尔积的每个元素$(d_1,d_2,…)$称为n元组（n-tuple），或简称<strong>元组</strong>，元组的每一个值$d_k$叫做<strong>分量</strong>，分量不可分</p>
</li>
<li>
<p>笛卡尔积可以表示为二维表<br>
关系也被称为二维表</p>
<table>
<thead>
<tr>
<th>$D_1$</th>
<th>$D2$</th>
<th>…</th>
<th>$D_n$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$d_1$</td>
<td>$d_2$</td>
<td>…</td>
<td>$d_n$</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>关系</strong><br>
笛卡尔积叫做在域$D_1, D_2…D_n$上的<strong>关系</strong>，用$R(D_1,D_2,…D_n)$表示<br>
n=1，单元关系<br>
n=2，二元关系<br>
二维表的每列称为<strong>属性(Attribute)</strong></p>
</li>
</ul>
<h4 id="关系的性质">关系的性质</h4>
<ul>
<li>列是同质的（Homogenenux），即每一列中的分量来自同一域</li>
<li>不同列可以出自同一域，每列必须有不同的属性名</li>
<li>行、列次序可以互换</li>
<li>任意两个元组不能完全相同</li>
<li>每一分量必须是不可再分的数据，满足这一条件的关系称为满足**第一范式（1NF）**的<br>
eg. 若某分量为二元组（a1, a2），则不满足第一范式</li>
</ul>
<h4 id="关系模型的数据结构">关系模型的数据结构</h4>
<blockquote>
<p>关系模型的数据结构就是“关系”</p>
</blockquote>
<ul>
<li>
<p>关系</p>
<ul>
<li>实体及实体之间的联系均用单一的数据结构——关系来约束</li>
</ul>
</li>
<li>
<p>基本概念</p>
<ul>
<li>
<p>关系、域、n目关系、元组、属性</p>
</li>
<li>
<p><strong>码（Key，键）</strong></p>
<ul>
<li><strong>候选码（Candidate key）</strong>：关系中的某一<strong>属性组</strong>，若它的值唯一地标识了一个元组，并具有<strong>最小性</strong>，则为<strong>候选码</strong></li>
<li><strong>主码（Primary key，首码，码）</strong>：若一个关系有多个候选码，则选择其中一个为<strong>主码</strong></li>
<li><strong>最小性</strong>：在保持唯一性的前提下，候选码不包含任何冗余属性。也就是说，如果从候选码中去掉任何一个属性，剩下的属性集将无法继续唯一标识数据记录。</li>
</ul>
</li>
<li>
<p><strong>主属性和非主属性</strong></p>
<ul>
<li>候选码中的属性称为<strong>主属性</strong>，否则为<strong>非主属性</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>关系模式</p>
<ul>
<li>作用：描述数据库的逻辑结构</li>
<li>形式化表示：$R(U, D, dom, F)$<br>
$R$：表示关系的名称，通常代表一个数据库表的名字<br>
$U$（Universe of attributes）：表示属性集合，包含该关系中的所有属性，每个属性对应数据库表中的一列<br>
$D$（Domains of attributes）：表示每个属性的定义域（Domain），即每个属性可以取的合法值的类型集合，更精简<br>
$dom$（Domain function）：表示一个映射函数，用于将每个属性映射到其对应的定义域，更精细<br>
$F$（Functional dependencies）：表示在该关系模式上定义的<strong>函数依赖集</strong>。函数依赖用于表示一个属性集如何函数性地决定另一个属性集</li>
<li>简记：$R(A_1,A_2…)$</li>
<li>关系是关系模式在某一时刻的状态或内容<br>
<strong>关系模式是静态的，关系是动态的</strong></li>
<li><strong>型</strong>：关系模式的集合构成关系数据库模式—关系数据库的型</li>
<li><strong>值</strong>：关系的集合则构成具体的关系数据库—关系数据库的值。</li>
</ul>
</li>
</ul>
<h4 id="关系模型的数据操作">关系模型的数据操作</h4>
<ul>
<li>
<p>特点：集合操作</p>
<ul>
<li>操作的对象和结果都是集合</li>
</ul>
</li>
<li>
<p>基础：关系运算</p>
<ul>
<li>
<p>关系运算分为代数方式和逻辑方式</p>
</li>
<li>
<pre><code class="language-mermaid">graph RL
A[关系代数（代数方式）]
B[关系演算（逻辑方式）]
C[元组关系演算]
D[域关系演算]
E[关系运算]
A---&gt;E
B---&gt;E
C---&gt;B
D---&gt;B
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  * 关系代数</span><br><span class="line"></span><br><span class="line">    * 常规集合运算：并、差、交、广义笛卡儿积（乘）</span><br><span class="line">    * 特有的关系运算：选择、投影、连接、自然连接、 求商</span><br><span class="line"></span><br><span class="line">  * 关系演算</span><br><span class="line"></span><br><span class="line">    * 元组演算：$\&#123;t\mid\Phi(t)\&#125;$</span><br><span class="line">    * 域关系演算：$\&#123;(x_1,x_2...\mid\Phi(x_1,x_2...)\&#125;$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 关系模型的语义约束（完整性约束）</span><br><span class="line"></span><br><span class="line">&gt; 关系模型必须支持实体完整性和参照完整性，可以支持用户定义完整性</span><br><span class="line"></span><br><span class="line">* 实体完整性（Entity Integrity）</span><br><span class="line">  * 主码不可为空或部分为空</span><br><span class="line">  * 空值：不知道或不存在的值</span><br><span class="line">* 参照完整性（Referential integrity）</span><br><span class="line">  * 若关系R的某个或某组关系F和关系S的主码相对应，则称F为关系R的**外部码（Foreign Key）**，并称R为**参照关系（Referencing Relation）**，S为被**参照关系（Referenced Relation）**或**目标关系（Target Relation）**；R和S不一定是不同的关系</span><br><span class="line">  * 相对应的含义：R的外码和S的主码定义在一个域上</span><br><span class="line">  * 参照完整性：若R的外码F和S的主码P相对应，则R中每一个元组的F值或者等于S中某元组的P值，或者为空值</span><br><span class="line"></span><br><span class="line">* 用户定义完整性</span><br><span class="line">  * 用户针对具体的应用环境定义的完整性约束</span><br><span class="line"></span><br><span class="line">### 关系代数</span><br><span class="line"></span><br><span class="line">&gt; 从数学角度，基本关系代数运算有：并、差、乘、选择、投影</span><br><span class="line">&gt;</span><br><span class="line">&gt; 从数据库角度，核心的关系代数运算为：选择、投影、连接（或自然连接）</span><br><span class="line"></span><br><span class="line">#### 传统集合运算</span><br><span class="line"></span><br><span class="line">* 并（Union）</span><br><span class="line">* 差（Defference）</span><br><span class="line">* 交（Intersection）</span><br><span class="line">* 广义笛卡儿积（Extended cartesian product）</span><br><span class="line">  * $R\times S = \&#123;t\mid t=&lt;r,s&gt;\and\ r\in R \and s\in S\&#125;$</span><br><span class="line"></span><br><span class="line">#### 专门的关系运算</span><br><span class="line"></span><br><span class="line">* 选取或限制（Selection or Restriction）</span><br><span class="line">  * $\sigma_F(R)=\&#123;t\mid t\in R,F(t)=\text&#123;True&#125;\&#125;$</span><br><span class="line">  * e.g. $\sigma_&#123;age=12&#125;(S)$</span><br><span class="line">* 投影（Projection)</span><br><span class="line">  * $\Pi_A(R)=\&#123;t[A]\mid t\in R, A\in U\&#125;$</span><br><span class="line">  * e.g. $\Pi_&#123;Name,Age&#125;(S)$</span><br><span class="line">  * 需要删去重复行</span><br><span class="line">* 连接（Join）</span><br><span class="line">  * $\underset&#123;X\theta Y&#125;&#123;R\bowtie S&#125; =\&#123;t\mid t=&lt;r,s&gt;\and r\in R \and s\in S \and r[X] \ \theta \ s[Y]\&#125;$</span><br><span class="line">* 自然连接（Natural Join）</span><br><span class="line">  * $R\bowtie S=\&#123;(Z,X,W)\mid (Z,X)\in R \and (X,W)\in S \and r[X] = s[X]\&#125;$</span><br><span class="line">  * 需要删去重复行</span><br><span class="line">  * 连接与自然连接</span><br><span class="line">    * 自然连接的结果要在上述R与S的等值连接结果基础上再进行投影运算，去掉重复的属性列</span><br><span class="line">* 除法（Divide）</span><br><span class="line">  * $R\div S = (t\mid t \in \Pi_x(R)\and s \in S\and &lt;t,s&gt; \in R)$</span><br><span class="line">  * 翻译：R中所有与S做笛卡尔积得到的关系包含在R中的关系</span><br><span class="line">  * ~~除法需要用乘法来定义，真是讽刺~~</span><br><span class="line"></span><br><span class="line">#### 优先级</span><br><span class="line"></span><br><span class="line">* 单目运算优先级最高，投影&gt;选取</span><br><span class="line">* 专门关系运算中的多目运算和笛卡尔积优先级其次</span><br><span class="line">* 传统集合运算中的多目运算除笛卡尔积外优先级最低</span><br><span class="line"></span><br><span class="line">### 元组关系演算与域关系演算</span><br><span class="line"></span><br><span class="line">&gt; 把谓词演算应用到关系运算中就是关系演算</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 以元组为变量，简称元组演算</span><br><span class="line">&gt; * 以域为变量，简称域演算</span><br><span class="line"></span><br><span class="line">#### 元组关系演算</span><br><span class="line"></span><br><span class="line">* 基本结构：元组演算表达式</span><br><span class="line">* 形式定义：$\&#123;t\mid\Phi(t)\&#125;$</span><br><span class="line">* 递归定义</span><br><span class="line">  1. 原子命题函数是公式，称为原子公式，原子公式有三类</span><br><span class="line">     * $R(t)$</span><br><span class="line">     * $t[i]\ \theta\  u[j]$</span><br><span class="line">     * $t[i]\ \theta\ c或c\ \theta\ t[i]$</span><br><span class="line">  2. 如果$\Phi_1$，$\Phi_2$是公式，则$\Phi_1\and\Phi_2,\Phi_1\or\Phi_2,\neg\Phi$也是公式</span><br><span class="line">  3. 如果$\Phi$是公式，则$\exist t(\Phi), \forall t(\Phi)$也是公式</span><br><span class="line"></span><br><span class="line">* 在元组演算公式中，各种运算符的优先次序为：</span><br><span class="line">  * 算术比较运算符最高</span><br><span class="line">  * 量词次之，且$\exist$的优先级高于$\forall$</span><br><span class="line">  * 逻辑运算符最低，且$\neg$优先级高于$\and$，$\and$高于$\or$</span><br><span class="line">  * 如果有括号，则括号中的运算优先级最高</span><br><span class="line"></span><br><span class="line">#### 域关系演算</span><br><span class="line"></span><br><span class="line">&gt; 其实就是不用数组的元组关系演算🤣</span><br><span class="line"></span><br><span class="line">* 形式定义：$\&#123;(x_1,x_2...\mid\Phi(x_1,x_2...)\&#125;$</span><br><span class="line">* 与元组关系演算有相同的运算符、相同的公式递归定义</span><br><span class="line"></span><br><span class="line">### 三类关系运算的安全约束及等价性</span><br><span class="line"></span><br><span class="line">#### 关系运算的安全约束</span><br><span class="line"></span><br><span class="line">* **安全运算**：关系运算中不产生无限关系和无穷验证的运算</span><br><span class="line">* **安全表达式**：**安全运算**的运算表达式</span><br><span class="line">* **安全约束**：对**安全运算**采取的限制</span><br><span class="line">* 关系代数是安全运算，关系演算则不一定是，所以对关系演算要进行安全约束</span><br><span class="line">  * 对$\Phi$定义一个优先的符号集$DOM(\Phi)$，使对$\Phi$的运算结果及中间结果所产生的关系及其 元组的各个分量都必须属于$DOM(\Phi)$</span><br><span class="line"></span><br><span class="line">#### 三类关系运算的等价性</span><br><span class="line"></span><br><span class="line">* 经过安全约束后的三类关系运算的表达能力是等价的，可以相互转换</span><br><span class="line"></span><br><span class="line">* ```mermaid</span><br><span class="line">  graph LR</span><br><span class="line">  A[关系代数表达式]&lt;--&gt;B[安全元组演算表达式]&lt;--&gt;C[安全域演算表达式]&lt;--&gt;A</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="关系数据语言概述">关系数据语言概述</h3>
<h4 id="数据库数据语言">数据库数据语言</h4>
<ul>
<li><strong>数据定义（描述）语言（Data definition or description language，DDL）</strong>
<ul>
<li>包括模式DDL，外模式DDL，内模式DDL</li>
</ul>
</li>
<li><strong>数据操纵语言（Data Manipulation Language，DML）</strong>
<ul>
<li>四种基本操作：检索、插入、修改、删除</li>
<li>DML有联机交互方式和宿主语言方式
<ul>
<li>联机交互方式：自含式语言，可独立使用，适用于终端直接查询</li>
<li>宿主语言方式：嵌入式语言，依附于宿主语言，嵌入高级语言的程序中，实现数据库操作</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据控制语言（Data Control Language，DCL）</strong>
<ul>
<li>完成数据库的安全性控制、完整性控制、并发控制</li>
</ul>
</li>
</ul>
<h4 id="关系数据语言特点及优点">关系数据语言特点及优点</h4>
<ul>
<li>特点
<ul>
<li>一体化
<ul>
<li>将数据的定义、查询、更新、控制等合为一体，只提供一种称之为“查询语言”的语言，便于用户学习使用</li>
</ul>
</li>
<li>非过程化
<ul>
<li>用户只需要决定“干什么”，具体“怎么干”由DBMS决定，使得语言操作简单、易学、易用</li>
</ul>
</li>
<li>面向集合的存取方式
<ul>
<li>操作的对象和结果都是关系</li>
</ul>
</li>
<li>既可独立使用又可与主语言嵌套使用</li>
</ul>
</li>
<li>优越性
<ul>
<li>关系模型采用了最简单的数据结构，使得DML大大简化</li>
<li>关系数据语言建立在关系运算的数学基础上，可以实现关系的垂直方向和水平方向的任意分割和组装操作，可构造出多样的新关系</li>
</ul>
</li>
</ul>
<h4 id="关系数据语言分类">关系数据语言分类</h4>
<blockquote>
<p>关系数据语言的核心是查询，所以又称为查询语言</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[关系代数]</span><br><span class="line">B[关系演算]</span><br><span class="line">C[元组关系演算]</span><br><span class="line">D[域关系演算]</span><br><span class="line">E[ISBL]</span><br><span class="line">F[ALPHA；QUEL]</span><br><span class="line">G[QBE]</span><br><span class="line">H[SQL]</span><br><span class="line">I[关系运算]</span><br><span class="line">I--&gt;A</span><br><span class="line">I--&gt;B</span><br><span class="line">A----&gt;E</span><br><span class="line">E---&gt;H</span><br><span class="line">F---&gt;H</span><br><span class="line">B--&gt;C---&gt;F</span><br><span class="line">B--&gt;D---&gt;G</span><br></pre></td></tr></table></figure>
<h3 id="关系模型的优点与缺点">关系模型的优点与缺点</h3>
<ul>
<li>
<p>优点</p>
<ul>
<li>建立在严格数学概念基础上，有严格的设计理论</li>
<li>概念单一，实体和联系都用关系描述，查询操作结果也是一个关系，保证了数据操作语言的一致性</li>
<li>数据结构简单直观、易理解、语言表达简洁</li>
<li>存取路径对用户透明，数据独立性更高，安全保密性更好,，简化了程序员和数据库开发建立的工作</li>
</ul>
</li>
<li>
<p>缺点</p>
<blockquote>
<p>随着各种查询优化的开发，劣势已经基本解决</p>
</blockquote>
<ul>
<li>由于存取路径对用户透明，查询效率不如层次、网状数据模型</li>
<li>为了提高性能，需要查询优化，增加数据库管理系统的开发难度</li>
</ul>
</li>
</ul>
<h2 id="第三章-关系数据库标准语言SQL">第三章 关系数据库标准语言SQL</h2>
<blockquote>
<ul>
<li>1974，由Chamberlin和Boyee提出，称为SEQUEL（Structured English Query Language），Chamberlin被称为SQL之父</li>
<li>1975-1979，在IBM的System R上实现</li>
<li>1981，IBM在推出SQL/DS关系数据库时，将其命名为SQL（Structured Query Language）</li>
<li>目前，ANSI和ISO先后制定了SQL-86、SQL-89……SQL-2011等多个SQL标准</li>
<li>2024，fysszlr被称为“SQL之耻”🏳️</li>
</ul>
</blockquote>
<h3 id="概述">概述</h3>
<blockquote>
<p>关系数据库中，可以通过SQL操作的数据对象有哪些？</p>
</blockquote>
<h4 id="SQL特点">SQL特点</h4>
<ul>
<li>综合统一</li>
<li>非过程化</li>
<li>面向集合</li>
<li>提供两种使用方式（交互式、嵌入式）</li>
<li>语言简洁、易学易用</li>
</ul>
<h4 id="基本概念">基本概念</h4>
<ul>
<li>
<p>基本表与导出表</p>
<ul>
<li>
<p><strong>基本表</strong>：是实际存在的，在存储中可用一个存储文件来表示</p>
</li>
<li>
<p><strong>导出表</strong>：是从基本表导出的表，由<strong>视图（View）<strong>和</strong>快照（Snapshot）</strong></p>
<ul>
<li>
<p>相对于快照视图更常用一些</p>
</li>
<li>
<p>视图是一个<strong>虚表</strong>，即在实际数据库中不单独存储视图的数据，只在数据库的数据字典中存储视图的定义</p>
</li>
<li>
<p>视图一经定义就可以和基本表一样进行查询等操作，也可以用来定义新的视图</p>
</li>
<li>
<p>视图定义示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CS_STudent</span><br><span class="line"><span class="keyword">As</span></span><br><span class="line">	<span class="keyword">SELECT</span> S#,SN,SA <span class="keyword">FROM</span> S</span><br><span class="line">	<span class="keyword">WHERE</span> SD <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>快照是某一个时间点，数据库内信息的静态副本；视图可更新，快照不可更新</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>关系数据库的三级模式结构</p>
<ul>
<li>用户——SQL，外模式——View，模式——Base table，内模式——Stored file</li>
<li>用户可以操作外模式，也可以直接操作模式</li>
<li>外模式可以对应到一个模式，也可以对应到多个模式</li>
<li>一个模式对应一个内模式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[SQL]</span><br><span class="line">B[View V1]</span><br><span class="line">C[View V2]</span><br><span class="line">D[Base table B1]</span><br><span class="line">E[Base table B2]</span><br><span class="line">F[Base table B3]</span><br><span class="line">G[Base table B4]</span><br><span class="line">H[Stored file S1]</span><br><span class="line">I[Stored file S2]</span><br><span class="line">J[Stored file S3]</span><br><span class="line">K[Stored file S4]</span><br><span class="line">A&lt;---&gt;D&lt;--&gt;H</span><br><span class="line">A&lt;--&gt;B--&gt;E&lt;--&gt;I</span><br><span class="line">A&lt;--&gt;C--&gt;F&lt;--&gt;J</span><br><span class="line">C--&gt;G&lt;--&gt;K</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SQL语法">SQL语法</h3>
<blockquote>
<p>SQL如何实现数据定义、查询、更新、控制操作？</p>
</blockquote>
<h4 id="SQL数据查询功能">SQL数据查询功能</h4>
<blockquote>
<p>这一部分内容其实不多，理解例子并灵活运用最重要</p>
<p>下文例子默认：</p>
<ul>
<li>S(S#, SN, SA, SD);</li>
<li>C(C#, CN, PC#);</li>
<li>SC(S#, C#, G);</li>
</ul>
</blockquote>
<ul>
<li>
<p>基本结构：SELECT-FROM-WHERE组成的查询块</p>
</li>
<li>
<pre><code class="language-sql">SELECT 目标列
FROM 基本表（或视图）
WHERE 检索条件;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 查询块的结构仍然是一个表，查询块可以进行关系代数中投影、选取、连接等操作的组合</span><br><span class="line"></span><br><span class="line">* SELECT对垂直方向进行操作，WHERE对水平方向进行操作</span><br><span class="line"></span><br><span class="line">* 技巧</span><br><span class="line"></span><br><span class="line">  * **投影操作**：如果没有WHERE，即为单纯的投影操作</span><br><span class="line"></span><br><span class="line">    * 采用**DISTINCT**可以消去SELECT结果中的重复行</span><br><span class="line"></span><br><span class="line">      ```sql</span><br><span class="line">      # 检索全体学生选的课号</span><br><span class="line">      SELECT DISTINCT C#</span><br><span class="line">      FROM SC;</span><br></pre></td></tr></table></figure>

* **选取检索**：WHERE可以包含多种符号

  * 比较运算符：=、&lt; &gt;(!=)、&gt;、&gt;=、&lt;、&lt;=

  * 布尔运算符：AND、OR、NOT 

  * ( )

  * 使用**BETWEEN AND**可以区间查询

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> G <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">85</span>;</span><br></pre></td></tr></table></figure>

* **排序检索**：使用**ORDER BY**进行排序检索

  * 格式：ORDER BY 列名 ASC（或DESC）

  * ASC：升序，DESC：降序；默认升序

  * 支持多列排序

  * ```sql
    # 检索全体学生信息，并按系号升序，同一个系按年龄降序排
    SELECT *
    FROM S
    ORDER BY SD, SA DESC;
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* **连表检索**：将多个相互关联的表按照一定条件连接起来，可以实现连表检索</span><br><span class="line"></span><br><span class="line">  * 此时WHERE需要包含连接条件和选取条件</span><br><span class="line"></span><br><span class="line">    ```sql</span><br><span class="line">    # 检索学生张华所学课程的成绩</span><br><span class="line">    SELECT SN, C#, G</span><br><span class="line">    FROM S, SC</span><br><span class="line">    WHERE S.S#=SC.S# AND SN=&#x27;张华&#x27;;</span><br></pre></td></tr></table></figure>

  * 可以定义**别名**实现表自身的连接

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索所有比李勇年龄大的学生姓名、年龄</span><br><span class="line"><span class="keyword">SELECT</span> X.SN, X.SA</span><br><span class="line"><span class="keyword">FROM</span> S X, S Y</span><br><span class="line"><span class="keyword">WHERE</span> X.SA<span class="operator">&gt;</span>Y.SA <span class="keyword">AND</span> Y.SN<span class="operator">=</span><span class="string">&#x27;李勇&#x27;</span>;</span><br></pre></td></tr></table></figure>

  * **外连接**
    在连接谓词某一边加\+或\*，则逻辑上为*所在边的表增加了一个空行；它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索所有学生的全部信息。</span><br><span class="line"><span class="keyword">SELECT</span> S.S#, SN,SA,SD, C#, G</span><br><span class="line"><span class="keyword">FROM</span> S, SC</span><br><span class="line"><span class="keyword">WHERE</span> S.S#<span class="operator">=</span>SC.S#(<span class="operator">*</span>);</span><br></pre></td></tr></table></figure>

* **嵌套检索**：WHERE的子句中可以包含另一个查询块，称为**子查询**或**嵌套查询**，包含子查询的语句称为**外部查询**

  * 普通子查询：与外部查询无关，可单独执行获得一组值

  * 相关子查询：把外查询的列值作为检索条件的条件值

  * 如果子查询返回单值，可以直接用比较运算符 =,&lt;&gt;,&gt;,&gt;=,&lt;,&lt;=等连接子查询

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索与李勇同岁的学生姓名</span><br><span class="line"><span class="keyword">SELECT</span> SN</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> S.SA<span class="operator">=</span></span><br><span class="line">	(<span class="keyword">SELECT</span> SA <span class="keyword">FROM</span> S</span><br><span class="line">	<span class="keyword">WHERE</span> SN<span class="operator">=</span><span class="string">&#x27;李勇&#x27;</span>);</span><br></pre></td></tr></table></figure>

  * 如果子查询返回一组值，则必须在比较运算符和子查询之间插入**ANY**、**ALL**、**IN**（在集合中）、**NOT IN** （不在集合中等）、**EXIST**（子查询不为空）、**NOT EXIST**（子查询不为空）等操作符啦

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索选修C2课程的成绩最高的学生学号</span><br><span class="line"><span class="keyword">SELECT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> C#<span class="operator">=</span>‘C2’ <span class="keyword">AND</span></span><br><span class="line">	G<span class="operator">&gt;=</span><span class="keyword">ALL</span></span><br><span class="line">	(<span class="keyword">SELECT</span> G <span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">WHERE</span> C#<span class="operator">=</span>‘C2’);</span><br></pre></td></tr></table></figure>

    特别的，可以用两个NOT EXIST表示任意或蕴含

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索至少选修了学生S2选修的全部课程的学生学号</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> SC SCX</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC SCY</span><br><span class="line">    <span class="keyword">WHERE</span> SCY.S# <span class="operator">=</span> <span class="string">&#x27;S2&#x27;</span> <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">        <span class="keyword">WHERE</span> S# <span class="operator">=</span> SCX.S# <span class="keyword">AND</span> C# <span class="operator">=</span> SCY.C#));</span><br></pre></td></tr></table></figure>

* **并、差、交检索**：**UNION**（并）、**MINUS**（差）、**INTERSECT**（交）

  * 并、差、交检索的操作对象必须是相容的，是同类关系，即必须有相同数量的属性列，且相应属性列的域也必须相同

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索无人选修的课程号和名称</span><br><span class="line"><span class="keyword">SELECT</span> C#，CN <span class="keyword">FROM</span> C <span class="keyword">WHERE</span> C# <span class="keyword">IN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> C# <span class="keyword">FROM</span> C</span><br><span class="line">    MINUS</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> C# <span class="keyword">FROM</span> SC); # 我觉得这里的<span class="keyword">DISTINCT</span>不必要</span><br></pre></td></tr></table></figure>

* **库函数检索**：库函数只能在SELECT和HAVING子句中出现

  | 库（集）函数 | 作用             |
  | ------------ | ---------------- |
  | COUNT()      | 按列值计个数     |
  | COUNT(\*)    | 对行记数         |
  | SUM()        | 对数值列求总和   |
  | AVG()        | 求数值列的平均值 |
  | MAX()        | 在列中找出最大值 |
  | MIN()        | 在列中找出最小值 |

* **分组检索**：按属性列（列组）将关系的元组分组，每组在这些分组属性列（列组）上具有相同值，对每一组执行SELECT操作

  * **HAVING**子句针对“分组”进行，必须和**GROUP BY** 连用，用于去掉不符合条件的若干分组

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 列名</span><br><span class="line">[<span class="keyword">HAVING</span> 条件表达式]</span><br></pre></td></tr></table></figure>

  * 出现的顺序：WHERE — GROUP BY — HAVING

    <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 求选修四门以上课程的学生学号和总成绩（不统计不及格的课程）。最后按降序列出总成绩排序名单。</span><br><span class="line"><span class="keyword">SELECT</span> S#, SUM（G）</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> G<span class="operator">&gt;=</span><span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> S#</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(G) <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

* **算术表达式检索**：SELECT子句中，可包括由属性列、常数、库函数、算 术运算符+-*/ 等组成的算术表达式；检索结果数据项名可用表达式表示或用“别名”来表示

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 有职工表EMP( EMP#，EMPN，JOB，SALARY，BONUS，DEPT )，要求检索所有PROGRAMMER的奖金大于工资<span class="number">25</span><span class="operator">%</span>的职工姓名和一年的总收入，并按奖金与工资之比的降序排列。</span><br><span class="line"><span class="keyword">SELECT</span> EMPN,BONUS<span class="operator">/</span>SALARY BS, <span class="number">12</span><span class="operator">*</span>(SALARY<span class="operator">+</span>BONUS) TOTAL</span><br><span class="line"><span class="keyword">FROM</span> EMP</span><br><span class="line"><span class="keyword">WHERE</span> JOB<span class="operator">=</span><span class="string">&#x27;PROGRAMMER&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> BONUS<span class="operator">&gt;</span><span class="number">0.25</span><span class="operator">*</span>SALARY</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> BONUS<span class="operator">/</span>SALARY <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

* **部分匹配查询**：&lt;列名&gt; **LIKE**/**NOT LIKE** &lt;字符串常量&gt;

  * %：代表任意序列的0个或多个字符
  * _：代表任意单个字符

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索所有姓刘的学生的学号、姓名</span><br><span class="line"><span class="keyword">SELECT</span> S#, SN</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> SN <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span>;</span><br></pre></td></tr></table></figure>

* **派生表查询**：当子查询出现在FROM子句中，则子查询生成的表称为临时派生表，该表也可作为主查询的操作对象

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 检索每个学生超出自己平均成绩的课程号。</span><br><span class="line"><span class="keyword">SELECT</span> S#, C#</span><br><span class="line"><span class="keyword">FROM</span> SC, (<span class="keyword">SELECT</span> S#, <span class="built_in">AVG</span>(G)</span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> S# ) <span class="keyword">AS</span> AVG_SC(AVG_S#,AVG_G)</span><br><span class="line"><span class="keyword">WHERE</span> SC.S# <span class="operator">=</span> AVG_SC.AVG_S# <span class="keyword">AND</span> SC.G <span class="operator">&gt;=</span> AVG_SC.AVG_G)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h4 id="SQL数据定义功能">SQL数据定义功能</h4>
<ul>
<li>
<p>定义、删除、修改基本表</p>
</li>
<li>
<p>定义、删除视图</p>
</li>
<li>
<p>定义、删除索引</p>
</li>
<li>
<table>
<thead>
<tr>
<th>操作对象</th>
<th>创建</th>
<th>删除</th>
<th>修改</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本表</td>
<td>Create Table</td>
<td>Drop Table</td>
<td>Alter Table</td>
</tr>
<tr>
<td>视图</td>
<td>Create View</td>
<td>Drop View</td>
<td>\</td>
</tr>
<tr>
<td>索引</td>
<td>Create Index</td>
<td>Drop Index</td>
<td>\</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="SQL视图操作">SQL视图操作</h4>
<ul>
<li>
<p>定义视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br><span class="line">[(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] …)]</span><br><span class="line"><span class="keyword">As</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">With</span> <span class="keyword">Check</span> Option]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Drop</span> <span class="keyword">View</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>视图消解</strong>（View Resolution）</p>
<ul>
<li>DBMS执行视图查询操作时，将对视图的操作转化为对原始数据字典的查询，这一过程叫做视图消解</li>
</ul>
</li>
<li>
<p>视图优点</p>
<ul>
<li>能够简化用户操作</li>
<li>使用户能够以多种角度看待同一数据</li>
<li>提供了一定程度的逻辑独立性</li>
<li>能够对数据提供安全保护</li>
</ul>
</li>
</ul>
<h4 id="SQL数据更新">SQL数据更新</h4>
<ul>
<li>插入数据——Insert语句</li>
<li>修改数据——Update语句</li>
<li>删除数据——Delete语句</li>
</ul>
<h4 id="SQL数据控制">SQL数据控制</h4>
<ul>
<li>定义完整性约束条件</li>
<li>支持事务操作</li>
<li>提供安全控制功能
<ul>
<li>授权</li>
<li>收回权限</li>
</ul>
</li>
</ul>
<h4 id="空值处理">空值处理</h4>
<ul>
<li>
<p><strong>空值</strong>：“不知道”、”不存在“、”无意义“的值，统一用NULL表示</p>
</li>
<li>
<p>属性定义中使用NOT NULL和UNIQUE约束的域以及主属性都不可以取空值</p>
</li>
<li>
<p>空值算数运算结果为NULL，布尔运算结果为UNKNOWN</p>
</li>
<li>
<p>空值判断：使用<strong>IS NULL</strong>或<strong>IS NOT NULL</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> SD <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在WHERE和HAVING子句中，只有使结果为TRUE的元组才会输出</p>
</li>
</ul>
<h3 id="嵌入式SQL">嵌入式SQL</h3>
<blockquote>
<p>SQL有哪些使用方式？</p>
</blockquote>
<ul>
<li>嵌入式SQL的意义
<ul>
<li>把SQL语句嵌入到高级语言中</li>
<li>把SQL的最佳特性与程序设计语言中的最佳特性（如过程处理能力）结合起来，使SQL功能更强，灵活性更强</li>
</ul>
</li>
<li>嵌入式SQL与高级语言区别
<ul>
<li>在SQL语句前加前缀（如EXEC SQL），区分SQL语句与主语言语句</li>
<li>需要通过游标遍历SQL产生的集合，对齐颗粒度</li>
<li>通过主变量（主语言程序变量） 交换数据</li>
</ul>
</li>
<li>嵌入式SQL的处理
<ul>
<li>对嵌入式SQL，DBMS需要进行预编译进行处理
<ul>
<li>DBMS需要将SQL语句翻译成高级语言源码，然后按主语言的通常方式进行编译、连接</li>
<li>优点：执行效率高</li>
<li>缺点：可移植性差
<ul>
<li>ODBC（Open Database Connectivity）<br>
由微软设计，便于数据库实现共同API，便于移植</li>
<li>JDBC（Java Database Connectivity）<br>
由Oracle设计，是Java的数据库访问标准</li>
</ul>
</li>
</ul>
</li>
<li>动态SQL允许程序在运行过程中“临时”组装SQL语句</li>
</ul>
</li>
</ul>
<h2 id="第四章-数据库保护">第四章 数据库保护</h2>
<blockquote>
<ul>
<li>数据完整性控制是为了防止数据库中存在不符合语义的数据，防止错误信息的输入和输出</li>
<li>数据安全性控制是保护数据库防止恶意的破坏和非法存取</li>
<li>安全性措施的防范对象是非法用户和非法操作，完整性措施的防范对象是不合语义的数据</li>
</ul>
</blockquote>
<h3 id="数据库安全性控制">数据库安全性控制</h3>
<blockquote>
<p>数据库中的数据会有哪些安全威胁，如何进行安全保护？</p>
</blockquote>
<h4 id="数据库安全性控制含义">数据库安全性控制含义</h4>
<ul>
<li>
<p><strong>数据库的安全性</strong>：保护数据库以防止不合法的使用所造成的<strong>数据泄漏、更改和破坏</strong></p>
<ul>
<li>向授权用户提供可靠的信息服务</li>
<li>拒绝对数据的非授权存取访问请求，保证数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益</li>
</ul>
</li>
<li>
<p>作用</p>
<ul>
<li>保护数据库防止恶意的破坏和非法存取</li>
</ul>
</li>
<li>
<p>计算机系统安全模型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[用户/应用程序]---B[DBMS]---C[OS&amp;Network]---D[DB]</span><br></pre></td></tr></table></figure>
<ul>
<li>用户/应用程序：用户标识和认证</li>
<li>DBMS：存取控制、审计</li>
<li>OS&amp;Network：操作系统与网络安全</li>
<li>DB：数据加密</li>
</ul>
</li>
</ul>
<h4 id="数据库安全性控制方法">数据库安全性控制方法</h4>
<ul>
<li>
<p>用户标识与认证</p>
<ul>
<li>数据库提供的<strong>最外层</strong>安全保护方法</li>
<li><strong>标识</strong>是指系统采用一定的方式标识其用户或应用程序的名字或身份</li>
<li><strong>认证</strong>是指系统在用户或应用程序登录时判断其是否为合法的授权用户</li>
<li>常用实现方式：用户名和口令</li>
</ul>
</li>
<li>
<p>存取控制</p>
<ul>
<li>
<p>确保合法用户按照指定权限使用DBMS和访问数据</p>
</li>
<li>
<p>包含<strong>用户权限定义</strong>和<strong>合法权限检查</strong>两部分，这两部分组成DBMS的安全子系统</p>
</li>
<li>
<p>自主存取控制（discretionary access control，DAC)</p>
<ul>
<li>
<p>根据预先定义的用户权限进行存取控制，用户权限是指用户对数据对象允许执行的操作类型，由数据对象和操作类型两个要素组成；用户间可以授予权限</p>
</li>
<li>
<p>示例</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th>数据对象</th>
<th>操作类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">模式</td>
<td>模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">模式</td>
<td>内模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">模式</td>
<td>外模式</td>
<td>建立、修改、检索</td>
</tr>
<tr>
<td style="text-align:left">数据</td>
<td>表</td>
<td>检索、插入、删除、修改</td>
</tr>
<tr>
<td style="text-align:left">数据</td>
<td>属性列</td>
<td>检索、插入、删除、修改</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>一般使用基于角色的存取控制（RBAC）</p>
<ul>
<li>用户级权限，用户对整个数据库权限的限定，与数据库中具体关系无关</li>
<li>关系级权限，用户使用关系和视图权限的限定</li>
<li>授予权限：Grant</li>
<li>取消权限：Revoke</li>
</ul>
</li>
</ul>
</li>
<li>
<p>强制存取方法（mandatory access control， MAC)</p>
<ul>
<li>MAC机制对比主体和客体的Label，最终确定主体是否能够存取客体
<ul>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体</li>
<li>仅当主体的许可证级别等于客体的密级时，该主体才能写相应的客体</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其它方法</p>
<ul>
<li>视图<br>
为不同用户定义不同视图，将用户访问限制在一定范围内</li>
<li>审计<br>
将用户对数据库的所有操作自动记录下来放入审计日志中</li>
<li>数据加密<br>
防止数据库中数据在存储和传输中失密</li>
</ul>
</li>
</ul>
<h4 id="可信计算机系统评测标准">可信计算机系统评测标准</h4>
<blockquote>
<p>目前大部分数据库系统处于C等级防护</p>
</blockquote>
<ul>
<li>标准
<ul>
<li>TCSEC（Trusted Computer System Evaluation Criteria)，1985，美国国防部制定，可信计算机标准</li>
<li>TDI（Trusted Database Interpretation），1991，美国国家计算机安全中心制定，数据库标准</li>
</ul>
</li>
</ul>
<h3 id="数据库完整性控制">数据库完整性控制</h3>
<blockquote>
<p>如何保证数据库中数据的正确、有效和一致性？</p>
</blockquote>
<h4 id="数据完整性含义">数据完整性含义</h4>
<ul>
<li><strong>数据完整性</strong>：指数据的正确性和相容性
<ul>
<li>正确性：数据应具有合法的类型，并在有效 的取值范围之内</li>
<li>相容性：指同一对象在不同关系中的数据是符合逻辑的</li>
</ul>
</li>
<li>作用
<ul>
<li>防止数据库中存在 不符合语义的数据，防止错误信息的输入和输出</li>
</ul>
</li>
</ul>
<h4 id="完整性约束条件">完整性约束条件</h4>
<ul>
<li>
<p>定义：施加在数据库数据之上的语义约束条件</p>
</li>
<li>
<p>作用对象可以是列、元组、关系</p>
</li>
<li>
<p>包含实体完整性、参照完整性、用户自定义完整性</p>
</li>
<li>
<p>静态约束</p>
<ul>
<li>数据库在每一确定状态必须满足的约束，是反映<strong>数据库状态合理性</strong>的约束</li>
<li>包含静态列级约束、静态元组约束、静态关系约束</li>
</ul>
</li>
<li>
<p>动态约束</p>
<ul>
<li>数据库在数据转变时必须满足的约束，是反映<strong>数据库状态变迁</strong>的约束</li>
<li>包含动态列级约束、动态元组约束、动态关系约束</li>
</ul>
</li>
</ul>
<h4 id="完整性控制">完整性控制</h4>
<ul>
<li>功能
<ul>
<li>定义功能<br>
提供定义完整性约束条件的机制</li>
<li>检查功能<br>
检查用户发出的操作请求是否违背了完整性约束条件</li>
<li>违约响应<br>
若违背了完整性约束条件，则采取一定措施来保证数据的完整性</li>
</ul>
</li>
<li>完整性检查时机
<ul>
<li><strong>立即执行约束</strong>：在一条语句执行完后立即进行完整性约束的检查</li>
<li><strong>延迟执行约束</strong>：在整个用户事务执行完毕后，再进行完整性约束的检查</li>
</ul>
</li>
<li>完整性规则形式定义：(D, O, A, C, P)
<ul>
<li>D ( Data ) 约束所作用的数据对象</li>
<li>O ( Operation ) 触发完整性检查的数据库操作</li>
<li>A ( Assertion ) 数据对象必须满足的断言或语义约束</li>
<li>C ( Condition ) 选择A作用的数据对象值的谓词</li>
<li>P ( Procedure ) 违反完整性规则时触发的过程</li>
</ul>
</li>
</ul>
<h2 id="第五章-关系数据理论">第五章 关系数据理论</h2>
<blockquote>
<p>什么样的关系是好关系？没有<strong>插入异常</strong>、<strong>删除异常</strong>、<strong>数据冗余</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A[关系的规范化]</span><br><span class="line">B[关系数据理论]</span><br><span class="line">C[规范化方法：模式分解]</span><br><span class="line">D[关系模式规范标准：范式]</span><br><span class="line">E[数据依赖：函数依赖/多值依赖]</span><br><span class="line">E--&gt;D--&gt;C</span><br><span class="line">E-.-&gt;B</span><br><span class="line">D-.-&gt;B</span><br><span class="line">C-.-&gt;B</span><br><span class="line">B--指导--&gt;A</span><br></pre></td></tr></table></figure>
<p>todo：</p>
<ul>
<li>多值依赖和4NF部分有未完成事宜</li>
<li>无损分解判定算法有未完成事宜</li>
<li>候选码求解算法有未完成事宜</li>
</ul>
</blockquote>
<h3 id="函数依赖">函数依赖</h3>
<h4 id="定义">定义</h4>
<ul>
<li><strong>X–&gt;Y</strong>：有属性X和Y，若对于X的每个具体值，Y有唯一的值与之对应，则称“X函数确定Y”或“Y函数依赖于X”</li>
<li><strong>平凡的函数依赖</strong>：X–&gt;Y，且$Y\subseteq X$</li>
<li><strong>非平凡的函数依赖</strong>：X–&gt;Y，且$Y\nsubseteq X$</li>
<li><strong>决定因素</strong>：X–&gt;Y，则X为决定因素</li>
<li>类型：1:1、1:m、n:m</li>
</ul>
<h4 id="三种函数依赖">三种函数依赖</h4>
<ul>
<li><strong>完全函数依赖</strong>：若X–&gt;Y，且X的任意真子集都无法确定Y，则Y对X完全函数依赖，记作$X\overset{f}\rightarrow Y$</li>
<li><strong>部分函数依赖</strong>：若X–&gt;Y，且存在X真子集确定Y，则Y对X部分函数依赖，记作$X\overset{p}\rightarrow Y$</li>
<li><strong>传递函数依赖</strong>：若X–&gt;Y，Y–&gt;Z，且Y无法确定X，则Z对X传递函数依赖，记作$X\overset{t}\rightarrow Z$</li>
</ul>
<h4 id="函数依赖公理系统">函数依赖公理系统</h4>
<ul>
<li>有属性集合X和Y，若从F的函数依赖能推出$X\rightarrow Y$，则称F逻辑蕴含$X\rightarrow Y$</li>
<li>$F$的闭包记作$F^+$</li>
<li><strong>Armstrong公理系统</strong>
<ul>
<li>自反律：若$Y\subseteq X$，则$X\rightarrow Y$</li>
<li>增广率：若$X\rightarrow Y$，则$XZ\rightarrow YZ$</li>
<li>传递率：若$X\rightarrow Y,\ Y\rightarrow Z$，则$X\rightarrow Z$</li>
</ul>
</li>
<li><strong>Armstrong公理推论</strong>
<ul>
<li>合并规则：若$X\rightarrow Y,\ X\rightarrow Z$，则$X\rightarrow YZ$</li>
<li>伪传递规则：若$X\rightarrow Y,\ WY\rightarrow Z$，则$WX\rightarrow YZ$</li>
<li>分解规则：若$X\rightarrow Y,\ Z\subseteq Y$，则$X\rightarrow Z$</li>
<li>由合并规则和分解规则可推出如下定理
<ul>
<li>$X\rightarrow A_1, A_2…A_k$成立，与$X\rightarrow A_i(i=1,2,…,k)$等价，X能推出A的任意子集</li>
</ul>
</li>
</ul>
</li>
<li>属性集的闭包
<ul>
<li>定义：属性集X关于函数依赖集F的闭包</li>
<li>定理：若$X\rightarrow Y$能从Armstrong公理系统推出，则$Y\subseteq X_F^+$</li>
</ul>
</li>
<li>Armstrong公理系统的有效性与完备性
<ul>
<li>有效性
<ul>
<li>指由F出发根据Armstrong公理推导出来的每个函数依赖一 定在F所蕴含的函数依赖的全体之中</li>
<li>有效性由Armstrong公理系统的正确性证明</li>
</ul>
</li>
<li>完备性
<ul>
<li>F所蕴含的函数依赖的全体中的每一个函数依赖，必定可以由F根据Armstrong公理导出</li>
<li>证明：使用两个特殊元组t，s辅助证明</li>
</ul>
</li>
</ul>
</li>
<li>函数依赖集等价与覆盖
<ul>
<li>若$F^+=G^+$，则称F+与G+等价</li>
<li>若$F^+=G^+$，则$F\subseteq G^+$、$G\subseteq F^+$，称F覆盖G，同时G覆盖F</li>
</ul>
</li>
<li>函数依赖集的最小依赖集
<ul>
<li>要求
<ul>
<li>右部为单属性</li>
<li>没有多余的函数依赖（Functional Dependency，FD）</li>
<li>每个FD左部没有多余属性</li>
</ul>
</li>
<li>极小化方法
<ol>
<li>用右部单属性推导式替代右部集合推导式</li>
<li>检查所有FD，删去所有多余项</li>
<li>检查所有FD，删去所有多余左部属性</li>
<li>重复以上步骤若干次</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="规范化">规范化</h3>
<blockquote>
<p>发展过程：</p>
<ul>
<li>1971-1972：CODD系统提出1NF，2NF，3NF的概念</li>
<li>1974：CODD 和BOYCE提出BCNF</li>
<li>1976：FAGIN 提出4NF，后来又提出了“投影-连接范式” PJNF，也称 5NF</li>
</ul>
<p>范式间关系：<br>
$1NF\subset2NF\subset3NF\subset BCNF\subset4NF\subset5NF$</p>
</blockquote>
<h4 id="范式概念（1NF）">范式概念（1NF）</h4>
<ul>
<li>如果某个关系满足某个指定的约束集，则称它属于某种<strong>范式</strong>（Normal Form）</li>
<li><strong>1NF</strong>
<ul>
<li>最低要求</li>
<li>定义：一个关系只包含<strong>原子值</strong></li>
<li>满足1NF的称为<strong>规范化关系</strong>，简称范式</li>
</ul>
</li>
<li><strong>规范化</strong>：一个低一级范式的关系模式，通过模式分解转换为若干个高级范式的关系模式的集合的过程</li>
</ul>
<h4 id="与函数依赖相关的范式（2NF-3NF-BCNF）">与函数依赖相关的范式（2NF, 3NF, BCNF）</h4>
<ul>
<li>
<p><strong>2NF</strong></p>
<ul>
<li>定义：$R\in 1NF$，且每个非主属性完全依赖于码（主属性可以部分依赖于码）</li>
<li>既要依赖于主键，又不能仅仅依赖码的一部分</li>
<li>规范化：用画图法从1NF中消除非主属性对码的部分函数依赖</li>
<li>插入异常依然存在；删除异常会导致连锁信息被删除；数据冗余得到一定改善</li>
</ul>
</li>
<li>
<p><strong>3NF</strong></p>
<ul>
<li>定义：$R\in2NF$，且每个非主属性不传递依赖于R的任何码</li>
<li>所有的异常都消失了（表面上）</li>
</ul>
</li>
<li>
<p><strong>BCNF</strong></p>
<ul>
<li>当某些特定情况发生时，3NF可能依然存在各种异常</li>
<li>定义
<ul>
<li>$R\in 1NF$，对所有X–&gt;Y，且$Y\nsubseteq X$时，都有X含有码</li>
</ul>
</li>
<li>性质
<ul>
<li>所有属性都完全函数依赖于（不包含该属性的）候选码</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多值依赖与第四范式">多值依赖与第四范式</h3>
<blockquote>
<p>函数依赖反应了现实世界实体间的相互约束</p>
<p>现实世界实体间还有其它约束：</p>
<ul>
<li>多值依赖</li>
<li>连接依赖</li>
<li>分层依赖</li>
<li>相互依赖</li>
</ul>
</blockquote>
<h4 id="多值依赖">多值依赖</h4>
<ul>
<li>定义
<ul>
<li>若对于X，Y，Z（其中Z=U-X-Y），Y的值决定于X的值，且与Z值无关，则称多值依赖X–&gt;–&gt;Y成立</li>
<li>也即：当X确定了，Y和Z都可以有被X决定的多个值，但它们之间是相互独立的</li>
</ul>
</li>
</ul>
<h4 id="4NF">4NF</h4>
<h3 id="模式分解的理论">模式分解的理论</h3>
<h4 id="模式分解的定义">模式分解的定义</h4>
<ul>
<li>若$F_i={X\rightarrow Y\mid X\rightarrow Y\in F^+\ \and\ XY\subseteq U_i}$，则称Fi为F在Ui上的投影</li>
<li>关系模式R&lt;U, F&gt;的一个分解${R_1&lt;U_1,F_1&gt;,R_2&lt;U_2, F_2&gt;,…,R_n&lt;U_n,F_n&gt;}$，其中$U=\Sigma U_i$</li>
</ul>
<h4 id="分解的无损连接性">分解的无损连接性</h4>
<ul>
<li>
<p>定义</p>
<ul>
<li>对于关系模式R&lt;U, F&gt;的分解，r为R中任何一个关系，若将分解中所有属于r的部分连接，仍能得到r，则称该分解为<strong>无损分解</strong>，具有<strong>无损连接性</strong></li>
</ul>
</li>
<li>
<p>判定算法</p>
<ul>
<li>仅分解为两部分时的判断算法：R1， R2的共同属性至少构成 R1、R2 二者之一的侯选码，则为无损连接</li>
</ul>
</li>
</ul>
<h4 id="分解的保持函数依赖性">分解的保持函数依赖性</h4>
<ul>
<li>定义
<ul>
<li>若$F+=(\Sigma F_i)+$，则称分解保持函数依赖</li>
</ul>
</li>
<li>判定算法
<ul>
<li>计算$(\Sigma F_i)+$，验证F的每一条依赖是否在$(\Sigma F_i)+$中</li>
</ul>
</li>
</ul>
<h4 id="模式分解的原则">模式分解的原则</h4>
<ul>
<li>具有无损连接性</li>
<li>保持函数依赖</li>
</ul>
<h4 id="模式分解的算法">模式分解的算法</h4>
<ul>
<li>达到3NF且保持函数依赖的分解算法</li>
<li>达到3NF且同时保持无损连接与函数依赖的分解算法</li>
<li>达到BCNF无损连接分解算法</li>
</ul>
<h3 id="候选码的求解和算法">候选码的求解和算法</h3>
<h4 id="快速求解候选码的充分条件">快速求解候选码的充分条件</h4>
<h4 id="左边为单属性的函数依赖集候选码成员的图论判定方法">左边为单属性的函数依赖集候选码成员的图论判定方法</h4>
<h4 id="多属性依赖集候选码求解法">多属性依赖集候选码求解法</h4>
<h2 id="第六章-数据库设计">第六章 数据库设计</h2>
<h3 id="数据库设计方法概述">数据库设计方法概述</h3>
<blockquote>
<p>数据库设计的任务是什么？</p>
<p>数据库设计中的难点是什么，采用怎样的设计方法解决？</p>
</blockquote>
<h4 id="数据库设计">数据库设计</h4>
<ul>
<li>定义
<ul>
<li>对于一个给定的应用环境，<strong>设计优化的数据库逻辑结构和物理结构</strong>，建立数据库，使之能够有效地存储数据，为开发满足用户需求的应用系统奠定基础</li>
</ul>
</li>
<li>特点
<ul>
<li>要把<strong>数据设计</strong>和<strong>处理设计</strong>密切结合起来</li>
<li>与硬件、软件和管理紧密相关</li>
</ul>
</li>
</ul>
<h4 id="手工试凑法">手工试凑法</h4>
<ul>
<li>
<p>根据应用的数据要求与处理要求，直接设计数据库的结构</p>
</li>
<li>
<p>缺点</p>
<ul>
<li>数据间关系复杂，使用要求各式各样，很难仅凭经验进行设计</li>
<li>用户需求一旦改变，难以改变数据结构设计</li>
<li>数据库设计和DBMS绑定，难以移植</li>
<li>难以多人合作；难以交流分享设计</li>
</ul>
</li>
</ul>
<h4 id="规范设计法">规范设计法</h4>
<ul>
<li>运用软件工程的思想和方法，把整个设计过程划分为若干阶段，把复杂的大问题分为若干相对简单的小问题，每个阶段只解决整个设计中的部分问题</li>
<li>迭代和逐步求精的过程</li>
<li>步骤
<ul>
<li>需求分析</li>
<li>概念结构设计</li>
<li>逻辑结构设计</li>
<li>物理结构设计</li>
<li>数据库实施</li>
<li>数据库运行和维护</li>
</ul>
</li>
</ul>
<h3 id="数据库设计的需求分析">数据库设计的需求分析</h3>
<blockquote>
<p>怎样进行数据库设计的需求分析？</p>
</blockquote>
<h4 id="需求分析的目标">需求分析的目标</h4>
<ul>
<li>处理要求：指用户要完成什么处理功能，对处理的响应时间和处理方式的要求</li>
<li>信息要求：指系统中所涉及的数据及数据之间的联系，具体收集数据的名称、类型、长度等，确定数据之间联系的类型</li>
<li>安全性和完整性的要求</li>
</ul>
<h4 id="需求分析的方法">需求分析的方法</h4>
<ol>
<li>调查用户实际要求，与用户达成共识</li>
<li>分析、表达用户的需求
<ul>
<li>用<strong>数据流图</strong>表达数据和处理之间的关系</li>
<li>用<strong>数据字典</strong>描述系统中各类数据</li>
</ul>
</li>
</ol>
<h3 id="数据库概念结构设计">数据库概念结构设计</h3>
<blockquote>
<p>如何利用E-R法进行应用系统的概念模型设计？</p>
</blockquote>
<ol>
<li>局部E-R图设计</li>
<li>综合分E-R图形成总E-R图
<ul>
<li>解决冲突，将各分E-R图合并起来生成<strong>初步E-R图</strong>
<ul>
<li>冲突主要包括属性冲突、命名冲突、结构冲突</li>
<li><strong>属性冲突</strong>：属性的类型、取值范围或取值集合不同，或属性取值单位冲突——讨论协商解决</li>
<li><strong>命名冲突</strong>：包括属性名、实体名、联系名之间的同名异义，异名同义——建立命名表，统一命名</li>
<li><strong>结构冲突</strong>：
<ul>
<li>同一对象在不同应用中有不同抽象；如在一应用中为实体，在另一应用中为属性——把属性变为实体或实体变为属性</li>
<li>同一实体在不同分E-R图中属性个数、次序不同——属性求并，再适当调整次序</li>
<li>实体之间的联系在不同分E-R图中呈现不同类型———根据语义加以综合或调整</li>
</ul>
</li>
</ul>
</li>
<li>消除不必要的冗余，生成<strong>基本E-R图</strong>
<ul>
<li>初步E-R图可能存在冗余的联系和冗余的关系</li>
<li>分析法</li>
<li>规范化方法
<ol>
<li>将各种关系依赖转化为码之间的函数依赖</li>
<li>进行极小化处理</li>
<li>考察每一个在极小集中消失的函数依赖，确定是否为冗余</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="数据库逻辑结构设计">数据库逻辑结构设计</h3>
<blockquote>
<p>数据库的逻辑结构设计的主要内容是什么？</p>
</blockquote>
<ul>
<li>E-R图向关系模型的转换
<ul>
<li>将实体型、联系和多元联系，每个转换为一个关系模式</li>
<li>具有相同码的关系可以合并</li>
<li>对于实体型：实体的属性就是关系的属性，实体的码就是关系的码</li>
<li>对于联系：联系相连的属性的码以及联系的属性为关系的属性，候选码根据各实体的码组合决定</li>
<li>对于弱实体类型：创建一个新的关系，新关系主码为被依赖关系的主码和弱实体类型的码，属性为弱实体类型所有的属性</li>
<li>对于超类/子类联系：为超类和子类分别创建关系，超类关系包含所有子类均有的属性，以及一个子类判定码；子类关系包含超类的码和子类的属性</li>
</ul>
</li>
<li>关系模型的规范化和优化
<ul>
<li>规范化
<ul>
<li>按照数据依赖的理论，确定关系模型的范式等级</li>
</ul>
</li>
<li>优化
<ul>
<li>按系统的处理要求，确定是否进行模式合并或分解</li>
<li>可以对关系模式进行必要的分解
<ul>
<li><strong>水平分解</strong>：将关系的元组分为若干子集合，每个集合为一个子关系，以提高系统效率
<ul>
<li>二八原则：将经常使用的数据分解出来作为一个关系，其它数据作为另一个关系</li>
</ul>
</li>
<li><strong>垂直分解</strong>：将关系模式的属性分解为若干子集合，形成若干子关系模式
<ul>
<li>原则：经常在一起使用的属性从R中分解出来的形成一子关系模式</li>
<li>垂直分解必须保证无损连接性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设计用户子模式
<ul>
<li>根据局部应用的需求，结合具体DBMS的特点，设计用户外模式
<ul>
<li>列更符合用户习惯</li>
<li>对不同级别的用户定义不用的视图，保证系统的安全性</li>
<li>降低复杂查询的难度，简化使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库物理结构设计">数据库物理结构设计</h3>
<blockquote>
<p>数据库的物理结构设计的主要内容是什么？</p>
</blockquote>
<ul>
<li>物理结构包括数据在物理设备上的存储结构与存取方法</li>
<li>存储结构
<ul>
<li>存放位置
<ul>
<li>经常存取部分和存取频率较低部分分开存放</li>
<li>数据和日志备份放于不同的磁盘上</li>
</ul>
</li>
<li>系统配置
<ul>
<li>配置变量、存储分配参数、进行物理优化</li>
</ul>
</li>
</ul>
</li>
<li>存取方法
<ul>
<li>索引
<ul>
<li>包含索引记录/索引项</li>
<li>索引记录必须有序</li>
<li>索引并非越多越好</li>
</ul>
</li>
<li>聚集
<ul>
<li>将关系中某个属性（组）相同的记录存放在连续的物理块中，提高该属性的查询速度</li>
<li>一个关系只能参加一个聚集</li>
<li>经常进行连接操作的关系可以建立聚集</li>
<li>建立和维护聚集系统开销很大，对于更新操作多于连接操作的关系不应该使用聚集</li>
</ul>
</li>
<li>hash
<ul>
<li>通过hash将关键字转化为地址</li>
<li>使用hash无法加速区间查询方法</li>
<li>一般要求关系的大小可与之，而且不变</li>
<li>如果关系大小动态改变，则需要dbms提供动态hash存取方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第七章-存储管理和索引">第七章 存储管理和索引</h2>
<blockquote>
<p>总的来说，这章内容在CO和OS讲过一遍了（大概</p>
</blockquote>
<h3 id="物理存储系统">物理存储系统</h3>
<blockquote>
<p>DBMS如何在磁盘上以文件形式存储数据？</p>
</blockquote>
<h4 id="存储分级">存储分级</h4>
<ul>
<li>内存：cpu，内存DRAM</li>
<li>外存：固态硬盘SSD，机械硬盘HDD，网盘Network Storage</li>
<li>数据只有放入内存才能被处理</li>
<li>DBMS设定数据库的基本存储在磁盘上，DBMS管理内存和外存的数据交换</li>
<li>DBMS目标：最小化磁盘的主存键传输存储块的数量，即最小化磁盘存取次数</li>
</ul>
<h4 id="磁盘">磁盘</h4>
<ul>
<li>架构：盘片-磁道-扇区</li>
<li>时间：寻道时间+旋转时间+传输时间</li>
</ul>
<h3 id="数据存储结构">数据存储结构</h3>
<blockquote>
<p>DBMS如何在磁盘上以文件形式存储数据？</p>
</blockquote>
<h4 id="概述-2">概述</h4>
<ul>
<li>数据库的表映射到文件</li>
<li>文件被组织为记录的序列，记录被映射到磁盘块上</li>
<li>文件由若干磁盘块构成，块是存储分配和数据传输的单位</li>
<li>一个块可以包含几个记录，每条记录被完全包含在单个块中</li>
</ul>
<h4 id="文件的磁盘块分配">文件的磁盘块分配</h4>
<ul>
<li>连续分配：文件在块中连续存放</li>
<li>连接分配：数据块中包含下个数据块的指针</li>
<li>按簇分配：簇是连续的几个磁盘块，簇之间指针连接</li>
<li>索引分配：索引块中存放指向数据块的指针</li>
</ul>
<h4 id="数据库块-页">数据库块/页</h4>
<ul>
<li>
<p>每个页由头部header和数据构成</p>
</li>
<li>
<p>header包含了页中数据的元数据，例如：</p>
<ul>
<li>页大小</li>
<li>checksum</li>
<li>dbms版本</li>
</ul>
</li>
<li>
<p>分槽（slot）页结构</p>
<ul>
<li>Header中记录了已经使用的槽数，以及最后一个被用槽的偏移量，以及一个槽数组</li>
<li>槽数据记录的每个元组的偏移量</li>
<li>槽数组从开始向尾部增长，记录元组从尾部向开始增长，二者相遇被认为页满</li>
<li>便于存储变长记录</li>
</ul>
</li>
<li>
<p>记录（tuple）结构</p>
<ul>
<li>记录是字节序列，DBMS负责将其解释为属性类型和值
<ul>
<li>记录头部：元组的元数据，例如加锁信息</li>
<li>记录数据：属性的实际数据，不能超过一个页</li>
<li>唯一标识符ID</li>
</ul>
</li>
</ul>
</li>
<li>
<pre><code class="language-mermaid">graph LR
A[文件]
B[页]
C[Header]
D[Slot]
E[Tuple]
A--&gt;B--&gt;C
B--&gt;D--&gt;E
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 缓冲区管理	</span><br><span class="line"></span><br><span class="line">&gt; DBMS如何管理内存，以及从磁盘读写文件？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 这里的缓冲区，真的不是缓存吗？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 脑袋好痒，感觉又听了一遍计组</span><br><span class="line"></span><br><span class="line">* 缓冲区：主存中可以存储磁盘块副本的区域</span><br><span class="line">* 缓冲区管理区：缓存空间分配，内外存交换</span><br><span class="line">* 交换单位：块/页</span><br><span class="line">* 目标：最小化交换的块/页数</span><br><span class="line">* 页表、策略......</span><br><span class="line"></span><br><span class="line">### 索引</span><br><span class="line"></span><br><span class="line">&gt; DBMS如何提高数据访问效率？有哪些类型的索引，它们是如何构造的？</span><br><span class="line"></span><br><span class="line">#### 基本概念</span><br><span class="line"></span><br><span class="line">* 构成</span><br><span class="line"></span><br><span class="line">  * **索引域（搜索码）**：存储数据文件的属性组</span><br><span class="line">  * **指引**：指向记录在磁盘块的位置</span><br><span class="line"></span><br><span class="line">* 索引对部分属性进行了组织或排序，且大小比原记录小得多，利用DBMS快速有效访问</span><br><span class="line"></span><br><span class="line">* DBMS负责在执行查询时使用最恰当的索引</span><br><span class="line"></span><br><span class="line">* 分类</span><br><span class="line"></span><br><span class="line">  * 排序索引 vs. 哈希索引</span><br><span class="line">    * 字如其名~</span><br><span class="line">  * 聚集索引 vs. 非聚集索引</span><br><span class="line">    * 聚集索引：索引排列顺序和记录一致，又被称为**主索引**（Primary Index）</span><br><span class="line">    * 非聚集索引：索引顺序和记录不一致，又被称为**辅助索引**（Secondary Index）</span><br><span class="line">  * 稠密索引 vs. 稀疏索引</span><br><span class="line">    * 稠密索引：对于文件中每个搜索码都有索引项与其对应</span><br><span class="line">    * 稀疏索引：只有部分索引域有索引项，索引大小小，但查询慢；非聚集索引都是稀疏索引</span><br><span class="line"></span><br><span class="line">* 多级索引</span><br><span class="line"></span><br><span class="line">  &gt; 索引文件可能过大，所以需要多级索引以减小空间大小</span><br><span class="line"></span><br><span class="line">  * 二叉树索引：排列方式和二叉堆相同</span><br><span class="line">  * 多枝树索引：同一节点有多个关键字值的情况时使用</span><br><span class="line">  * B树</span><br><span class="line">  * B+树</span><br><span class="line">  * 哈希索引</span><br><span class="line"></span><br><span class="line">## 第八章 查询处理与查询优化</span><br><span class="line"></span><br><span class="line">&gt; 关系查询处理的四个阶段：</span><br><span class="line">&gt;</span><br><span class="line">&gt; * 查询分析</span><br><span class="line">&gt; * 查询检查</span><br><span class="line">&gt; * 查询优化</span><br><span class="line">&gt; * 查询执行</span><br><span class="line">&gt;</span><br><span class="line">&gt; 查询时间的主要影响因素：IO次数</span><br><span class="line"></span><br><span class="line">### 查询处理过程</span><br><span class="line"></span><br><span class="line">&gt; 从接收到SQL查询语句到语句执行，需要做哪些处理？</span><br><span class="line"></span><br><span class="line">#### 关系查询处理步骤</span><br><span class="line"></span><br><span class="line">1. 查询分析</span><br><span class="line">2. 查询检查</span><br><span class="line">3. 查询优化</span><br><span class="line">4. 查询执行</span><br><span class="line"></span><br><span class="line">#### 查询代价的度量</span><br><span class="line"></span><br><span class="line">* 影响因素：磁盘访问，CPU, 网络通信等</span><br><span class="line">* 从磁盘访问数据的**I/O代价**通常是最重要的代价</span><br><span class="line">* 使用访问磁盘的块数作为估计代价的因素</span><br><span class="line"></span><br><span class="line">### 查询操作的实现</span><br><span class="line"></span><br><span class="line">&gt; 选取、连接等操作是如何实现的？</span><br><span class="line"></span><br><span class="line">#### 选择运算实现算法</span><br><span class="line"></span><br><span class="line">* 全表扫描法</span><br><span class="line">  * 按照物理顺序读表的块到内存，检查每个元组，直到所有块都接受检查</span><br><span class="line">* 索引扫描法</span><br><span class="line">  * 先通过索引项找到目标索引项，再通过索引项找到元组</span><br><span class="line"></span><br><span class="line">#### 连接运算实现算法</span><br><span class="line"></span><br><span class="line">* 嵌套—循环法</span><br><span class="line">  * 两个表，一个为外循环，一个为内循环</span><br><span class="line">  * 需要检查每一种元组组合，代价高</span><br><span class="line">  * 元组较多的为外层关系</span><br><span class="line">* 索引嵌套—循环法</span><br><span class="line">  * 如果内层关系有索引，则可以用其索引加速连接查询过程</span><br><span class="line">  * 如果内外都有索引，则用元组较少的关系作为外层关系</span><br><span class="line">* 排序—合并法</span><br><span class="line">  * 将两个关系在连接属性上排序</span><br><span class="line">  * 用类似two pointers的方法遍历两个关系一遍</span><br><span class="line">  * 只能用于等值连接或自然连接</span><br><span class="line">* 哈希连接法</span><br><span class="line">  * 将两表的连接属性映射到一个集合上，只在集合的同一个元组中遍历查找连接项</span><br><span class="line">  * 只能用于等值连接或自然连接</span><br><span class="line"></span><br><span class="line">#### 排序算法</span><br><span class="line"></span><br><span class="line">* 快速排序：内存中可以完全容纳关系时使用</span><br><span class="line">* 外排序-归并</span><br><span class="line">  1. 简历多个排好序的归并段（run），仅包含关系的部分记录</span><br><span class="line">  2. 对归并段进行排序</span><br><span class="line"></span><br><span class="line">#### 其它算法</span><br><span class="line"></span><br><span class="line">* 去重：使重复数据相邻，再删除</span><br><span class="line">  * 排序</span><br><span class="line">  * 哈希</span><br><span class="line">* 投影：在每个元组上投影，再去重</span><br><span class="line">* 并差交</span><br><span class="line">  * 类似排序-合并法</span><br><span class="line">  * 或类似hash法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 表达式的执行</span><br><span class="line"></span><br><span class="line">* 物化（Materialized）</span><br><span class="line">  * 按次序每次执行一个运算，并将结果保存为一个临时关系，写入磁盘</span><br><span class="line">  * 适用性广泛，但临时表的写和读代价大</span><br><span class="line">* 流水线（Pipeline）</span><br><span class="line">  * 将运算过程整理为一个运算树</span><br><span class="line">  * 同时执行多个运算，将结果传递给下一个运算</span><br><span class="line">  * 不需要在磁盘存储临时关系</span><br><span class="line">  * 对于一些操作不适用，比如排序</span><br><span class="line"></span><br><span class="line">### 查询优化</span><br><span class="line"></span><br><span class="line">&gt; 查询优化的目标是什么？如何进行优化？</span><br><span class="line"></span><br><span class="line">#### 查询优化的必要性</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">SELECT SN</span><br><span class="line">FROM S, SC</span><br><span class="line">WHERE S.S# = SC.S# AND C#=’02’;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>该sql在好的查询语句和坏的查询语句下表现可能相差10^4倍！！！</p>
<h4 id="查询优化的目标">查询优化的目标</h4>
<p>选择一个高效执行的查询处理策略，使得查询代价 最小，即访问磁盘的块数最少</p>
<h4 id="查询优化方法">查询优化方法</h4>
<blockquote>
<p>查询计划：定义了每个操作的算法以及这些操作执行的顺序</p>
</blockquote>
<ul>
<li>查询的代数优化
<ul>
<li>关系代数表达式的优化，即按照一定的规则，<strong>改变代数表达式中操作的次序和组合</strong></li>
<li>启发式优化规则
<ul>
<li>选择运算尽早执行（减小中间关系——减少元组数据）</li>
<li>投影运算尽早执行（减小中间关系——减少属性数目）</li>
<li>把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来（减少扫描关系的次数）</li>
<li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算（把笛卡尔积与选择转换为连接）</li>
<li>找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用（中间结果复用）</li>
</ul>
</li>
<li>关系代数表达式等价变换规则
<ul>
<li>共十一条<br>
<s>因为打赌不会考这个所以没有记录（理直气壮）</s></li>
</ul>
</li>
</ul>
</li>
<li>查询的物理优化
<ul>
<li><strong>存取路径和底层操作算法的选择</strong>，包括基于规则或基于代价等</li>
<li>常用方法
<ul>
<li>基于规则的启发式优化方法</li>
<li>基于代价估算的优化方法</li>
<li>两者结合的优化方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="查询优化的一般步骤">查询优化的一般步骤</h4>
<ol>
<li>把查询转换成语法树，如关系代数语法树（查询树）</li>
<li>把查询树利用代数优化转换成优化后的标准形式</li>
<li>利用基于启发式规则的物理优化，选择底层的操作算法与存取路径，生成查询计划；利用基于代价的物理优化，选择代价最小的</li>
</ol>
<h2 id="第九章-事务处理技术">第九章 事务处理技术</h2>
<blockquote>
<p>事务是数据库恢复和并发控制的基本单位</p>
</blockquote>
<h3 id="事务的概念">事务的概念</h3>
<blockquote>
<p>在数据库系统运行过程中，有哪些情况可能造成数据丢失、错误或不一致？</p>
<p>什么是事务？事务有哪些特性？事务的实现机制有哪些？</p>
</blockquote>
<h4 id="事务的特性">事务的特性</h4>
<blockquote>
<p>ACID</p>
</blockquote>
<ul>
<li>原子性（Atomicity）：由恢复技术实现</li>
<li>一致性（Consistency）：由原子性保证</li>
<li>隔离性（Isolation）：由并发控制实现</li>
<li>持久性（Durability）：由恢复技术实现</li>
</ul>
<h4 id="事务的特性遭破坏的情况">事务的特性遭破坏的情况</h4>
<ul>
<li>多个事务并发运行时，不同事务的操作交叉进行</li>
<li>事务在运行过程中被强行停止</li>
</ul>
<h3 id="数据库恢复技术">数据库恢复技术</h3>
<blockquote>
<p>如何将数据库从各种故障中恢复？</p>
</blockquote>
<h4 id="概述-3">概述</h4>
<ul>
<li>将数据库从错误状态回复到已知正确状态</li>
<li>通过数据库管理系统的恢复子系统完成</li>
</ul>
<h4 id="故障的种类">故障的种类</h4>
<ul>
<li>事务内部的故障
<ul>
<li>人工对数据库进行回滚</li>
<li>死锁、运算溢出等</li>
</ul>
</li>
<li>系统故障
<ul>
<li>硬件错误、操作系统故障、掉电等</li>
<li>会使事务异常终止，不会破坏数据</li>
</ul>
</li>
<li>介质故障
<ul>
<li>硬盘损坏</li>
<li>破坏数据库，影响相关事务</li>
</ul>
</li>
<li>计算机病毒
<ul>
<li>对数据进行非法修改</li>
<li>基本不在考虑范围内</li>
</ul>
</li>
</ul>
<h4 id="恢复的实现技术">恢复的实现技术</h4>
<blockquote>
<p>核心思想：UNDO未完成的事务，REDO已完成的事务</p>
</blockquote>
<ul>
<li>故障对数据库系统的影响
<ol>
<li>数据本身被破坏</li>
<li>数据本身没有问题</li>
</ol>
</li>
<li>恢复原理：冗余</li>
<li>关键问题
<ul>
<li>如何建立冗余</li>
<li>如何通过冗余实施数据库恢复</li>
</ul>
</li>
<li>数据转储的两种状态
<ul>
<li>静态转储
<ul>
<li>系统中无事务运行时进行的转储操作，并且转储 过程中，不允许对数据库进行任何存取、修改</li>
<li>优点：保证副本的数据一致性</li>
<li>缺点：由于转储必须等待正在运行的事务结束才能开始，而新的事务必须等待转储结束才能执行，降低了数据库的可用性</li>
</ul>
</li>
<li>动态转储
<ul>
<li>转储期间允许对数据库进行存取或修改</li>
<li>优点：不影响数据库的可用性</li>
<li>缺点：不能保证副本上的数据正确、有效，还必须把转储期间各事务对数据库的修改记录下来，建立日志文件</li>
</ul>
</li>
</ul>
</li>
<li>数据转储的两种方式
<ul>
<li>海量转储
<ul>
<li>每次存储全部数据库</li>
</ul>
</li>
<li>增量转储
<ul>
<li>只存储上次更新的内容</li>
</ul>
</li>
</ul>
</li>
<li>日志文件的建立和使用
<ul>
<li>记录事务对数据库的操作</li>
<li>分为以记录为单位和以数据块为单位</li>
<li>必须先写日志文件，后写数据库</li>
<li>遇到事务故障和系统故障时，撤销事务，根据转储类型恢复数据</li>
</ul>
</li>
<li>UNDO
<ul>
<li>反向扫描日志文件，查找事务的更新操作</li>
<li>对更新操作执行逆操作，直到遇到该事务的开始标志为止</li>
</ul>
</li>
<li>检查点
<ul>
<li>纯日志恢复技术的缺点
<ul>
<li>搜索耗费时间多</li>
<li>不必要重做某些事务</li>
</ul>
</li>
<li>检查点技术可以改善效率，使得检查点前的事务不必重做</li>
<li>新增重新开始文件，动态维护检查点</li>
<li>恢复步骤
<ul>
<li>将检查点时的事务放入UNDO列表</li>
<li>从检查点开始正向扫描日志，将开始的事务放入UNDO，结束的事务放入REDO</li>
<li>UNDOUNDO的，REDOREDO的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="并发控制技术">并发控制技术</h3>
<blockquote>
<p>并发控制的基本思想与主要方法是什么？如何保证并发事务调度的正确性？</p>
</blockquote>
<h4 id="概述-4">概述</h4>
<ul>
<li>并发控制优点
<ul>
<li>提高系统吞吐量</li>
<li>减少平均相应时间</li>
</ul>
</li>
<li>问题
<ul>
<li>如果控制不当，会对数据一致性带来问题</li>
</ul>
</li>
<li>具体问题种类
<ul>
<li>丢失更新（Lost Update）</li>
<li>“脏”数据的读出（Dirty Read）</li>
<li>不可重复读（Non-Repeatable Read）</li>
</ul>
</li>
</ul>
<h4 id="并发控制主要方法">并发控制主要方法</h4>
<ul>
<li>
<p>采用封锁机制，合理调度并发事务，避免并发事务间的互相干扰造成数据的不一致</p>
</li>
<li>
<p>封锁的类型</p>
<ul>
<li>
<p>排它锁（X锁）：不可读不可写</p>
</li>
<li>
<p>共享锁（S锁）：可读不可写</p>
</li>
<li>
<table>
<thead>
<tr>
<th>t1\t2</th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>S</td>
<td>N</td>
<td>Y</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>一级封锁协议——防止丢失更新</p>
<ul>
<li>事务在修改数据前必须对其加X锁，直到事务结束</li>
<li>防止丢失修改，不能保证可重复读和不读“脏”数据</li>
</ul>
</li>
<li>
<p>二级封锁协议——防止读脏数据</p>
<ul>
<li>一级封锁协议+事务在读取数据前必须加S锁，直到读取结束</li>
<li>防止读“脏”数据，不能保证重复读</li>
</ul>
</li>
<li>
<p>三级封锁协议——防止不可重复度</p>
<ul>
<li>一级封锁协议+事务在读取数据前必须加S锁，直到事务结束</li>
<li>防止重复读</li>
</ul>
</li>
<li>
<p>封锁粒度：封锁对象的大小</p>
<ul>
<li>粒度大，并发性低，封锁机构简单，开销小</li>
<li>粒度小，并发性高，封锁机构复杂，开销大</li>
</ul>
</li>
<li>
<p>多粒度封锁协议</p>
<ul>
<li>
<p>多粒度树中每个结点可以被独立地加锁，覆盖所有子节点</p>
</li>
<li>
<p>显式封锁是当前结点被直接加锁</p>
</li>
<li>
<p>隐式封锁是当前节点的先祖被加锁导致当前结点加锁</p>
</li>
<li>
<p><strong>意向锁</strong></p>
<ul>
<li>
<p>对任意节点加锁时，必须先对其上级节点加意向锁</p>
</li>
<li>
<p>在后续加锁时，不需要额外检查下级节点的封锁，只需检查对象和它的上级结点</p>
</li>
<li>
<p>三种意向锁</p>
<ul>
<li>意向共享锁 IS</li>
<li>意向排它锁 IX</li>
<li>意向共享排它锁 SIX （<strong>先加S，再加IX</strong>）</li>
</ul>
</li>
<li>
<table>
<thead>
<tr>
<th>t1\t2</th>
<th>S</th>
<th>X</th>
<th>IS</th>
<th>IX</th>
<th>SIX</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>X</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>IS</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>IX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>SIX</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="活锁和死锁">活锁和死锁</h4>
<blockquote>
<p>CO还在追我</p>
</blockquote>
<ul>
<li>解决死锁的办法
<ul>
<li>预防死锁</li>
<li>死锁检测和解除</li>
</ul>
</li>
<li>预防死锁
<ul>
<li>一次封锁法</li>
<li>顺序封锁法</li>
</ul>
</li>
<li>死锁检测
<ul>
<li>超时法</li>
<li>等待图法</li>
</ul>
</li>
<li>死锁恢复
<ul>
<li>选择一个处理死锁代价最小的事务，将其撤销</li>
</ul>
</li>
</ul>
<h4 id="事务可串行化调度">事务可串行化调度</h4>
<ul>
<li>定义
<ul>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行执行它们时的结果相同，我们称这种调度策略为可串行化调度</li>
<li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li>
</ul>
</li>
<li><strong>两段锁协议</strong>（Two-phase Locking）
<ul>
<li>事务分为两个阶段，第一个阶段是获得封锁，也称为扩展阶段；第二个阶段是释放封锁，也称为收缩阶段</li>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再获得任何其它封锁</li>
</ul>
</li>
<li>执行两段锁协议的事务一定是可串行化调度的，但仍可能发生死锁</li>
</ul>
<h4 id="其它并发控制方法">其它并发控制方法</h4>
<ul>
<li>事务隔离级别</li>
<li>悲观与乐观并发控制技术</li>
<li>多版本并发控制技术</li>
</ul>
<h2 id="第十章-数据库技术新发展">第十章 数据库技术新发展</h2>
<blockquote>
<p>终于结束啦~~让我们来听听数据库的“新”技术</p>
</blockquote>
<h3 id="概述-5">概述</h3>
<blockquote>
<p>数据库技术有哪些新的发展方向？</p>
</blockquote>
<h4 id="SQL">SQL</h4>
<ul>
<li>传统关系型数据库，支持SQL操作、事务ACID特性</li>
<li>几千用户，TB级数据</li>
</ul>
<h4 id="NoSQL">NoSQL</h4>
<ul>
<li>Not only SQL，非关系型的数据库，水平可扩展、分布式</li>
<li>不使用SQL，不支持事务的ACID操作</li>
<li>HBase、MongoDB等</li>
</ul>
<h4 id="NewSQL">NewSQL</h4>
<ul>
<li>新的可扩展/高性能数据库</li>
<li>不仅具有NoSQL的海量数据存储管理能力，还保持了传统数据库支持ACID和SQL等特性</li>
<li>华为云数据库GaussDB，VoltDB，OceanBase等</li>
</ul>
<h3 id="分布式数据库概念与技术">分布式数据库概念与技术</h3>
<blockquote>
<p>什么是分布式数据库系统，分布式数据库的体系结构以及实现技术是怎样的？</p>
</blockquote>
<h4 id="分布式数据库系统基本概念">分布式数据库系统基本概念</h4>
<ul>
<li>分布式数据库系统定义
<ul>
<li>分布式数据库是由一组分布在计算机网络的不同结点上的数据组成，每个结点具有独立处理的能力（称为场地自治），可以执行局部应用，同时每个结点也能通过网络通信支持全局应用
<ul>
<li>局部应用：只操作一个结点上 数据库的应用</li>
<li>全局应用：操作两个或两个以上节点上数据库的应用</li>
</ul>
</li>
<li>分布性— 数据分布存储在网络的各个节点上</li>
<li>逻辑上的整体性—数据被一种机制联系在一起，构成一个有机整体</li>
<li>分布式数据库以“数据分布”为前提，强调场地自治性（局部应用）以及自治场地之间的协作性（全局应用），两者缺一不可
<ul>
<li>场地自治性：每个场地有自己的数据库、一组终端、运行局部DBMS，是独立的DBS，具有高度自治性</li>
<li>自治场地之间的协作性：各结点组成整体，从用户角度看，分布式数据库系统逻辑上如同一个集中式数据库一样，用户可以在任何场地执行全局应用</li>
</ul>
</li>
</ul>
</li>
<li>分布式数据库系统的特点
<ul>
<li>数据独立性
<ul>
<li>数据的逻辑独立性和物理独立性</li>
<li>数据的分布独立性
<ul>
<li>数据的逻辑分片、数据物理位置分布的细节、重复副本（冗余数据）一致性问题、局部结点上的数据模型等与用户程序无关</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>集中与自治相结合的控制结构</li>
<li>适当增加数据冗余
<ul>
<li>提高系统的可靠性、可用性</li>
<li>提高系统性能</li>
<li>不利于更新，增加了系统维护代价</li>
<li>全局的一致性、可串行性和可恢复性</li>
</ul>
</li>
</ul>
<h4 id="分布式数据库系统体系结构">分布式数据库系统体系结构</h4>
<ul>
<li>整体结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[全局外模式1]</span><br><span class="line">B[全局外模式2]</span><br><span class="line">C[全局概念模式]</span><br><span class="line">D[分片模式]</span><br><span class="line">E[分布模式]</span><br><span class="line">F[局部概念模式1]</span><br><span class="line">G[局部内模式1]</span><br><span class="line">H[局部DB1]</span><br><span class="line">I[局部概念模式2]</span><br><span class="line">J[局部内模式2]</span><br><span class="line">K[局部DB2]</span><br><span class="line">A---C</span><br><span class="line">B---C</span><br><span class="line">C---D---E</span><br><span class="line">E---F</span><br><span class="line">E---I</span><br><span class="line">F---G---H</span><br><span class="line">I---J---K</span><br></pre></td></tr></table></figure>
<ul>
<li>分布透明性
<ul>
<li>分片透明性</li>
<li>位置透明性</li>
<li>局部数据模型透明性</li>
</ul>
</li>
</ul>
<h4 id="分布式数据库系统主要技术">分布式数据库系统主要技术</h4>
<ul>
<li>分布式查询处理和优化</li>
<li>分布事务管理</li>
</ul>
<h3 id="云数据库">云数据库</h3>
<blockquote>
<p>什么是云数据库，其架构是怎样的？</p>
</blockquote>
<ul>
<li>云数据库
<ul>
<li>概述
<ul>
<li>云服务提供商建立计算、存储与网络资源池，基于这些资源池提供基础设施、平台和软件服务</li>
<li>用户可按需按量购买和使用云服务提供的各种服务</li>
</ul>
</li>
<li>挑战和机遇
<ul>
<li>如何更好的将云的底层资源池化、资源解耦优势发挥出来，支撑用户建立高可用、可拓展性、弹性的数据库系统</li>
</ul>
</li>
<li>数据库服务DataBase-as-a-Service，DBaaS
<ul>
<li>云数据库服务
<ul>
<li>一主多从</li>
</ul>
</li>
<li>云原生数据库技术
<ul>
<li>计算存储分离</li>
<li>计算节点无状态</li>
<li>存储集群灵巧化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>原生分布式数据库
<ul>
<li>由多个同构型的数据库节点组成</li>
<li>每个节点都具备分布式处理的能力</li>
<li>相互连接组合形成面向用户的单个数据库</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
